.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ZOOM 3"
.TH ZOOM 3 "2010-06-08" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ZOOM \- Perl extension implementing the ZOOM API for Information Retrieval
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 12
\& use ZOOM;
\& eval {
\&     $conn = new ZOOM::Connection($host, $port,
\&                                  databaseName => "mydb");
\&     $conn\->option(preferredRecordSyntax => "usmarc");
\&     $rs = $conn\->search_pqf(\*(Aq@attr 1=4 dinosaur\*(Aq);
\&     $n = $rs\->size();
\&     print $rs\->record(0)\->render();
\& };
\& if ($@) {
\&     print "Error ", $@\->code(), ": ", $@\->message(), "\en";
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a nice, Perlish implementation of the \s-1ZOOM\s0
Abstract \s-1API\s0 described and documented at http://zoom.z3950.org/api/
.PP
the \s-1ZOOM\s0 module is implemented as a set of thin classes on top of the
non-OO functions provided by this distribution's \f(CW\*(C`Net::Z3950::ZOOM\*(C'\fR
module, which in 
turn is a thin layer on top of the ZOOM-C code supplied as part of
Index Data's \s-1YAZ\s0 Toolkit.  Because ZOOM-C is also the underlying code
that implements \s-1ZOOM\s0 bindings in \*(C+, Visual Basic, Scheme, Ruby, .NET
(including C#) and other languages, this Perl module works compatibly
with those other implementations.  (Of course, the point of a public
\&\s-1API\s0 such as \s-1ZOOM\s0 is that all implementations should be compatible
anyway; but knowing that the same code is running is reassuring.)
.PP
The \s-1ZOOM\s0 module provides two enumerations (\f(CW\*(C`ZOOM::Error\*(C'\fR and
\&\f(CW\*(C`ZOOM::Event\*(C'\fR), three utility functions \f(CW\*(C`diag_str()\*(C'\fR, \f(CW\*(C`event_str()\*(C'\fR
and \f(CW\*(C`event()\*(C'\fR in the \f(CW\*(C`ZOOM\*(C'\fR package itself, and eight classes:
\&\f(CW\*(C`ZOOM::Exception\*(C'\fR,
\&\f(CW\*(C`ZOOM::Options\*(C'\fR,
\&\f(CW\*(C`ZOOM::Connection\*(C'\fR,
\&\f(CW\*(C`ZOOM::Query\*(C'\fR,
\&\f(CW\*(C`ZOOM::ResultSet\*(C'\fR,
\&\f(CW\*(C`ZOOM::Record\*(C'\fR,
\&\f(CW\*(C`ZOOM::ScanSet\*(C'\fR
and
\&\f(CW\*(C`ZOOM::Package\*(C'\fR.
Of these, the Query class is abstract, and has four concrete
subclasses:
\&\f(CW\*(C`ZOOM::Query::CQL\*(C'\fR,
\&\f(CW\*(C`ZOOM::Query::PQF\*(C'\fR,
\&\f(CW\*(C`ZOOM::Query::CQL2RPN\*(C'\fR
and
\&\f(CW\*(C`ZOOM::Query::CCL2RPN\*(C'\fR.
Finally, it also provides a
\&\f(CW\*(C`ZOOM::Query::Log\*(C'\fR
module which supplies a useful general-purpose logging facility.
Many useful \s-1ZOOM\s0 applications can be built using only the Connection,
ResultSet, Record and Exception classes, as in the example
code-snippet above.
.PP
A typical application will begin by creating an Connection object,
then using that to execute searches that yield ResultSet objects, then
fetching records from the result-sets to yield Record objects.  If an
error occurs, an Exception object is thrown and can be dealt with.
.PP
More sophisticated applications might also browse the server's indexes
to create a ScanSet, from which indexed terms may be retrieved; others
might send ``Extended Services'' Packages to the server, to achieve
non-standard tasks such as database creation and record update.
Searching using a query syntax other than \s-1PQF\s0 can be done using an
query object of one of the Query subclasses.  Finally, sets of options
may be manipulated independently of the objects they are associated
with using an Options object.
.PP
In general, method calls throw an exception if anything goes wrong, so
you don't need to test for success after each call.  See the section
below on the Exception class for details.
.SH "UTILITY FUNCTIONS"
.IX Header "UTILITY FUNCTIONS"
.SS "\fIZOOM::diag_str()\fP"
.IX Subsection "ZOOM::diag_str()"
.Vb 1
\& $msg = ZOOM::diag_str(ZOOM::Error::INVALID_QUERY);
.Ve
.PP
Returns a human-readable English-language string corresponding to the
error code that is its own parameter.  This works for any error-code
returned from
\&\f(CW\*(C`ZOOM::Exception::code()\*(C'\fR,
\&\f(CW\*(C`ZOOM::Connection::error_x()\*(C'\fR
or
\&\f(CW\*(C`ZOOM::Connection::errcode()\*(C'\fR,
irrespective of whether it is a member of the \f(CW\*(C`ZOOM::Error\*(C'\fR
enumeration or drawn from the \s-1BIB\-1\s0 diagnostic set.
.SS "\fIZOOM::diag_srw_str()\fP"
.IX Subsection "ZOOM::diag_srw_str()"
.Vb 1
\& $msg = ZOOM::diag_srw_str(18);
.Ve
.PP
Returns a human-readable English-language string corresponding to the
specified \s-1SRW\s0 error code.
.SS "\fIZOOM::event_str()\fP"
.IX Subsection "ZOOM::event_str()"
.Vb 1
\& $msg = ZOOM::event_str(ZOOM::Event::RECV_APDU);
.Ve
.PP
Returns a human-readable English-language string corresponding to the
event code that is its own parameter.  This works for any value of the
\&\f(CW\*(C`ZOOM::Event\*(C'\fR enumeration.
.SS "\fIZOOM::event()\fP"
.IX Subsection "ZOOM::event()"
.Vb 4
\& $connsRef = [ $conn1, $conn2, $conn3 ];
\& $which = ZOOM::event($connsRef);
\& $ev = $connsRef\->[$which\-1]\->last_event()
\&     if ($which != 0);
.Ve
.PP
Used only in complex asynchronous applications, this function takes a
reference to a list of Connection objects, waits until an event
occurs on any one of them, and returns an integer indicating which of
the connections it occurred on.  The return value is a 1\-based index
into the list; 0 is returned if no event occurs within the longest
timeout specified by the \f(CW\*(C`timeout\*(C'\fR options of all the connections.
.PP
See the section below on asynchronous applications.
.SH "CLASSES"
.IX Header "CLASSES"
The eight \s-1ZOOM\s0 classes are described here in ``sensible order'':
first, the four commonly used classes, in the he order that they will
tend to be used in most programs (Connection, ResultSet, Record,
Exception); then the four more esoteric classes in descending order of
how often they are needed.
.PP
With the exception of the Options class, which is an extension to the
\&\s-1ZOOM\s0 model, the introduction to each class includes a link to the
relevant section of the \s-1ZOOM\s0 Abstract \s-1API\s0.
.SS "ZOOM::Connection"
.IX Subsection "ZOOM::Connection"
.Vb 9
\& $conn = new ZOOM::Connection("indexdata.dk:210/gils");
\& print("server is \*(Aq", $conn\->option("serverImplementationName"), "\*(Aq\en");
\& $conn\->option(preferredRecordSyntax => "usmarc");
\& $rs = $conn\->search_pqf(\*(Aq@attr 1=4 mineral\*(Aq);
\& $ss = $conn\->scan(\*(Aq@attr 1=1003 a\*(Aq);
\& if ($conn\->errcode() != 0) {
\&    die("somthing went wrong: " . $conn\->errmsg())
\& }
\& $conn\->destroy()
.Ve
.PP
This class represents a connection to an information retrieval server,
using an \s-1IR\s0 protocol such as \s-1ANSI/NISO\s0 Z39.50, \s-1SRW\s0 (the
Search/Retrieve Webservice), \s-1SRU\s0 (the Search/Retrieve \s-1URL\s0) or
OpenSearch.  Not all of these protocols require a low-level connection
to be maintained, but the Connection object nevertheless provides a
location for the necessary cache of configuration and state
information, as well as a uniform \s-1API\s0 to the connection-oriented
facilities (searching, index browsing, etc.), provided by these
protocols.
.PP
See the description of the \f(CW\*(C`Connection\*(C'\fR class in the \s-1ZOOM\s0 Abstract
\&\s-1API\s0 at
http://zoom.z3950.org/api/zoom\-current.html#3.2
.PP
\fIMethods\fR
.IX Subsection "Methods"
.PP
\fInew()\fR
.IX Subsection "new()"
.PP
.Vb 7
\& $conn = new ZOOM::Connection("indexdata.dk", 210);
\& $conn = new ZOOM::Connection("indexdata.dk:210/gils");
\& $conn = new ZOOM::Connection("tcp:indexdata.dk:210/gils");
\& $conn = new ZOOM::Connection("http:indexdata.dk:210/gils");
\& $conn = new ZOOM::Connection("indexdata.dk", 210,
\&                               databaseName => "mydb",
\&                               preferredRecordSyntax => "marc");
.Ve
.PP
Creates a new Connection object, and immediately connects it to the
specified server.  If you want to make a new Connection object but
delay forging the connection, use the \f(CW\*(C`create()\*(C'\fR and \f(CW\*(C`connect()\*(C'\fR
methods instead.
.PP
This constructor can be called with two arguments or a single
argument.  In the former case, the arguments are the name and port
number of the Z39.50 server to connect to; in the latter case, the
single argument is a \s-1YAZ\s0 service-specifier string of the form
.PP
When the two-option form is used (which may be done using a vacuous
second argument of zero), any number of additional argument pairs may
be provided, which are interpreted as key-value pairs to be set as
options after the Connection object is created but before it is
connected to the server.  This is a convenient way to set options,
including those that must be set before connecting such as
authentication tokens.
.PP
The server-name string is of the form:
.IP "\(bu" 4
[\fIscheme\fR:]\fIhost\fR[:\fIport\fR][/\fIdatabaseName\fR]
.PP
In which the \fIhost\fR and \fIport\fR parts are as in the two-argument
form, the \fIdatabaseName\fR if provided specifies the name of the
database to be used in subsequent searches on this connection, and the
optional \fIscheme\fR (default \f(CW\*(C`tcp\*(C'\fR) indicates what protocol should be
used.  At present, the following schemes are supported:
.IP "tcp" 4
.IX Item "tcp"
Z39.50 connection.
.IP "ssl" 4
.IX Item "ssl"
Z39.50 connection encrypted using \s-1SSL\s0 (Secure Sockets Layer).  Not
many servers support this, but Index Data's Zebra is one that does.
.IP "unix" 4
.IX Item "unix"
Z39.50 connection on a Unix-domain (local) socket, in which case the
\&\fIhostname\fR portion of the string is instead used as a filename in the
local filesystem.
.IP "http" 4
.IX Item "http"
\&\s-1SRU\s0 connection over \s-1HTTP\s0.
.PP
If the \f(CW\*(C`http\*(C'\fR scheme is used, the particular \s-1SRU\s0 flavour to be used
may be specified by the \f(CW\*(C`sru\*(C'\fR option, which takes the following
values:
.IP "soap" 4
.IX Item "soap"
\&\s-1SRU\s0 over \s-1SOAP\s0 (i.e. what used to be called \s-1SRW\s0).
This is the default.
.IP "get" 4
.IX Item "get"
\&\*(L"\s-1SRU\s0 Classic\*(R" (i.e. \s-1SRU\s0 over \s-1HTTP\s0 \s-1GET\s0).
.IP "post" 4
.IX Item "post"
\&\s-1SRU\s0 over \s-1HTTP\s0 \s-1POST\s0.
.PP
If an error occurs, an exception is thrown.  This may indicate a
networking problem (e.g. the host is not found or unreachable), or a
protocol-level problem (e.g. a Z39.50 server rejected the Init
request).
.PP
\fIcreate()\fR / \fIconnect()\fR
.IX Subsection "create() / connect()"
.PP
.Vb 7
\& $options = new ZOOM::Options();
\& $options\->option(implementationName => "my client");
\& $options\->option(implementationId => 12345);
\& $conn = create ZOOM::Connection($options)
\& # or
\& $conn = create ZOOM::Connection(implementationName => "my client",
\&                                 implementationId => 12345);
\&
\& $conn\->connect($host, 0);
.Ve
.PP
The usual Connection constructor, \f(CW\*(C`new()\*(C'\fR brings a new object into
existence and forges the connection to the server all in one
operation, which is often what you want.  For applications that need
more control, however, these two methods separate the two steps,
allowing additional steps in between such as the setting of options.
.PP
\&\f(CW\*(C`create()\*(C'\fR creates and returns a new Connection object, which is
\&\fInot\fR connected to any server.  It may be passed an options block, of
type \f(CW\*(C`ZOOM::Options\*(C'\fR (see below), into which options may be set
before or after the creation of the Connection.  Alternatively and
equivalently, \f(CW\*(C`create()\*(C'\fR may be passed a list of key-value option
pairs directly.  The connection to the server may then be forged by
the \f(CW\*(C`connect()\*(C'\fR method, the arguments of which are the same as those
of the \f(CW\*(C`new()\*(C'\fR constructor.
.PP
\fIerror_x()\fR / \fIerrcode()\fR / \fIerrmsg()\fR / \fIaddinfo()\fR / \fIdiagset()\fR
.IX Subsection "error_x() / errcode() / errmsg() / addinfo() / diagset()"
.PP
.Vb 5
\& ($errcode, $errmsg, $addinfo, $diagset) = $conn\->error_x();
\& $errcode = $conn\->errcode();
\& $errmsg = $conn\->errmsg();
\& $addinfo = $conn\->addinfo();
\& $diagset = $conn\->diagset();
.Ve
.PP
These methods may be used to obtain information about the last error
to have occurred on a connection \- although typically they will not
been used, as the same information is available through the
\&\f(CW\*(C`ZOOM::Exception\*(C'\fR that is thrown when the error occurs.  The
\&\f(CW\*(C`errcode()\*(C'\fR,
\&\f(CW\*(C`errmsg()\*(C'\fR,
\&\f(CW\*(C`addinfo()\*(C'\fR
and
\&\f(CW\*(C`diagset()\*(C'\fR
methods each return one element of the diagnostic, and
\&\f(CW\*(C`error_x()\*(C'\fR
returns all four at once.
.PP
See the \f(CW\*(C`ZOOM::Exception\*(C'\fR for the interpretation of these elements.
.PP
\fIexception()\fR
.IX Subsection "exception()"
.PP
.Vb 1
\& die $conn\->exception();
.Ve
.PP
\&\f(CW\*(C`exception()\*(C'\fR returns the same information as \f(CW\*(C`error_x()\*(C'\fR in the
form of a \f(CW\*(C`ZOOM::Exception\*(C'\fR object which may be thrown or rendered.
If no error occurred on the connection, then \f(CW\*(C`exception()\*(C'\fR returns an
undefined value.
.PP
\fIcheck()\fR
.IX Subsection "check()"
.PP
.Vb 1
\& $conn\->check();
.Ve
.PP
Checks whether an error is pending on the connection, and throw a
\&\f(CW\*(C`ZOOM::Exception\*(C'\fR object if so.  Since errors are thrown as they
occur for synchronous connections, there is no need ever to call this
except in asynchronous applications.
.PP
\fIoption()\fR / \fIoption_binary()\fR
.IX Subsection "option() / option_binary()"
.PP
.Vb 4
\& print("server is \*(Aq", $conn\->option("serverImplementationName"), "\*(Aq\en");
\& $conn\->option(preferredRecordSyntax => "usmarc");
\& $conn\->option_binary(iconBlob => "foo\e0bar");
\& die if length($conn\->option_binary("iconBlob") != 7);
.Ve
.PP
Objects of the Connection, ResultSet, ScanSet and Package classes
carry with them a set of named options which affect their behaviour in
certain ways.  See the ZOOM-C options documentation for details:
.PP
Connection options are listed at
http://indexdata.com/yaz/doc/zoom.tkl#zoom.connections
.PP
These options are set and fetched using the \f(CW\*(C`option()\*(C'\fR method, which
may be called with either one or two arguments.  In the two-argument
form, the option named by the first argument is set to the value of
the second argument, and its old value is returned.  In the
one-argument form, the value of the specified option is returned.
.PP
For historical reasons, option values are not binary-clean, so that a
value containing a \s-1NUL\s0 byte will be returned in truncated form.  The
\&\f(CW\*(C`option_binary()\*(C'\fR method behaves identically to \f(CW\*(C`option()\*(C'\fR except
that it is binary-clean, so that values containing \s-1NUL\s0 bytes are set
and returned correctly.
.PP
\fIsearch()\fR / \fIsearch_pqf()\fR
.IX Subsection "search() / search_pqf()"
.PP
.Vb 4
\& $rs = $conn\->search(new ZOOM::Query::CQL(\*(Aqtitle=dinosaur\*(Aq));
\& # The next two lines are equivalent
\& $rs = $conn\->search(new ZOOM::Query::PQF(\*(Aq@attr 1=4 dinosaur\*(Aq));
\& $rs = $conn\->search_pqf(\*(Aq@attr 1=4 dinosaur\*(Aq);
.Ve
.PP
The principal purpose of a search-and-retrieve protocol is searching
(and, er, retrieval), so the principal method used on a Connection
object is \f(CW\*(C`search()\*(C'\fR.  It accepts a single argument, a \f(CW\*(C`ZOOM::Query\*(C'\fR
object (or, more precisely, an object of a subclass of this class);
and it creates and returns a new ResultSet object representing the set
of records resulting from the search.
.PP
Since queries using \s-1PQF\s0 (Prefix Query Format) are so common, we make
them a special case by providing a \f(CW\*(C`search_pqf()\*(C'\fR method.  This is
identical to \f(CW\*(C`search()\*(C'\fR except that it accepts a string containing
the query rather than an object, thereby obviating the need to create
a \f(CW\*(C`ZOOM::Query::PQF\*(C'\fR object.  See the documentation of that class for
information about \s-1PQF\s0.
.PP
\fIscan()\fR / \fIscan_pqf()\fR
.IX Subsection "scan() / scan_pqf()"
.PP
.Vb 4
\& $rs = $conn\->scan(new ZOOM::Query::CQL(\*(Aqtitle=dinosaur\*(Aq));
\& # The next two lines are equivalent
\& $rs = $conn\->scan(new ZOOM::Query::PQF(\*(Aq@attr 1=4 dinosaur\*(Aq));
\& $rs = $conn\->scan_pqf(\*(Aq@attr 1=4 dinosaur\*(Aq);
.Ve
.PP
Many Z39.50 servers allow you to browse their indexes to find terms to
search for.  This is done using the \f(CW\*(C`scan\*(C'\fR method, which creates and
returns a new ScanSet object representing the set of terms resulting
from the scan.
.PP
\&\f(CW\*(C`scan()\*(C'\fR takes a single argument, but it has to work hard: it
specifies both what index to scan for terms, and where in the index to
start scanning.  What's more, the specification of what index to scan
includes multiple facets, such as what database fields it's an index
of (author, subject, title, etc.) and whether to scan for whole fields
or single words (e.g. the title ``\fIThe Empire Strikes Back\fR'', or the
four words ``Back'', ``Empire'', ``Strikes'' and ``The'', interleaved
with words from other titles in the same index.
.PP
All of this is done by using a Query object representing a query of a
single term as the \f(CW\*(C`scan()\*(C'\fR argument.  The attributes associated with
the term indicate which index is to be used, and the term itself
indicates the point in the index at which to start the scan.  For
example, if the argument is the query \f(CW\*(C`@attr 1=4 fish\*(C'\fR, then
.ie n .IP "@attr 1=4" 4
.el .IP "\f(CW@attr\fR 1=4" 4
.IX Item "@attr 1=4"
This is the \s-1BIB\-1\s0 attribute with type 1 (meaning access-point, which
specifies an index), and type 4 (which means ``title'').  So the scan
is in the title index.
.IP "fish" 4
.IX Item "fish"
Start the scan from the lexicographically earliest term that is equal
to or falls after ``fish''.
.PP
The argument \f(CW\*(C`@attr 1=4 @attr 6=3 fish\*(C'\fR would behave similarly; but
the \s-1BIB\-1\s0 attribute 6=3 mean completeness=``complete field'', so the
scan would be for complete titles rather than for words occurring in
titles.
.PP
This takes a bit of getting used to.
.PP
The behaviour is \f(CW\*(C`scan()\*(C'\fR is affected by the following options, which
may be set on the Connection through which the scan is done:
.IP "number [default: 10]" 4
.IX Item "number [default: 10]"
Indicates how many terms should be returned in the ScanSet.  The
number actually returned may be less, if the start-point is near the
end of the index, but will not be greater.
.IP "position [default: 1]" 4
.IX Item "position [default: 1]"
A 1\-based index specifying where in the returned list of terms the
seed-term should appear.  By default it should be the first term
returned, but \f(CW\*(C`position\*(C'\fR may be set, for example, to zero (requesting
the next terms \fIafter\fR the seed-term), or to the same value as
\&\f(CW\*(C`number\*(C'\fR (requesting the index terms \fIbefore\fR the seed term).
.IP "stepSize [default: 0]" 4
.IX Item "stepSize [default: 0]"
An integer indicating how many indexed terms are to be skipped between
each one returned in the ScanSet.  By default, no terms are skipped,
but overriding this can be useful to get a high-level overview of the
index.
.Sp
Since scans using \s-1PQF\s0 (Prefix Query Format) are so common, we make
them a special case by providing a \f(CW\*(C`scan_pqf()\*(C'\fR method.  This is
identical to \f(CW\*(C`scan()\*(C'\fR except that it accepts a string containing the
query rather than an object, thereby obviating the need to create a
\&\f(CW\*(C`ZOOM::Query::PQF\*(C'\fR object.
.PP
\fIpackage()\fR
.IX Subsection "package()"
.PP
.Vb 4
\& $p = $conn\->package();
\& $o = new ZOOM::Options();
\& $o\->option(databaseName => "newdb");
\& $p = $conn\->package($o);
.Ve
.PP
Creates and returns a new \f(CW\*(C`ZOOM::Package\*(C'\fR, to be used in invoking an
Extended Service.  An options block may optionally be passed in.  See
the \f(CW\*(C`ZOOM::Package\*(C'\fR documentation.
.PP
\fIlast_event()\fR
.IX Subsection "last_event()"
.PP
.Vb 3
\& if ($conn\->last_event() == ZOOM::Event::CONNECT) {
\&     print "Connected!\en";
\& }
.Ve
.PP
Returns a \f(CW\*(C`ZOOM::Event\*(C'\fR enumerated value indicating the type of the
last event that occurred on the connection.  This is used only in
complex asynchronous applications \- see the sections below on the
\&\f(CW\*(C`ZOOM::Event\*(C'\fR enumeration and asynchronous applications.
.PP
\fIdestroy()\fR
.IX Subsection "destroy()"
.PP
.Vb 1
\& $conn\->destroy()
.Ve
.PP
Destroys a Connection object, tearing down any low-level connection
associated with it and freeing its resources.  It is an error to reuse
a Connection that has been \f(CW\*(C`destroy()\*(C'\fRed.
.SS "ZOOM::ResultSet"
.IX Subsection "ZOOM::ResultSet"
.Vb 6
\& $rs = $conn\->search_pqf(\*(Aq@attr 1=4 mineral\*(Aq);
\& $n = $rs\->size();
\& for $i (1 .. $n) {
\&     $rec = $rs\->record($i\-1);
\&     print $rec\->render();
\& }
.Ve
.PP
A ResultSet object represents the set of zero or more records
resulting from a search, and is the means whereby these records can be
retrieved.  A ResultSet object may maintain client side cache or some,
less, none, all or more of the server's records: in general, this is
supposed to an implementaton detail of no interest to a typical
application, although more sophisticated applications do have
facilities for messing with the cache.  Most applications will only
need the \f(CW\*(C`size()\*(C'\fR, \f(CW\*(C`record()\*(C'\fR and \f(CW\*(C`sort()\*(C'\fR methods.
.PP
There is no \f(CW\*(C`new()\*(C'\fR method nor any other explicit constructor.  The
only way to create a new ResultSet is by using \f(CW\*(C`search()\*(C'\fR (or
\&\f(CW\*(C`search_pqf()\*(C'\fR) on a Connection.
.PP
See the description of the \f(CW\*(C`Result Set\*(C'\fR class in the \s-1ZOOM\s0 Abstract
\&\s-1API\s0 at
http://zoom.z3950.org/api/zoom\-current.html#3.4
.PP
\fIMethods\fR
.IX Subsection "Methods"
.PP
\fIoption()\fR
.IX Subsection "option()"
.PP
.Vb 1
\& $rs\->option(elementSetName => "f");
.Ve
.PP
Allows options to be set into, and read from, a ResultSet, just like
the Connection class's \f(CW\*(C`option()\*(C'\fR method.  There is no
\&\f(CW\*(C`option_binary()\*(C'\fR method for ResultSet objects.
.PP
ResultSet options are listed at
http://indexdata.com/yaz/doc/zoom.resultsets.tkl
.PP
\fIsize()\fR
.IX Subsection "size()"
.PP
.Vb 1
\& print "Found ", $rs\->size(), " records\en";
.Ve
.PP
Returns the number of records in the result set.
.PP
\fIrecord()\fR / \fIrecord_immediate()\fR
.IX Subsection "record() / record_immediate()"
.PP
.Vb 4
\& $rec = $rs\->record(0);
\& $rec2 = $rs\->record_immediate(0);
\& $rec3 = $rs\->record_immediate(1)
\&     or print "second record wasn\*(Aqt in cache\en";
.Ve
.PP
The \f(CW\*(C`record()\*(C'\fR method returns a \f(CW\*(C`ZOOM::Record\*(C'\fR object representing
a record from result-set, whose position is indicated by the argument
passed in.  This is a zero-based index, so that legitimate values
range from zero to \f(CW\*(C`$rs\->size()\-1\*(C'\fR.
.PP
The \f(CW\*(C`record_immediate()\*(C'\fR \s-1API\s0 is identical, but it never invokes a
network operation, merely returning the record from the ResultSet's
cache if it's already there, or an undefined value otherwise.  So if
you use this method, \fByou must always check the return value\fR.
.PP
\fIrecords()\fR
.IX Subsection "records()"
.PP
.Vb 4
\& $rs\->records(0, 10, 0);
\& for $i (0..10) {
\&     print $rs\->record_immediate($i)\->render();
\& }
\&
\& @nextseven = $rs\->records(10, 7, 1);
.Ve
.PP
The \f(CW\*(C`record_immediate()\*(C'\fR method only fetches records from the cache,
whereas \f(CW\*(C`record()\*(C'\fR fetches them from the server if they have not
already been cached; but the \s-1ZOOM\s0 module has to guess what the most
efficient strategy for this is.  It might fetch each record, alone
when asked for: that's optimal in an application that's only
interested in the top hit from each search, but pessimal for one that
wants to display a whole list of results.  Conversely, the software's
strategy might be always to ask for blocks of a twenty records:
that's great for assembling long lists of things, but wasteful when
only one record is wanted.  The problem is that the \s-1ZOOM\s0 module can't
tell, when you call \f(CW\*(C`$rs\->record()\*(C'\fR, what your intention is.
.PP
But you can tell it.  The \f(CW\*(C`records()\*(C'\fR method fetches a sequence of
records, all in one go.  It takes three arguments: the first is the
zero-based index of the first record in the sequence, the second is
the number of records to fetch, and the third is a boolean indication
of whether or not to return the retrieved records as well as adding
them to the cache.  (You can always pass 1 for this if you like, and
Perl will discard the unused return value, but there is a small
efficiency gain to be had by passing 0.)
.PP
Once the records have been retrieved from the server
(i.e. \f(CW\*(C`records()\*(C'\fR has completed without throwing an exception), they
can be fetched much more efficiently using \f(CW\*(C`record()\*(C'\fR \- or
\&\f(CW\*(C`record_immediate()\*(C'\fR, which is then guaranteed to succeed.
.PP
\fIcache_reset()\fR
.IX Subsection "cache_reset()"
.PP
.Vb 1
\& $rs\->cache_reset()
.Ve
.PP
Resets the ResultSet's record cache, so that subsequent invocations of
\&\f(CW\*(C`record_immediate()\*(C'\fR will fail.  I struggle to imagine a real
scenario where you'd want to do this.
.PP
\fIsort()\fR
.IX Subsection "sort()"
.PP
.Vb 3
\& if ($rs\->sort("yaz", "1=4 >i 1=21 >s") < 0) {
\&     die "sort failed";
\& }
.Ve
.PP
Sorts the ResultSet in place (discarding any cached records, as they
will in general be sorted into a different position).  There are two
arguments: the first is a string indicating the type of the
sort-specification, and the second is the specification itself.
.PP
The \f(CW\*(C`sort()\*(C'\fR method returns 0 on success, or \-1 if the
sort-specification is invalid.
.PP
At present, the only supported sort-specification type is \f(CW\*(C`yaz\*(C'\fR.
Such a specification consists of a space-separated sequence of keys,
each of which itself consists of two space-separated words (so that
the total number of words in the sort-specification is even).  The two
words making up each key are a field and a set of flags.  The field
can take one of two forms: if it contains an \f(CW\*(C`=\*(C'\fR sign, then it is a
\&\s-1BIB\-1\s0 \fItype\fR=\fIvalue\fR pair specifying which field to sort
(e.g. \f(CW\*(C`1=4\*(C'\fR for a title sort); otherwise it is sent for the server to
interpret as best it can.  The word of flags is made up from one or
more of the following: \f(CW\*(C`s\*(C'\fR for case sensitive, \f(CW\*(C`i\*(C'\fR for case
insensitive; \f(CW\*(C`<\*(C'\fR for ascending order and \f(CW\*(C`>\*(C'\fR for descending
order.
.PP
For example, the sort-specification in the code-fragment above will
sort the records in \f(CW$rs\fR case-insensitively in descending order of
title, with records having equivalent titles sorted case-sensitively
in ascending order of subject.  (The \s-1BIB\-1\s0 access points 4 and 21
represent title and subject respectively.)
.PP
\fIdestroy()\fR
.IX Subsection "destroy()"
.PP
.Vb 1
\& $rs\->destroy()
.Ve
.PP
Destroys a ResultSet object, freeing its resources.  It is an error to
reuse a ResultSet that has been \f(CW\*(C`destroy()\*(C'\fRed.
.SS "ZOOM::Record"
.IX Subsection "ZOOM::Record"
.Vb 5
\& $rec = $rs\->record($i);
\& print $rec\->render();
\& $raw = $rec\->raw();
\& $marc = new_from_usmarc MARC::Record($raw);
\& print "Record title is: ", $marc\->title(), "\en";
.Ve
.PP
A Record object represents a record that has been retrived from the
server.
.PP
There is no \f(CW\*(C`new()\*(C'\fR method nor any other explicit constructor.  The
only way to create a new Record is by using \f(CW\*(C`record()\*(C'\fR (or
\&\f(CW\*(C`record_immediate()\*(C'\fR, or \f(CW\*(C`records()\*(C'\fR) on a ResultSet.
.PP
In general, records are ``owned'' by their result-sets that they were
retrieved from, so they do not have to be explicitly memory-managed:
they are deallocated (and therefore can no longer be used) when the
result-set is destroyed.
.PP
See the description of the \f(CW\*(C`Record\*(C'\fR class in the \s-1ZOOM\s0 Abstract
\&\s-1API\s0 at
http://zoom.z3950.org/api/zoom\-current.html#3.5
.PP
\fIMethods\fR
.IX Subsection "Methods"
.PP
\fIerror()\fR / \fIexception()\fR
.IX Subsection "error() / exception()"
.PP
.Vb 5
\& if ($rec\->error()) {
\&     my($code, $msg, $addinfo, $dset) = $rec\->error();
\&     print "error $code, $msg ($addinfo) from $dset set\en";
\&     die $rec\->exception();
\& }
.Ve
.PP
These functions test for surrogate diagnostics associated with a
record: that is, errors pertaining to a particular record rather than
to the fetch-some-records operation as a whole.  (The latter are known
in Z39.50 as non-surrogate diagnostics, and are reported as exceptions
thrown by searches.)  If a particular record can't be obtained \- for
example, because it is not available in the requested record syntax \-
then the record object obtained from the result-set, when interrogated
with these functions, will report the error.
.PP
\&\f(CW\*(C`error()\*(C'\fR returns the error-code, a human-readable message,
additional information and the name of the diagnostic set that the
error is from.  When called in a scalar context, it just returns the
error-code.  Since error 0 means \*(L"no error\*(R", it can be used as a
boolean has-there-been-an-error indicator.
.PP
\&\f(CW\*(C`exception()\*(C'\fR returns the same information in the form of a
\&\f(CW\*(C`ZOOM::Exception\*(C'\fR object which may be thrown or rendered.  If no
error occurred on the record, then \f(CW\*(C`exception()\*(C'\fR returns an undefined
value.
.PP
\fIrender()\fR
.IX Subsection "render()"
.PP
.Vb 2
\& print $rec\->render();
\& print $rec\->render("charset=latin1,utf8");
.Ve
.PP
Returns a human-readable representation of the record.  Beyond that,
no promises are made: careful programs should not make assumptions
about the format of the returned string.
.PP
If the optional argument is provided, then it is interpreted as in the
\&\f(CW\*(C`get()\*(C'\fR method (q.v.)
.PP
This method is useful mostly for debugging.
.PP
\fIraw()\fR
.IX Subsection "raw()"
.PP
.Vb 4
\& use MARC::Record;
\& $raw = $rec\->raw();
\& $marc = new_from_usmarc MARC::Record($raw);
\& $trans = $rec\->render("charset=latin1,utf8");
.Ve
.PP
Returns an opaque blob of data that is the raw form of the record.
Exactly what this is, and what you can do with it, varies depending on
the record-syntax.  For example, \s-1XML\s0 records will be returned as,
well, \s-1XML\s0; \s-1MARC\s0 records will be returned as \s-1ISO\s0 2709\-encoded blocks
that can be decoded by software such as the fine \f(CW\*(C`Marc::Record\*(C'\fR
module; \s-1GRS\-1\s0 record will be ... gosh, what an interesting question.
But no-one uses \s-1GRS\-1\s0 any more, do they?
.PP
If the optional argument is provided, then it is interpreted as in the
\&\f(CW\*(C`get()\*(C'\fR method (q.v.)
.PP
\fIget()\fR
.IX Subsection "get()"
.PP
.Vb 4
\& $raw = $rec\->get("raw");
\& $rendered = $rec\->get("render");
\& $trans = $rec\->get("render;charset=latin1,utf8");
\& $trans = $rec\->get("render", "charset=latin1,utf8");
.Ve
.PP
This is the underlying method used by \f(CW\*(C`render()\*(C'\fR and \f(CW\*(C`raw()\*(C'\fR, and
which in turn delegates to the \f(CW\*(C`ZOOM_record_get()\*(C'\fR function of the
underlying ZOOM-C library.  Most applications will find it more
natural to work with \f(CW\*(C`render()\*(C'\fR and \f(CW\*(C`raw()\*(C'\fR.
.PP
\&\f(CW\*(C`get()\*(C'\fR may be called with either one or two arguments.  The
two-argument form is syntactic sugar: the two arguments are simply
joined with a semi-colon to make a single argument, so the third and
fourth example invocations above are equivalent.  The second argument
(or portion of the first argument following the semicolon) is used in
the \f(CW\*(C`type\*(C'\fR argument of \f(CW\*(C`ZOOM_record_get()\*(C'\fR, as described in
http://www.indexdata.com/yaz/doc/zoom.records.tkl
This is useful primarily for invoking the character-set transformation
\&\- in the examples above, from \s-1ISO\s0 Latin\-1 to \s-1UTF\-8\s0 Unicode.
.PP
\fIclone()\fR / \fIdestroy()\fR
.IX Subsection "clone() / destroy()"
.PP
.Vb 5
\& $rec = $rs\->record($i);
\& $newrec = $rec\->clone();
\& $rs\->destroy();
\& print $newrec\->render();
\& $newrec\->destroy();
.Ve
.PP
Usually, it's convenient that Record objects are owned by their
ResultSets and go away when the ResultSet is destroyed; but
occasionally you need a Record to outlive its parent and destroy it
later, explicitly.  To do this, \f(CW\*(C`clone()\*(C'\fR the record, keep the new
Record object that is returned, and \f(CW\*(C`destroy()\*(C'\fR it when it's no
longer needed.  This is \fBonly\fR situation in which a Record needs to
be destroyed.
.SS "ZOOM::Exception"
.IX Subsection "ZOOM::Exception"
In general, method calls throw an exception (of class
\&\f(CW\*(C`ZOOM::Exception\*(C'\fR) if anything goes wrong, so you don't need to test
for success after each call.  Exceptions are caught by enclosing the
main code in an \f(CW\*(C`eval{}\*(C'\fR block and checking \f(CW$@\fR on exit from that
block, as in the code-sample above.
.PP
There are a small number of exceptions to this rule: the three
record-fetching methods in the \f(CW\*(C`ZOOM::ResultSet\*(C'\fR class,
\&\f(CW\*(C`record()\*(C'\fR,
\&\f(CW\*(C`record_immediate()\*(C'\fR,
and
\&\f(CW\*(C`records()\*(C'\fR
can all return undefined values for legitimate reasons, under
circumstances that do not merit throwing an exception.  For this
reason, the return values of these methods should be checked.  See the
individual methods' documentation for details.
.PP
An exception carries the following pieces of information:
.IP "error-code" 4
.IX Item "error-code"
A numeric code that specifies the type of error.  This can be checked
for equality with known values, so that intelligent applications can
take appropriate action.
.IP "error-message" 4
.IX Item "error-message"
A human-readable message corresponding with the code.  This can be
shown to users, but its value should not be tested, as it could vary
in different versions or under different locales.
.IP "additional information [optional]" 4
.IX Item "additional information [optional]"
A string containing information specific to the error-code.  For
example, when the error-code is the \s-1BIB\-1\s0 diagnostic 109 (\*(L"Database
unavailable\*(R"), the additional information is the name of the database
that the application tried to use.  For some error-codes, there is no
additional information at all; for some others, the additional
information is undefined and may just be an human-readable string.
.IP "diagnostic set [optional]" 4
.IX Item "diagnostic set [optional]"
A short string specifying the diagnostic set from which the error-code
was drawn: for example, \f(CW\*(C`ZOOM\*(C'\fR for a ZOOM-specific error such as
\&\f(CW\*(C`ZOOM::Error::MEMORY\*(C'\fR (\*(L"out of memory\*(R"), and \f(CW\*(C`BIB\-1\*(C'\fR for a Z39.50
error-code drawn from the \s-1BIB\-1\s0 diagnostic set.
.PP
In theory, the error-code should be interpreted in the context of the
diagnostic set from which it is drawn; in practice, nearly all errors
are from either the \s-1ZOOM\s0 or \s-1BIB\-1\s0 diagnostic sets, and the codes in
those sets have been chosen so as not to overlap, so the diagnostic
set can usually be ignored.
.PP
See the description of the \f(CW\*(C`Exception\*(C'\fR class in the \s-1ZOOM\s0 Abstract
\&\s-1API\s0 at
http://zoom.z3950.org/api/zoom\-current.html#3.7
.PP
\fIMethods\fR
.IX Subsection "Methods"
.PP
\fInew()\fR
.IX Subsection "new()"
.PP
.Vb 1
\& die new ZOOM::Exception($errcode, $errmsg, $addinfo, $diagset);
.Ve
.PP
Creates and returns a new Exception object with the specified
error-code, error-message, additional information and diagnostic set.
Applications will not in general need to use this, but may find it
useful to simulate \s-1ZOOM\s0 exceptions.  As is usual with Perl, exceptions
are thrown using \f(CW\*(C`die()\*(C'\fR.
.PP
\fIcode()\fR / \fImessage()\fR / \fIaddinfo()\fR / \fIdiagset()\fR
.IX Subsection "code() / message() / addinfo() / diagset()"
.PP
.Vb 2
\& print "Error ", $@\->code(), ": ", $@\->message(), "\en";
\& print "(addinfo \*(Aq", $@\->addinfo(), "\*(Aq, set \*(Aq", $@\->diagset(), "\*(Aq)\en";
.Ve
.PP
These methods, of no arguments, return the exception's error-code,
error-message, additional information and diagnostic set respectively.
.PP
\fIrender()\fR
.IX Subsection "render()"
.PP
.Vb 1
\& print $@\->render();
.Ve
.PP
Returns a human-readable rendition of an exception.  The \f(CW""\fR
operator is overloaded on the Exception class, so that an Exception
used in a string context is automatically rendered.  Among other
consequences, this has the useful result that a \s-1ZOOM\s0 application that
died due to an uncaught exception will emit an informative message
before exiting.
.SS "ZOOM::ScanSet"
.IX Subsection "ZOOM::ScanSet"
.Vb 5
\& $ss = $conn\->scan(\*(Aq@attr 1=1003 a\*(Aq);
\& $n = $ss\->size();
\& ($term, $occ) = $ss\->term($n\-1);
\& $rs = $conn\->search_pqf(\*(Aq@attr 1=1003 "\*(Aq . $term . "\*(Aq");
\& assert($rs\->size() == $occ);
.Ve
.PP
A ScanSet represents a set of candidate search-terms returned from an
index scan.  Its sole purpose is to provide access to those term, to
the corresponding display terms, and to the occurrence-counts of the
terms.
.PP
There is no \f(CW\*(C`new()\*(C'\fR method nor any other explicit constructor.  The
only way to create a new ScanSet is by using \f(CW\*(C`scan()\*(C'\fR on a
Connection.
.PP
See the description of the \f(CW\*(C`Scan Set\*(C'\fR class in the \s-1ZOOM\s0 Abstract
\&\s-1API\s0 at
http://zoom.z3950.org/api/zoom\-current.html#3.6
.PP
\fIMethods\fR
.IX Subsection "Methods"
.PP
\fIsize()\fR
.IX Subsection "size()"
.PP
.Vb 1
\& print "Found ", $ss\->size(), " terms\en";
.Ve
.PP
Returns the number of terms in the scan set.  In general, this will be
the scan-set size requested by the \f(CW\*(C`number\*(C'\fR option in the Connection
on which the scan was performed [default 10], but it may be fewer if
the scan is close to the end of the index.
.PP
\fIterm()\fR / \fIdisplay_term()\fR
.IX Subsection "term() / display_term()"
.PP
.Vb 8
\& $ss = $conn\->scan(\*(Aq@attr 1=1004 whatever\*(Aq);
\& ($term, $occurrences) = $ss\->term(0);
\& ($displayTerm, $occurrences2) = $ss\->display_term(0);
\& assert($occurrences == $occurrences2);
\& if (user_likes_the_look_of($displayTerm)) {
\&     $rs = $conn\->search_pqf(\*(Aq@attr 1=4 "\*(Aq . $term . \*(Aq"\*(Aq);
\&     assert($rs\->size() == $occurrences);
\& }
.Ve
.PP
These methods return the scanned terms themselves.  \f(CW\*(C`term()\*(C'\fR returns
the term is a form suitable for submitting as part of a query, whereas
\&\f(CW\*(C`display_term()\*(C'\fR returns it in a form suitable for displaying to a
user.  Both versions also return the number of occurrences of the term
in the index, i.e. the number of hits that will be found if the term
is subsequently used in a query.
.PP
In most cases, the term and display term will be identical; however,
they may be different in cases where punctuation or case is
normalised, or where identifiers rather than the original document
terms are indexed.
.PP
\fIoption()\fR
.IX Subsection "option()"
.PP
.Vb 1
\& print "scan status is ", $ss\->option("scanStatus");
.Ve
.PP
Allows options to be set into, and read from, a ScanSet, just like
the Connection class's \f(CW\*(C`option()\*(C'\fR method.  There is no
\&\f(CW\*(C`option_binary()\*(C'\fR method for ScanSet objects.
.PP
ScanSet options are also described, though not particularly
informatively, at
http://indexdata.com/yaz/doc/zoom.scan.tkl
.PP
\fIdestroy()\fR
.IX Subsection "destroy()"
.PP
.Vb 1
\& $ss\->destroy()
.Ve
.PP
Destroys a ScanSet object, freeing its resources.  It is an error to
reuse a ScanSet that has been \f(CW\*(C`destroy()\*(C'\fRed.
.SS "ZOOM::Package"
.IX Subsection "ZOOM::Package"
.Vb 6
\& $p = $conn\->package();
\& $p\->option(action => "specialUpdate");
\& $p\->option(recordIdOpaque => 145);
\& $p\->option(record => content_of("/tmp/record.xml"));
\& $p\->send("update");
\& $p\->destroy();
.Ve
.PP
This class represents an Extended Services Package: an instruction to
the server to do something not covered by the core parts of the Z39.50
standard (or the equivalent in \s-1SRW\s0 or \s-1SRU\s0).  Since the core protocols
are read-only, such requests are often used to make changes to the
database, such as in the record update example above.
.PP
Requesting an extended service is a four-step process: first, create a
package associated with the connection to the relevant database;
second, set options on the package to instruct the server on what to
do; third, send the package (which may result in an exception being
thrown if the server cannot execute the requested operations; and
finally, destroy the package.
.PP
Package options are listed at
http://indexdata.com/yaz/doc/zoom.ext.tkl
.PP
The particular options that have meaning are determined by the
top-level operation string specified as the argument to \f(CW\*(C`send()\*(C'\fR.
For example, when the operation is \f(CW\*(C`update\*(C'\fR (the most commonly used
extended service), the \f(CW\*(C`action\*(C'\fR option may be set to any of
\&\f(CW\*(C`recordInsert\*(C'\fR
(add a new record, failing if that record already exists),
\&\f(CW\*(C`recordDelete\*(C'\fR
(delete a record, failing if it is not in the database).
\&\f(CW\*(C`recordReplace\*(C'\fR
(replace a record, failing if an old version is not already present)
or
\&\f(CW\*(C`specialUpdate\*(C'\fR
(add a record, replacing any existing version that may be present).
.PP
For update, the \f(CW\*(C`record\*(C'\fR option should be set to the full text of the
\&\s-1XML\s0 record to added, deleted or replaced.  Depending on how the server
is configured, it may extract the record's unique \s-1ID\s0 from the text
(i.e. from a known element such as the \f(CW001\fR field of a \s-1MARCXML\s0
record), or it may require the unique \s-1ID\s0 to passed in explicitly using
the \f(CW\*(C`recordIdOpaque\*(C'\fR option.
.PP
Extended services packages are \fBnot currently described\fR in the \s-1ZOOM\s0
Abstract \s-1API\s0 at
http://zoom.z3950.org/api/zoom\-current.html
They will be added in a forthcoming version, and will function much
as those implemented in this module.
.PP
\fIMethods\fR
.IX Subsection "Methods"
.PP
\fIoption()\fR
.IX Subsection "option()"
.PP
.Vb 1
\& $p\->option(recordIdOpaque => "46696f6e61");
.Ve
.PP
Allows options to be set into, and read from, a Package, just like
the Connection class's \f(CW\*(C`option()\*(C'\fR method.  There is no
\&\f(CW\*(C`option_binary()\*(C'\fR method for Package objects.
.PP
Package options are listed at
http://indexdata.com/yaz/doc/zoom.ext.tkl
.PP
\fIsend()\fR
.IX Subsection "send()"
.PP
.Vb 1
\& $p\->send("create");
.Ve
.PP
Sends a package to the server associated with the Connection that
created it.  Problems are reported by throwing an exception.  The
single parameter indicates the operation that the server is being
requested to perform, and controls the interpretation of the package's
options.  Valid operations include:
.IP "itemorder" 4
.IX Item "itemorder"
Request a copy of a nominated object, e.g. place an \s-1ILL\s0 request.
.IP "create" 4
.IX Item "create"
Create a new database, the name of which is specified by the
\&\f(CW\*(C`databaseName\*(C'\fR option.
.IP "drop" 4
.IX Item "drop"
Drop an existing database, the name of which is specified by the
\&\f(CW\*(C`databaseName\*(C'\fR option.
.IP "commit" 4
.IX Item "commit"
Commit changes made to the database within a transaction.
.IP "update" 4
.IX Item "update"
Modify the contents of the database by adding, deleting or replacing
records (as described above in the overview of the \f(CW\*(C`ZOOM::Package\*(C'\fR
class).
.IP "xmlupdate" 4
.IX Item "xmlupdate"
I have no idea what this does.
.PP
Although the module is capable of \fImaking\fR all these requests, not
all servers are capable of \fIexecuting\fR them.  Refusal is indicated by
throwing an exception.  Problems may also be caused by lack of
privileges; so \f(CW\*(C`send()\*(C'\fR must be used with caution, and is perhaps
best wrapped in a clause that checks for execptions, like so:
.PP
.Vb 5
\& eval { $p\->send("create") };
\& if ($@ && $@\->isa("ZOOM::Exception")) {
\&     print "Oops!  ", $@\->message(), "\en";
\&     return $@\->code();
\& }
.Ve
.PP
\fIdestroy()\fR
.IX Subsection "destroy()"
.PP
.Vb 1
\& $p\->destroy()
.Ve
.PP
Destroys a Package object, freeing its resources.  It is an error to
reuse a Package that has been \f(CW\*(C`destroy()\*(C'\fRed.
.SS "ZOOM::Query"
.IX Subsection "ZOOM::Query"
.Vb 4
\& $q = new ZOOM::Query::CQL("creator=pike and subject=unix");
\& $q\->sortby("1=4 >i 1=21 >s");
\& $rs = $conn\->search($q);
\& $q\->destroy();
.Ve
.PP
\&\f(CW\*(C`ZOOM::Query\*(C'\fR is a virtual base class from which various concrete
subclasses can be derived.  Different subclasses implement different
types of query.  The sole purpose of a Query object is to be used in a
\&\f(CW\*(C`search()\*(C'\fR on a Connection; because \s-1PQF\s0 is such a common special
case, the shortcut Connection method \f(CW\*(C`search_pqf()\*(C'\fR is provided.
.PP
The following Query subclasses are provided, each providing the
same set of methods described below:
.IP "ZOOM::Query::PQF" 4
.IX Item "ZOOM::Query::PQF"
Implements Prefix Query Format (\s-1PQF\s0), also sometimes known as Prefix
Query Notation (\s-1PQN\s0).  This esoteric but rigorous and expressive
format is described in the \s-1YAZ\s0 Manual at
http://indexdata.com/yaz/doc/tools.tkl#PQF
.IP "ZOOM::Query::CQL" 4
.IX Item "ZOOM::Query::CQL"
Implements the Common Query Language (\s-1CQL\s0) of \s-1SRU\s0, the Search/Retrieve
\&\s-1URL\s0.  \s-1CQL\s0 is a much friendlier notation than \s-1PQF\s0, using a simple infix
notation.  The queries are passed ``as is'' to the server rather than
being compiled into a Z39.50 Type\-1 query, so only CQL-compliant
servers can support such querier.  \s-1CQL\s0 is described at
http://www.loc.gov/standards/sru/cql/
and in a slight out-of-date but nevertheless useful tutorial at
http://zing.z3950.org/cql/intro.html
.IP "ZOOM::Query::CQL2RPN" 4
.IX Item "ZOOM::Query::CQL2RPN"
Implements \s-1CQL\s0 by compiling it on the client-side into a Z39.50
Type\-1 (\s-1RPN\s0) query, and sending that.  This provides essentially the
same functionality as \f(CW\*(C`ZOOM::Query::CQL\*(C'\fR, but it will work against
any standard Z39.50 server rather than only against the small subset
that support \s-1CQL\s0 natively.  The drawback is that, because the
compilation is done on the client side, a configuration file is
required to direct the mapping of \s-1CQL\s0 constructs such as index names,
relations and modifiers into Type\-1 query attributes.  An example \s-1CQL\s0
configuration file is included in the ZOOM-Perl distribution, in the
file \f(CW\*(C`samples/cql/pqf.properties\*(C'\fR
.IP "ZOOM::Query::CCL2RPN" 4
.IX Item "ZOOM::Query::CCL2RPN"
Implements \s-1CCL\s0 by compiling it on the client-side into a Z39.50 Type\-1
(\s-1RPN\s0) query, and sending that.  Because the compilation is done on the
client side, a configuration file is required to direct the mapping of
\&\s-1CCL\s0 constructs such as index names and boolean operators into Type\-1
query attributes.  An example \s-1CCL\s0 configuration file is included in
the ZOOM-Perl distribution, in the file \f(CW\*(C`samples/ccl/default.bib\*(C'\fR
.Sp
\&\s-1CCL\s0 is syntactically very similar to \s-1CQL\s0, but much looser.  While \s-1CQL\s0
is an entirely precise language in which each possible query has
rigorously defined semantics, and is thus suitable for transfer as
part of a protocol, \s-1CCL\s0 is best deployed as a human-facing \s-1UI\s0
language.
.PP
See the description of the \f(CW\*(C`Query\*(C'\fR class in the \s-1ZOOM\s0 Abstract
\&\s-1API\s0 at
http://zoom.z3950.org/api/zoom\-current.html#3.3
.PP
\fIMethods\fR
.IX Subsection "Methods"
.PP
\fInew()\fR
.IX Subsection "new()"
.PP
.Vb 2
\& $q = new ZOOM::Query::CQL(\*(Aqtitle=dinosaur\*(Aq);
\& $q = new ZOOM::Query::PQF(\*(Aq@attr 1=4 dinosaur\*(Aq);
.Ve
.PP
Creates a new query object, compiling the query passed as its argument
according to the rules of the particular query-type being
instantiated.  If compilation fails, an exception is thrown.
Otherwise, the query may be passed to the \f(CW\*(C`Connection\*(C'\fR method
\&\f(CW\*(C`search()\*(C'\fR.
.PP
.Vb 2
\& $conn\->option(cqlfile => "samples/cql/pqf.properties");
\& $q = new ZOOM::Query::CQL2RPN(\*(Aqtitle=dinosaur\*(Aq, $conn);
.Ve
.PP
Note that for the \f(CW\*(C`ZOOM::Query::CQL2RPN\*(C'\fR subclass, the Connection
must also be passed into the constructor.  This is used for two
purposes: first, its \f(CW\*(C`cqlfile\*(C'\fR option is used to find the \s-1CQL\s0
configuration file that directs the translations into \s-1RPN\s0; and second,
if compilation fails, then diagnostic information is cached in the
Connection and be retrieved using \f(CW\*(C`$conn\->errcode()\*(C'\fR and related
methods.
.PP
.Vb 4
\& $conn\->option(cclfile => "samples/ccl/default.bib");
\& # or
\& $conn\->option(cclqual => "ti u=4 s=pw\enab u=62 s=pw");
\& $q = new ZOOM::Query::CCL2RPN(\*(Aqti=dinosaur\*(Aq, $conn);
.Ve
.PP
For the \f(CW\*(C`ZOOM::Query::CCL2RPN\*(C'\fR subclass, too, the Connection must be
passed into the constructor, for the same reasons as when client-side
\&\s-1CQL\s0 compilation is used.  The \f(CW\*(C`cclqual\*(C'\fR option, if defined, gives a
\&\s-1CCL\s0 qualification specification inline; otherwise, the contents of the
file named by the \f(CW\*(C`cclfile\*(C'\fR option are used.
.PP
\fIsortby()\fR
.IX Subsection "sortby()"
.PP
.Vb 1
\& $q\->sortby("1=4 >i 1=21 >s");
.Ve
.PP
Sets a sort specification into the query, so that when a \f(CW\*(C`search()\*(C'\fR
is run on the query, the result is automatically sorted.  The sort
specification language is the same as the \f(CW\*(C`yaz\*(C'\fR sort-specification
type of the \f(CW\*(C`ResultSet\*(C'\fR method \f(CW\*(C`sort()\*(C'\fR, described above.
.PP
\fIdestroy()\fR
.IX Subsection "destroy()"
.PP
.Vb 1
\& $p\->destroy()
.Ve
.PP
Destroys a Query object, freeing its resources.  It is an error to
reuse a Query that has been \f(CW\*(C`destroy()\*(C'\fRed.
.SS "ZOOM::Options"
.IX Subsection "ZOOM::Options"
.Vb 7
\& $o1 = new ZOOM::Options();
\& $o1\->option(user => "alf");
\& $o2 = new ZOOM::Options();
\& $o2\->option(password => "fruit");
\& $opts = new ZOOM::Options($o1, $o2);
\& $conn = create ZOOM::Connection($opts);
\& $conn\->connect($host); # Uses the specified username and password
.Ve
.PP
Several classes of \s-1ZOOM\s0 objects carry their own sets of options, which
can be manipulated using their \f(CW\*(C`option()\*(C'\fR method.  Sometimes,
however, it's useful to deal with the option sets directly, and the
\&\f(CW\*(C`ZOOM::Options\*(C'\fR class exists to enable this approach.
.PP
Option sets are \fBnot currently described\fR in the \s-1ZOOM\s0
Abstract \s-1API\s0 at
http://zoom.z3950.org/api/zoom\-current.html
They are an extension to that specification.
.PP
\fIMethods\fR
.IX Subsection "Methods"
.PP
\fInew()\fR
.IX Subsection "new()"
.PP
.Vb 4
\& $o1 = new ZOOM::Options();
\& $o1and2 = new ZOOM::Options($o1);
\& $o3 = new ZOOM::Options();
\& $o1and3and4 = new ZOOM::Options($o1, $o3);
.Ve
.PP
Creates and returns a new option set.  One or two (but no more)
existing option sets may be passed as arguments, in which case they
become ``parents'' of the new set, which thereby ``inherits'' their
options, the values of the first parent overriding those of the second
when both have a value for the same key.  An option set that inherits
from a parent that has its own parents also inherits the grandparent's
options, and so on.
.PP
\fIoption()\fR / \fIoption_binary()\fR
.IX Subsection "option() / option_binary()"
.PP
.Vb 3
\& $o\->option(preferredRecordSyntax => "usmarc");
\& $o\->option_binary(iconBlob => "foo\e0bar");
\& die if length($o\->option_binary("iconBlob") != 7);
.Ve
.PP
These methods are used to get and set options within a set, and behave
the same way as the same-named \f(CW\*(C`Connection\*(C'\fR methods \- see above.  As
with the \f(CW\*(C`Connection\*(C'\fR methods, values passed to and retrieved using
\&\f(CW\*(C`option()\*(C'\fR are interpreted as NUL-terminated, while those passed to
and retrieved from \f(CW\*(C`option_binary()\*(C'\fR are binary-clean.
.PP
\fIbool()\fR
.IX Subsection "bool()"
.PP
.Vb 5
\& $o\->option(x => "T");
\& $o\->option(y => "F");
\& assert($o\->bool("x", 1));
\& assert(!$o\->bool("y", 1));
\& assert($o\->bool("z", 1));
.Ve
.PP
The first argument is a key, and the second is a default value.
Returns the value associated with the specified key as a boolean, or
the default value if the key has not been set.  The values \f(CW\*(C`T\*(C'\fR (upper
case) and \f(CW1\fR are considered true; all other values (including \f(CW\*(C`t\*(C'\fR
(lower case) and non-zero integers other than one) are considered
false.
.PP
This method is provided in ZOOM-C because in a statically typed
language it's convenient to have the result returned as an
easy-to-test type.  In a dynamically typed language such as Perl, this
problem doesn't arise, so \f(CW\*(C`bool()\*(C'\fR is nearly useless; but it is made
available in case applications need to duplicate the idiosyncratic
interpretation of truth and falsehood and ZOOM-C uses.
.PP
\fIint()\fR
.IX Subsection "int()"
.PP
.Vb 3
\& $o\->option(x => "012");
\& assert($o\->int("x", 20) == 12);
\& assert($o\->int("y", 20) == 20);
.Ve
.PP
Returns the value associated with the specified key as an integer, or
the default value if the key has not been set.  See the description of
\&\f(CW\*(C`bool()\*(C'\fR for why you almost certainly don't want to use this.
.PP
\fIset_int()\fR
.IX Subsection "set_int()"
.PP
.Vb 1
\& $o\->set_int(x => "29");
.Ve
.PP
Sets the value of the specified option as an integer.  Of course, Perl
happily converts strings to integers on its own, so you can just use
\&\f(CW\*(C`option()\*(C'\fR for this, but \f(CW\*(C`set_int()\*(C'\fR is guaranteed to use the same
string-to-integer conversion as ZOOM-C does, which might occasionally
be useful.  Though I can't imagine how.
.PP
\fIset_callback()\fR
.IX Subsection "set_callback()"
.PP
.Vb 6
\& sub cb {
\&     ($udata, $key) = @;
\&     return "$udata\-$key\-$udata";
\& }
\& $o\->set_callback(\e&cb, "xyz");
\& assert($o\->option("foo") eq "xyz\-foo\-xyz");
.Ve
.PP
This method allows a callback function to be installed in an option
set, so that the values of options can be calculated algorithmically
rather than, as usual, looked up in a table.  Along with the callback
function itself, an additional datum is provided: when an option is
subsequently looked up, this datum is passed to the callback function
along with the key; and its return value is returned to the caller as
the value of the option.
.PP
\&\fBWarning.\fR
Although it ought to be possible to specify callback function using
the \f(CW\*(C`\e&name\*(C'\fR syntax above, or a literal \f(CW\*(C`sub { code }\*(C'\fR code
reference, the complexities of the Perl-internal memory management
system mean that the function must currently be specified as a string
containing the fully-qualified name, e.g. \f(CW"main::cb"\fR.>
.PP
\&\fBWarning.\fR
The current implementation of the this method leaks memory, not only
when the callback is installed, but on every occasion that it is
consulted to look up an option value.
.PP
\fIdestroy()\fR
.IX Subsection "destroy()"
.PP
.Vb 1
\& $o\->destroy()
.Ve
.PP
Destroys an Options object, freeing its resources.  It is an error to
reuse an Options object that has been \f(CW\*(C`destroy()\*(C'\fRed.
.SH "ENUMERATIONS"
.IX Header "ENUMERATIONS"
The \s-1ZOOM\s0 module provides two enumerations that list possible return
values from particular functions.  They are described in the following
sections.
.SS "ZOOM::Error"
.IX Subsection "ZOOM::Error"
.Vb 3
\& if ($@\->code() == ZOOM::Error::QUERY_PQF) {
\&     return "your query was not accepted";
\& }
.Ve
.PP
This class provides a set of manifest constants representing some of
the possible error codes that can be raised by the \s-1ZOOM\s0 module.  The
methods that return error-codes are
\&\f(CW\*(C`ZOOM::Exception::code()\*(C'\fR,
\&\f(CW\*(C`ZOOM::Connection::error_x()\*(C'\fR
and
\&\f(CW\*(C`ZOOM::Connection::errcode()\*(C'\fR.
.PP
The \f(CW\*(C`ZOOM::Error\*(C'\fR class provides the constants
\&\f(CW\*(C`NONE\*(C'\fR,
\&\f(CW\*(C`CONNECT\*(C'\fR,
\&\f(CW\*(C`MEMORY\*(C'\fR,
\&\f(CW\*(C`ENCODE\*(C'\fR,
\&\f(CW\*(C`DECODE\*(C'\fR,
\&\f(CW\*(C`CONNECTION_LOST\*(C'\fR,
\&\f(CW\*(C`ZINIT\*(C'\fR,
\&\f(CW\*(C`INTERNAL\*(C'\fR,
\&\f(CW\*(C`TIMEOUT\*(C'\fR,
\&\f(CW\*(C`UNSUPPORTED_PROTOCOL\*(C'\fR,
\&\f(CW\*(C`UNSUPPORTED_QUERY\*(C'\fR,
\&\f(CW\*(C`INVALID_QUERY\*(C'\fR,
\&\f(CW\*(C`CQL_PARSE\*(C'\fR,
\&\f(CW\*(C`CQL_TRANSFORM\*(C'\fR,
\&\f(CW\*(C`CCL_CONFIG\*(C'\fR,
\&\f(CW\*(C`CCL_PARSE\*(C'\fR,
\&\f(CW\*(C`CREATE_QUERY\*(C'\fR,
\&\f(CW\*(C`QUERY_CQL\*(C'\fR,
\&\f(CW\*(C`QUERY_PQF\*(C'\fR,
\&\f(CW\*(C`SORTBY\*(C'\fR,
\&\f(CW\*(C`CLONE\*(C'\fR,
\&\f(CW\*(C`PACKAGE\*(C'\fR,
\&\f(CW\*(C`SCANTERM\*(C'\fR
and
\&\f(CW\*(C`LOGLEVEL\*(C'\fR,
each of which specifies a client-side error.  These codes constitute
the \f(CW\*(C`ZOOM\*(C'\fR diagnostic set.
.PP
Since errors may also be diagnosed by the server, and returned to the
client, error codes may also take values from the \s-1BIB\-1\s0 diagnostic set
of Z39.50, listed at the Z39.50 Maintenance Agency's web-site at
http://www.loc.gov/z3950/agency/defns/bib1diag.html
.PP
All error-codes, whether client-side from the \f(CW\*(C`ZOOM::Error\*(C'\fR
enumeration or server-side from the \s-1BIB\-1\s0 diagnostic set, can be
translated into human-readable messages by passing them to the
\&\f(CW\*(C`ZOOM::diag_str()\*(C'\fR utility function.
.SS "ZOOM::Event"
.IX Subsection "ZOOM::Event"
.Vb 3
\& if ($conn\->last_event() == ZOOM::Event::CONNECT) {
\&     print "Connected!\en";
\& }
.Ve
.PP
In applications that need it \- mostly complex multiplexing
applications \- The \f(CW\*(C`ZOOM::Connection::last_event()\*(C'\fR method is used to
return an indication of the last event that occurred on a particular
connection.  It always returns a value drawn from this enumeration,
that is, one of \f(CW\*(C`NONE\*(C'\fR, \f(CW\*(C`CONNECT\*(C'\fR, \f(CW\*(C`SEND_DATA\*(C'\fR, \f(CW\*(C`RECV_DATA\*(C'\fR,
\&\f(CW\*(C`TIMEOUT\*(C'\fR, \f(CW\*(C`UNKNOWN\*(C'\fR, \f(CW\*(C`SEND_APDU\*(C'\fR, \f(CW\*(C`RECV_APDU\*(C'\fR, \f(CW\*(C`RECV_RECORD\*(C'\fR,
\&\f(CW\*(C`RECV_SEARCH\*(C'\fR or \f(CW\*(C`ZEND\*(C'\fR.
.PP
See the section below on asynchronous applications.
.SH "LOGGING"
.IX Header "LOGGING"
.Vb 2
\& ZOOM::Log::init_level(ZOOM::Log::mask_str("zoom,myapp,\-warn"));
\& ZOOM::Log::log("myapp", "starting up with pid ", $$);
.Ve
.PP
Logging facilities are provided by a set of functions in the
\&\f(CW\*(C`ZOOM::Log\*(C'\fR module.  Note that \f(CW\*(C`ZOOM::Log\*(C'\fR is not a class, and it
is not possible to create \f(CW\*(C`ZOOM::Log\*(C'\fR objects: the \s-1API\s0 is imperative,
reflecting that of the underlying \s-1YAZ\s0 logging facilities.  Although
there are nine logging functions altogether, you can ignore nearly
all of them: most applications that use logging will begin by calling
\&\f(CW\*(C`mask_str()\*(C'\fR and \f(CW\*(C`init_level()\*(C'\fR once each, as above, and will then
repeatedly call \f(CW\*(C`log()\*(C'\fR.
.SS "\fImask_str()\fP"
.IX Subsection "mask_str()"
.Vb 1
\& $level = ZOOM::Log::mask_str("zoom,myapp,\-warn");
.Ve
.PP
Returns an integer corresponding to the log-level specified by the
parameter.  This is a string of zero or more comma-separated
module-names, each indicating an individual module to be either added
to the default log-level or removed from it (for those components
prefixed by a minus-sign).  The names may be those of either standard
YAZ-logging modules such as \f(CW\*(C`fatal\*(C'\fR, \f(CW\*(C`debug\*(C'\fR and \f(CW\*(C`warn\*(C'\fR, or custom
modules such as \f(CW\*(C`myapp\*(C'\fR in the example above.  The module \f(CW\*(C`zoom\*(C'\fR
requests logging from the \s-1ZOOM\s0 module itself, which may be helpful for
debugging.
.PP
Note that calling this function does not in any way change the logging
state: it merely returns a value.  To change the state, this value
must be passed to \f(CW\*(C`init_level()\*(C'\fR.
.SS "\fImodule_level()\fP"
.IX Subsection "module_level()"
.Vb 2
\& $level = ZOOM::Log::module_level("zoom");
\& ZOOM::Log::log($level, "all systems clear: thrusters invogriated");
.Ve
.PP
Returns the integer corresponding to the single log-level specified as
the parameter, or zero if that level has not been registered by a
prior call to \f(CW\*(C`mask_str()\*(C'\fR.  Since \f(CW\*(C`log()\*(C'\fR accepts either a numeric
log-level or a string, there is no reason to call this function; but,
what the heck, maybe you enjoy that kind of thing.  Who are we to
judge?
.SS "\fIinit_level()\fP"
.IX Subsection "init_level()"
.Vb 1
\& ZOOM::Log::init_level($level);
.Ve
.PP
Initialises the log-level to the specified integer, which is a bitmask
of values, typically as returned from \f(CW\*(C`mask_str()\*(C'\fR.  All subsequent
calls to \f(CW\*(C`log()\*(C'\fR made with a log-level that matches one of the bits
in this mask will result in a log-message being emitted.  All logging
can be turned off by calling \f(CWinit_level(0)\fR.
.SS "\fIinit_prefix()\fP"
.IX Subsection "init_prefix()"
.Vb 1
\& ZOOM::Log::init_prefix($0);
.Ve
.PP
Initialises a prefix string to be included in all log-messages.
.SS "\fIinit_file()\fP"
.IX Subsection "init_file()"
.Vb 1
\& ZOOM::Log::init_file("/tmp/myapp.log");
.Ve
.PP
Initialises the output file to be used for logging: subsequent
log-messages are written to the nominated file.  If this function is
not called, log-messages are written to the standard error stream.
.SS "\fIinit()\fP"
.IX Subsection "init()"
.Vb 1
\& ZOOM::Log::init($level, $0, "/tmp/myapp.log");
.Ve
.PP
Initialises the log-level, the logging prefix and the logging output
file in a single operation.
.SS "\fItime_format()\fP"
.IX Subsection "time_format()"
.Vb 1
\& ZOOM::Log::time_format("%Y\-%m\-%d %H:%M:%S");
.Ve
.PP
Sets the format in which log\-messages' timestamps are emitted, by
means of a format-string like that used in the C function
\&\f(CW\*(C`strftime()\*(C'\fR.  The example above emits year, month, day, hours,
minutes and seconds in big-endian order, such that timestamps can be
sorted lexicographically.
.SS "\fIinit_max_size()\fP"
.IX Subsection "init_max_size()"
(This doesn't seem to work, so I won't bother describing it.)
.SS "\fIlog()\fP"
.IX Subsection "log()"
.Vb 2
\& ZOOM::Log::log(8192, "reducing to warp\-factor $wf");
\& ZOOM::Log::log("myapp", "starting up with pid ", $$);
.Ve
.PP
Provided that the first argument, log-level, is among the modules
previously established by \f(CW\*(C`init_level()\*(C'\fR, this function emits a
log-message made up of a timestamp, the prefix supplied to
\&\f(CW\*(C`init_prefix()\*(C'\fR, if any, and the concatenation of all arguments after
the first.  The message is written to the standard output stream, or
to the file previous specified by \f(CW\*(C`init_file()\*(C'\fR if this has been
called.
.PP
The log-level argument may be either a numeric value, as returned from
\&\f(CW\*(C`module_level()\*(C'\fR, or a string containing the module name.
.SH "ASYNCHRONOUS APPLICATIONS"
.IX Header "ASYNCHRONOUS APPLICATIONS"
Although asynchronous applications are conceptually complex, the \s-1ZOOM\s0
support for them is provided through a very simple interface,
consisting of one option (\f(CW\*(C`async\*(C'\fR), one function (\f(CW\*(C`ZOOM::event()\*(C'\fR),
one Connection method (\f(CW\*(C`last_event()\*(C'\fR and an enumeration
(\f(CW\*(C`ZOOM::Event\*(C'\fR).
.PP
The approach is as follows:
.IP "Initialisation" 4
.IX Item "Initialisation"
Create several connections to the various servers, each of them having
the option \f(CW\*(C`async\*(C'\fR set, and with whatever additional options are
required \- e.g. the piggyback retrieval record-count can be set so
that records will be returned in search responses.
.IP "Operations" 4
.IX Item "Operations"
Send searches to the connections, request records, etc.
.IP "Event harvesting" 4
.IX Item "Event harvesting"
Repeatedly call \f(CW\*(C`ZOOM::event()\*(C'\fR to discover what responses are being
received from the servers.  Each time this function returns, it
indicates which of the connections has fired; this connection can then
be interrogated with the \f(CW\*(C`last_event()\*(C'\fR method to discover what event
has occurred, and the return value \- an element of the \f(CW\*(C`ZOOM::Event\*(C'\fR
enumeration \- can be tested to determine what to do next.  For
example, the \f(CW\*(C`ZEND\*(C'\fR event indicates that no further operations are
outstanding on the connection, so any fetched records can now be
immediately obtained.
.PP
Here is a very short program (omitting all error-checking!) which
demonstrates this process.  It parallel-searches three servers (or more
of you add them the list), displaying the first record in the
result-set of each server as soon as it becomes available.
.PP
.Vb 10
\& use ZOOM;
\& @servers = (\*(Aqz3950.loc.gov:7090/Voyager\*(Aq,
\&             \*(Aqz3950.indexdata.com:210/gils\*(Aq,
\&             \*(Aqagricola.nal.usda.gov:7190/Voyager\*(Aq);
\& for ($i = 0; $i < @servers; $i++) {
\&     $z[$i] = new ZOOM::Connection($servers[$i], 0,
\&                                   async => 1, # asynchronous mode
\&                                   count => 1, # piggyback retrieval count
\&                                   preferredRecordSyntax => "usmarc");
\&     $r[$i] = $z[$i]\->search_pqf("mineral");
\& }
\& while (($i = ZOOM::event(\e@z)) != 0) {
\&     $ev = $z[$i\-1]\->last_event();
\&     print("connection ", $i\-1, ": ", ZOOM::event_str($ev), "\en");
\&     if ($ev == ZOOM::Event::ZEND) {
\&         $size = $r[$i\-1]\->size();
\&         print "connection ", $i\-1, ": $size hits\en";
\&         print $r[$i\-1]\->record(0)\->render()
\&             if $size > 0;
\&     }
\& }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The \s-1ZOOM\s0 abstract \s-1API\s0,
http://zoom.z3950.org/api/zoom\-current.html
.PP
The \f(CW\*(C`Net::Z3950::ZOOM\*(C'\fR module, included in the same distribution as this one.
.PP
The \f(CW\*(C`Net::Z3950\*(C'\fR module, which this one supersedes.
http://perl.z3950.org/
.PP
The documentation for the ZOOM-C module of the \s-1YAZ\s0 Toolkit, which this
module is built on.  Specifically, its lists of options are useful.
http://indexdata.com/yaz/doc/zoom.tkl
.PP
The \s-1BIB\-1\s0 diagnostic set of Z39.50,
http://www.loc.gov/z3950/agency/defns/bib1diag.html
.SH "AUTHOR"
.IX Header "AUTHOR"
Mike Taylor, <mike@indexdata.com>
.SH "COPYRIGHT AND LICENCE"
.IX Header "COPYRIGHT AND LICENCE"
Copyright (C) 2005 by Index Data.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.4 or,
at your option, any later version of Perl 5 you may have available.
