.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Rose::Class::MakeMethods::Set 3"
.TH Rose::Class::MakeMethods::Set 3 "2010-10-17" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Rose::Class::MakeMethods::Set \- Create class methods to manage sets.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MyClass;
\&
\&  use Rose::Class::MakeMethods::Set
\&  (
\&    inheritable_set =>
\&    [
\&      required_name =>
\&      {
\&        add_implies => \*(Aqadd_valid_name\*(Aq,
\&        test_method => \*(Aqname_is_required\*(Aq, 
\&      },
\&    ],
\&
\&    inherited_set =>
\&    [
\&      valid_name =>
\&      {
\&        test_method => \*(Aqname_is_valid\*(Aq, 
\&      },
\&    ],
\&  );
\&
\&  ...
\&
\&  package MySubClass;
\&  our @ISA = qw(MyClass);
\&  ...
\&
\&  MyClass\->add_valid_names(\*(AqA\*(Aq, \*(AqB\*(Aq, \*(AqC\*(Aq);
\&  MyClass\->add_required_name(\*(AqD\*(Aq);
\&
\&  $v1 = join(\*(Aq,\*(Aq, MyClass\->valid_names);       # \*(AqA,B,C,D\*(Aq;
\&  $r1 = join(\*(Aq,\*(Aq, MyClass\->required_names);    # \*(AqD\*(Aq
\&
\&  $v2 = join(\*(Aq,\*(Aq, MySubClass\->valid_names);    # \*(AqA,B,C,D\*(Aq;
\&  $r2 = join(\*(Aq,\*(Aq, MySubClass\->required_names); # \*(AqD\*(Aq
\&
\&  MySubClass\->add_required_names(\*(AqX\*(Aq, \*(AqY\*(Aq);
\&
\&  $v2 = join(\*(Aq,\*(Aq, MySubClass\->valid_names);    # \*(AqA,B,C,D,X,Y\*(Aq;
\&  $r2 = join(\*(Aq,\*(Aq, MySubClass\->required_names); # \*(AqD,X,Y\*(Aq
\&
\&  MySubClass\->delete_valid_names(\*(AqB\*(Aq, \*(AqX\*(Aq);
\&
\&  $v1 = join(\*(Aq,\*(Aq, MyClass\->valid_names);       # \*(AqA,B,C,D\*(Aq;
\&  $r1 = join(\*(Aq,\*(Aq, MyClass\->required_names);    # \*(AqD\*(Aq
\&
\&  $v2 = join(\*(Aq,\*(Aq, MySubClass\->valid_names);    # \*(AqA,C,D,Y\*(Aq;
\&  $r2 = join(\*(Aq,\*(Aq, MySubClass\->required_names); # \*(AqD,X,Y\*(Aq
\&
\&  MySubClass\->delete_required_name(\*(AqD\*(Aq);
\&
\&  $v1 = join(\*(Aq,\*(Aq, MyClass\->valid_names);       # \*(AqA,B,C,D\*(Aq;
\&  $r1 = join(\*(Aq,\*(Aq, MyClass\->required_names);    # \*(AqD\*(Aq
\&
\&  $v2 = join(\*(Aq,\*(Aq, MySubClass\->valid_names);    # \*(AqA,C,D,Y\*(Aq;
\&  $r2 = join(\*(Aq,\*(Aq, MySubClass\->required_names); # \*(AqX,Y\*(Aq
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Rose::Class::MakeMethods::Set is a method maker that inherits from Rose::Object::MakeMethods.  See the Rose::Object::MakeMethods documentation to learn about the interface.  The method types provided by this module are described below.  All methods work only with classes, not objects.
.SH "METHODS TYPES"
.IX Header "METHODS TYPES"
.IP "\fBinheritable_set\fR" 4
.IX Item "inheritable_set"
Create a family of class methods for managing an inheritable set of items, each with an optional associated value.  Each item must be a string, or must stringify to a unique string value, since a hash is used internally to store the set.
.Sp
The set is inherited by subclasses, but any subclass that accesses or manipulates the set in any way will immediately get its own private copy of the set \fIas it exists in the superclass at the time of the access or manipulation\fR.  The superclass from which the set is copied is the closest (\*(L"least super\*(R") class that has ever accessed or manipulated this set.
.Sp
These may sound like wacky rules, but it may help to know that this family of methods was created for use in the Rose::HTML::Objects family of modules to manage the set of required \s-1HTML\s0 attributes (and their optional default values) for various \s-1HTML\s0 tags.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.ie n .IP """add_implies""" 4
.el .IP "\f(CWadd_implies\fR" 4
.IX Item "add_implies"
.PD
A method name, or reference to a list of method names, to call when an item is added to the set.  Each added attribute is passed as an argument to each method in the \f(CW\*(C`add_implies\*(C'\fR list.
.ie n .IP """add_method""" 4
.el .IP "\f(CWadd_method\fR" 4
.IX Item "add_method"
The name of the class method used to add a single item to the set. Defaults to the method name with the prefix \f(CW\*(C`add_\*(C'\fR added.
.ie n .IP """adds_method""" 4
.el .IP "\f(CWadds_method\fR" 4
.IX Item "adds_method"
The name of the class method used to add one or more items to the set. Defaults to \f(CW\*(C`add_method\*(C'\fR with \f(CW\*(C`s\*(C'\fR added to the end.
.ie n .IP """clear_method""" 4
.el .IP "\f(CWclear_method\fR" 4
.IX Item "clear_method"
The name of the class method used to clear the contents of the set. Defaults to \f(CW\*(C`plural_name\*(C'\fR with a \f(CW\*(C`clear_\*(C'\fR prefix added.
.ie n .IP """delete_implies""" 4
.el .IP "\f(CWdelete_implies\fR" 4
.IX Item "delete_implies"
A method name, or reference to a list of method names, to call when an item is removed from the set.  Each deleted attribute is passed as an argument to each method in the \f(CW\*(C`delete_implies\*(C'\fR list.
.ie n .IP """delete_method""" 4
.el .IP "\f(CWdelete_method\fR" 4
.IX Item "delete_method"
The name of the class method used to remove a single item from the set. Defaults to the method name with the prefix \f(CW\*(C`delete_\*(C'\fR added.
.ie n .IP """deletes_method""" 4
.el .IP "\f(CWdeletes_method\fR" 4
.IX Item "deletes_method"
The name of the class method used to remove one or more items from the set. Defaults to \f(CW\*(C`plural_name\*(C'\fR with a \f(CW\*(C`delete_\*(C'\fR prefix added.
.ie n .IP """hash_method""" 4
.el .IP "\f(CWhash_method\fR" 4
.IX Item "hash_method"
The name of the class method that returns a reference to the actual hash that contains the set of items in scalar context, and a shallow copy of the hash in list context.  Defaults to \f(CW\*(C`plural_name\*(C'\fR with \f(CW\*(C`_hash\*(C'\fR added to the end.
.ie n .IP """interface""" 4
.el .IP "\f(CWinterface\fR" 4
.IX Item "interface"
Choose the interface.  This is kind of pointless since there is only one interface right now.  Defaults to \f(CW\*(C`all\*(C'\fR, obviously.
.ie n .IP """list_method""" 4
.el .IP "\f(CWlist_method\fR" 4
.IX Item "list_method"
The name of the class method that returns a reference to a sorted list of items in scalar context, or a sorted list in list context.  If called with any arguments, the set is cleared with a call to \f(CW\*(C`clear_method\*(C'\fR, then the set is repopulated by passing all of the arguments to a call to \f(CW\*(C`adds_method\*(C'\fR.  The method name defaults to \f(CW\*(C`plural_name\*(C'\fR.
.ie n .IP """plural_name""" 4
.el .IP "\f(CWplural_name\fR" 4
.IX Item "plural_name"
The plural name of the items, used to construct the default names for some other methods.  Defaults to the method name with \f(CW\*(C`s\*(C'\fR added.
.ie n .IP """test_method""" 4
.el .IP "\f(CWtest_method\fR" 4
.IX Item "test_method"
The name of the class method that tests for the existence of an item in the set.  Defaults to the method name with the prefix \f(CW\*(C`is_\*(C'\fR added.
.ie n .IP """value_method""" 4
.el .IP "\f(CWvalue_method\fR" 4
.IX Item "value_method"
The name of the class method used to get and set the (optional) value associated with each item in the set.  Defaults to the method name with \f(CW\*(C`_value\*(C'\fR added to the end.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
.PD
Creates the entire family of methods described above.  The example below illustrates their use.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&    package MyClass;
\&
\&    use Rose::Class::MakeMethods::Set
\&    (
\&      inheritable_set =>
\&      [
\&        valid_name =>
\&        {
\&          test_method    => \*(Aqname_is_valid\*(Aq, 
\&          delete_implies => \*(Aqdelete_required_name\*(Aq,
\&        },
\&
\&        required_name =>
\&        {
\&          add_implies => \*(Aqadd_valid_name\*(Aq,
\&          test_method => \*(Aqname_is_required\*(Aq, 
\&        },
\&      ],
\&    );
\&
\&    package MySubClass;
\&    our @ISA = qw(MyClass);
\&    ...
\&
\&    MyClass\->add_valid_names(\*(AqA\*(Aq, \*(AqB\*(Aq, \*(AqC\*(Aq);
\&    MyClass\->add_required_name(\*(AqD\*(Aq);
\&
\&    $v1 = join(\*(Aq,\*(Aq, MyClass\->valid_names);       # \*(AqA,B,C,D\*(Aq;
\&    $r1 = join(\*(Aq,\*(Aq, MyClass\->required_names);    # \*(AqD\*(Aq
\&
\&    $v2 = join(\*(Aq,\*(Aq, MySubClass\->valid_names);    # \*(AqA,B,C,D\*(Aq;
\&    $r2 = join(\*(Aq,\*(Aq, MySubClass\->required_names); # \*(AqD\*(Aq
\&
\&    MySubClass\->add_required_names(\*(AqX\*(Aq, \*(AqY\*(Aq);
\&
\&    $v2 = join(\*(Aq,\*(Aq, MySubClass\->valid_names);    # \*(AqA,B,C,D,X,Y\*(Aq;
\&    $r2 = join(\*(Aq,\*(Aq, MySubClass\->required_names); # \*(AqD,X,Y\*(Aq
\&
\&    MySubClass\->delete_valid_names(\*(AqB\*(Aq, \*(AqX\*(Aq);
\&
\&    $v1 = join(\*(Aq,\*(Aq, MyClass\->valid_names);       # \*(AqA,B,C,D\*(Aq;
\&    $r1 = join(\*(Aq,\*(Aq, MyClass\->required_names);    # \*(AqD\*(Aq
\&
\&    $v2 = join(\*(Aq,\*(Aq, MySubClass\->valid_names);    # \*(AqA,C,D,Y\*(Aq;
\&    $r2 = join(\*(Aq,\*(Aq, MySubClass\->required_names); # \*(AqD,Y\*(Aq
\&
\&    MySubClass\->delete_required_name(\*(AqD\*(Aq);
\&
\&    $v1 = join(\*(Aq,\*(Aq, MyClass\->valid_names);       # \*(AqA,B,C,D\*(Aq;
\&    $r1 = join(\*(Aq,\*(Aq, MyClass\->required_names);    # \*(AqD\*(Aq
\&
\&    $v2 = join(\*(Aq,\*(Aq, MySubClass\->valid_names);    # \*(AqA,C,D,Y\*(Aq;
\&    $r2 = join(\*(Aq,\*(Aq, MySubClass\->required_names); # \*(AqY\*(Aq
\&
\&    MyClass\->name_is_required(\*(AqD\*(Aq);    # true
\&    MySubClass\->name_is_required(\*(AqD\*(Aq); # false
\&
\&    $h = MyClass\->valid_names_hash;
\&
\&    # Careful!  This is the actual hash used for set storage!
\&    # You should use delete_valid_name() instead!
\&    delete $h\->{\*(AqC\*(Aq}; 
\&
\&    MySubClass\->required_name_value(Y => \*(Aqxval\*(Aq);
\&
\&    print MySubClass\->required_name_value(\*(AqY\*(Aq); # \*(Aqxval\*(Aq
\&
\&    %r = MySubClass\->required_names_hash;
\&
\&    print $r{\*(AqY\*(Aq}; # \*(Aqxval\*(Aq
\&
\&    # Okay: %r is a (shallow) copy, not the actual hash
\&    delete $r{\*(AqY\*(Aq};
.Ve
.RE
.IP "\fBinherited_set\fR" 4
.IX Item "inherited_set"
Create a family of class methods for managing an inherited set of items. Each item must be a string, or must stringify to a unique string value, since a hash is used internally to store the set.
.Sp
An inherited set is made up of the union of the sets of all superclasses, minus any items that are explicitly deleted in the current class.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.ie n .IP """add_implies""" 4
.el .IP "\f(CWadd_implies\fR" 4
.IX Item "add_implies"
.PD
A method name, or reference to a list of method names, to call when an item is added to the set.  Each added attribute is passed as an argument to each method in the \f(CW\*(C`add_implies\*(C'\fR list.
.ie n .IP """add_method""" 4
.el .IP "\f(CWadd_method\fR" 4
.IX Item "add_method"
The name of the class method used to add a single item to the set. Defaults to the method name with the prefix \f(CW\*(C`add_\*(C'\fR added.
.ie n .IP """adds_method""" 4
.el .IP "\f(CWadds_method\fR" 4
.IX Item "adds_method"
The name of the class method used to add one or more items to the set. Defaults to \f(CW\*(C`add_method\*(C'\fR with \f(CW\*(C`s\*(C'\fR added to the end.
.ie n .IP """cache_method""" 4
.el .IP "\f(CWcache_method\fR" 4
.IX Item "cache_method"
The name of the class method used to retrieve (or generate, if it doesn't exist) the internal cache for the set.  This should be considered a private method, but it is listed here because it does take up a spot in the method namespace.  Defaults to \f(CW\*(C`plural_name\*(C'\fR with \f(CW\*(C`_cache\*(C'\fR added to the end.
.ie n .IP """clear_method""" 4
.el .IP "\f(CWclear_method\fR" 4
.IX Item "clear_method"
The name of the class method used to clear the contents of the set. Defaults to \f(CW\*(C`plural_name\*(C'\fR with a \f(CW\*(C`clear_\*(C'\fR prefix added.
.ie n .IP """delete_implies""" 4
.el .IP "\f(CWdelete_implies\fR" 4
.IX Item "delete_implies"
A method name, or reference to a list of method names, to call when an item is removed from the set.  Each deleted attribute is passed as an argument to each method in the \f(CW\*(C`delete_implies\*(C'\fR list.
.ie n .IP """delete_method""" 4
.el .IP "\f(CWdelete_method\fR" 4
.IX Item "delete_method"
The name of the class method used to remove a single item from the set. Defaults to the method name with the prefix \f(CW\*(C`delete_\*(C'\fR added.
.ie n .IP """deletes_method""" 4
.el .IP "\f(CWdeletes_method\fR" 4
.IX Item "deletes_method"
The name of the class method used to remove one or more items from the set. Defaults to \f(CW\*(C`plural_name\*(C'\fR with a \f(CW\*(C`delete_\*(C'\fR prefix added.
.ie n .IP """hash_method""" 4
.el .IP "\f(CWhash_method\fR" 4
.IX Item "hash_method"
The name of the class method that returns a hash (in list context) or a reference to a hash (in scalar context) that contains the set of items. The existence of a key in the hash indicates its existence in the set. Defaults to \f(CW\*(C`plural_name\*(C'\fR with \f(CW\*(C`_hash\*(C'\fR added to the end.
.ie n .IP """inherit_method""" 4
.el .IP "\f(CWinherit_method\fR" 4
.IX Item "inherit_method"
The name of the class method used to indicate that an inherited value that was previously deleted from the set should return to being inherited.  Defaults to the method name with the prefix \f(CW\*(C`inherit_\*(C'\fR added.
.ie n .IP """inherits_method""" 4
.el .IP "\f(CWinherits_method\fR" 4
.IX Item "inherits_method"
The name of the class method used to indicate that one or more inherited values that were previously deleted from the set should return to being inherited.  Defaults to the \f(CW\*(C`inherit_method\*(C'\fR name with \f(CW\*(C`s\*(C'\fR added to the end.
.ie n .IP """interface""" 4
.el .IP "\f(CWinterface\fR" 4
.IX Item "interface"
Choose the interface.  This is kind of pointless since there is only one interface right now.  Defaults to \f(CW\*(C`all\*(C'\fR, obviously.
.ie n .IP """list_method""" 4
.el .IP "\f(CWlist_method\fR" 4
.IX Item "list_method"
The name of the class method that returns a reference to a sorted list of items in scalar context, or a sorted list in list context.  If called with any arguments, the set is cleared with a call to \f(CW\*(C`clear_method\*(C'\fR, then the set is repopulated by passing all of the arguments to a call to \f(CW\*(C`adds_method\*(C'\fR.  The method name defaults to \f(CW\*(C`plural_name\*(C'\fR.
.ie n .IP """plural_name""" 4
.el .IP "\f(CWplural_name\fR" 4
.IX Item "plural_name"
The plural name of the items, used to construct the default names for some other methods.  Defaults to the method name with \f(CW\*(C`s\*(C'\fR added.
.ie n .IP """test_method""" 4
.el .IP "\f(CWtest_method\fR" 4
.IX Item "test_method"
The name of the class method that tests for the existence of an item in the set.  Defaults to the method name with the prefix \f(CW\*(C`is_\*(C'\fR added.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
.PD
Creates the entire family of methods described above.  The example
below illustrates their use.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&    package MyClass;
\&
\&    use Rose::Class::MakeMethods::Set
\&    (
\&      inherited_set =>
\&      [
\&        valid_name =>
\&        {
\&          test_method     => \*(Aqname_is_valid\*(Aq, 
\&          delete_implies  => \*(Aqdelete_required_name\*(Aq,
\&          inherit_implies => \*(Aqinherit_required_name\*(Aq,
\&        },
\&
\&        required_name =>
\&        {
\&          add_implies => \*(Aqadd_valid_name\*(Aq,
\&          test_method => \*(Aqname_is_required\*(Aq, 
\&        },
\&      ],
\&    );
\&    ...
\&
\&    package MySubClass;
\&    our @ISA = qw(MyClass);
\&    ...
\&
\&    MyClass\->add_valid_names(\*(AqA\*(Aq, \*(AqB\*(Aq, \*(AqC\*(Aq);
\&    MyClass\->add_required_name(\*(AqD\*(Aq);
\&
\&
\&    $v1 = join(\*(Aq,\*(Aq, MyClass\->valid_names);       # \*(AqA,B,C,D\*(Aq;
\&    $r1 = join(\*(Aq,\*(Aq, MyClass\->required_names);    # \*(AqD\*(Aq
\&
\&    $v2 = join(\*(Aq,\*(Aq, MySubClass\->valid_names);    # \*(AqA,B,C,D\*(Aq;
\&    $r2 = join(\*(Aq,\*(Aq, MySubClass\->required_names); # \*(AqD\*(Aq
\&
\&    MyClass\->add_required_names(\*(AqX\*(Aq, \*(AqY\*(Aq);
\&
\&    $v2 = join(\*(Aq,\*(Aq, MySubClass\->valid_names);    # \*(AqA,B,C,D,X,Y\*(Aq;
\&    $r2 = join(\*(Aq,\*(Aq, MySubClass\->required_names); # \*(AqD,X,Y\*(Aq
\&
\&    MySubClass\->delete_valid_names(\*(AqB\*(Aq, \*(AqX\*(Aq);
\&
\&    $v1 = join(\*(Aq,\*(Aq, MyClass\->valid_names);       # \*(AqA,B,C,D,X,Y\*(Aq;
\&    $r1 = join(\*(Aq,\*(Aq, MyClass\->required_names);    # \*(AqD,X,Y\*(Aq
\&
\&    $v2 = join(\*(Aq,\*(Aq, MySubClass\->valid_names);    # \*(AqA,C,D,Y\*(Aq;
\&    $r2 = join(\*(Aq,\*(Aq, MySubClass\->required_names); # \*(AqD,Y\*(Aq
\&
\&    MySubClass\->delete_required_name(\*(AqD\*(Aq);
\&
\&    $v1 = join(\*(Aq,\*(Aq, MyClass\->valid_names);       # \*(AqA,B,C,D,X,Y\*(Aq;
\&    $r1 = join(\*(Aq,\*(Aq, MyClass\->required_names);    # \*(AqD,X,Y\*(Aq
\&
\&    $v2 = join(\*(Aq,\*(Aq, MySubClass\->valid_names);    # \*(AqA,C,D,Y\*(Aq;
\&    $r2 = join(\*(Aq,\*(Aq, MySubClass\->required_names); # \*(AqY\*(Aq
\&
\&    MySubClass\->inherit_required_name(\*(AqD\*(Aq);
\&
\&    $v1 = join(\*(Aq,\*(Aq, MyClass\->valid_names);       # \*(AqA,B,C,D,X,Y\*(Aq;
\&    $r1 = join(\*(Aq,\*(Aq, MyClass\->required_names);    # \*(AqD,X,Y\*(Aq
\&
\&    $v2 = join(\*(Aq,\*(Aq, MySubClass\->valid_names);    # \*(AqA,C,D,Y\*(Aq;
\&    $r2 = join(\*(Aq,\*(Aq, MySubClass\->required_names); # \*(AqD,Y\*(Aq
\&
\&    MySubClass\->delete_valid_name(\*(AqD\*(Aq);
\&
\&    $v1 = join(\*(Aq,\*(Aq, MyClass\->valid_names);       # \*(AqA,B,C,D,X,Y\*(Aq;
\&    $r1 = join(\*(Aq,\*(Aq, MyClass\->required_names);    # \*(AqD,X,Y\*(Aq
\&
\&    $v2 = join(\*(Aq,\*(Aq, MySubClass\->valid_names);    # \*(AqA,C,Y\*(Aq;
\&    $r2 = join(\*(Aq,\*(Aq, MySubClass\->required_names); # \*(AqY\*(Aq
\&
\&    MySubClass\->inherit_valid_name(\*(AqD\*(Aq);
\&
\&    $v1 = join(\*(Aq,\*(Aq, MyClass\->valid_names);       # \*(AqA,B,C,D,X,Y\*(Aq;
\&    $r1 = join(\*(Aq,\*(Aq, MyClass\->required_names);    # \*(AqD,X,Y\*(Aq
\&
\&    $v2 = join(\*(Aq,\*(Aq, MySubClass\->valid_names);    # \*(AqA,C,D,Y\*(Aq;
\&    $r2 = join(\*(Aq,\*(Aq, MySubClass\->required_names); # \*(AqD,Y\*(Aq
\&
\&    MyClass\->delete_valid_name(\*(AqD\*(Aq);
\&
\&    $v1 = join(\*(Aq,\*(Aq, MyClass\->valid_names);       # \*(AqA,B,C,X,Y\*(Aq;
\&    $r1 = join(\*(Aq,\*(Aq, MyClass\->required_names);    # \*(AqX,Y\*(Aq
\&
\&    $v2 = join(\*(Aq,\*(Aq, MySubClass\->valid_names);    # \*(AqA,C,Y\*(Aq;
\&    $r2 = join(\*(Aq,\*(Aq, MySubClass\->required_names); # \*(AqY\*(Aq
\&
\&    MySubClass\->add_required_name(\*(AqD\*(Aq);
\&
\&    $v1 = join(\*(Aq,\*(Aq, MyClass\->valid_names);       # \*(AqA,B,C,X,Y\*(Aq;
\&    $r1 = join(\*(Aq,\*(Aq, MyClass\->required_names);    # \*(AqX,Y\*(Aq
\&
\&    $v2 = join(\*(Aq,\*(Aq, MySubClass\->valid_names);    # \*(AqA,C,D,Y\*(Aq;
\&    $r2 = join(\*(Aq,\*(Aq, MySubClass\->required_names); # \*(AqD,Y\*(Aq
\&
\&    $h = MyClass\->valid_names_hash;
\&
\&    # This has no affect on the set.  $h is not a reference to the 
\&    # actual hash used for set storage.
\&    delete $h\->{\*(AqC\*(Aq}; 
\&
\&    $v1 = join(\*(Aq,\*(Aq, MyClass\->valid_names);       # \*(AqA,B,C,X,Y\*(Aq;
\&    $r1 = join(\*(Aq,\*(Aq, MyClass\->required_names);    # \*(AqX,Y\*(Aq
.Ve
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
John C. Siracusa (siracusa@gmail.com)
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2010 by John C. Siracusa.  All rights reserved.  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
