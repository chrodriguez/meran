.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MARC::File 3"
.TH MARC::File 3 "2010-03-29" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MARC::File \- Base class for files of MARC records
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use MARC::File::USMARC;
\&
\&    # If you have werid control fields...
\&    use MARC::Field;
\&    MARC::Field\->allow_controlfield_tags(\*(AqFMT\*(Aq, \*(AqLDX\*(Aq);    
\&
\&    my $file = MARC::File::USMARC\->in( $filename );
\&
\&    while ( my $marc = $file\->next() ) {
\&        # Do something
\&    }
\&    $file\->close();
\&    undef $file;
.Ve
.SH "EXPORT"
.IX Header "EXPORT"
None.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIin()\fP"
.IX Subsection "in()"
Opens a file for import. Ordinarily you will use \f(CW\*(C`MARC::File::USMARC\*(C'\fR
or \f(CW\*(C`MARC::File::MicroLIF\*(C'\fR to do this.
.PP
.Vb 1
\&    my $file = MARC::File::USMARC\->in( \*(Aqfile.marc\*(Aq );
.Ve
.PP
Returns a \f(CW\*(C`MARC::File\*(C'\fR object, or \f(CW\*(C`undef\*(C'\fR on failure. If you
encountered an error the error message will be stored in
\&\f(CW$MARC::File::ERROR\fR.
.PP
Optionally you can also pass in a filehandle, and \f(CW\*(C`MARC::File\*(C'\fR.
will \*(L"do the right thing\*(R".
.PP
.Vb 2
\&    my $handle = IO::File\->new( \*(Aqgunzip \-c file.marc.gz |\*(Aq );
\&    my $file = MARC::File::USMARC\->in( $handle );
.Ve
.SS "next( [\e&filter_func] )"
.IX Subsection "next( [&filter_func] )"
Reads the next record from the file handle passed in.
.PP
The \f(CW$filter_func\fR is a reference to a filtering function.  Currently,
only \s-1USMARC\s0 records support this.  See MARC::File::USMARC's \f(CW\*(C`decode()\*(C'\fR
function for details.
.PP
Returns a MARC::Record reference, or \f(CW\*(C`undef\*(C'\fR on error.
.SS "\fIskip()\fP"
.IX Subsection "skip()"
Skips over the next record in the file.  Same as \f(CW\*(C`next()\*(C'\fR,
without the overhead of parsing a record you're going to throw away
anyway.
.PP
Returns 1 or undef.
.SS "\fIwarnings()\fP"
.IX Subsection "warnings()"
Simlilar to the methods in MARC::Record and MARC::Batch,
\&\f(CW\*(C`warnings()\*(C'\fR will return any warnings that have accumulated while
processing this file; and as a side-effect will clear the warnings buffer.
.SS "\fIclose()\fP"
.IX Subsection "close()"
Closes the file, both from the object's point of view, and the actual file.
.SS "\fIwrite()\fP"
.IX Subsection "write()"
Writes a record to the output file.  This method must be overridden
in your subclass.
.SS "\fIdecode()\fP"
.IX Subsection "decode()"
Decodes a record into a \s-1USMARC\s0 format.  This method must be overridden
in your subclass.
.SH "RELATED MODULES"
.IX Header "RELATED MODULES"
MARC::Record
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
\&\f(CW\*(C`out()\*(C'\fR method
.Sp
We only handle files for input right now.
.SH "LICENSE"
.IX Header "LICENSE"
This code may be distributed under the same terms as Perl itself.
.PP
Please note that these modules are not products of or supported by the
employers of the various contributors to the code.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Lester, \f(CW\*(C`<andy@petdance.com>\*(C'\fR
