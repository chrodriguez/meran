.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Rose::DB::Object::Metadata::Relationship::ManyToMany 3"
.TH Rose::DB::Object::Metadata::Relationship::ManyToMany 3 "2010-07-23" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Rose::DB::Object::Metadata::Relationship::ManyToMany \- Many to many table relationship metadata object.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Rose::DB::Object::Metadata::Relationship::ManyToMany;
\&
\&  $rel = Rose::DB::Object::Metadata::Relationship::ManyToMany\->new(...);
\&  $rel\->make_methods(...);
\&  ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Objects of this class store and manipulate metadata for relationships in which rows from one table are connected to rows in another table through an intermediate table that maps between them.
.PP
This class inherits from Rose::DB::Object::Metadata::Relationship. Inherited methods that are not overridden will not be documented a second time here.  See the Rose::DB::Object::Metadata::Relationship documentation for more information.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
Consider the following tables.
.PP
.Vb 5
\&    CREATE TABLE widgets
\&    (
\&      id    SERIAL PRIMARY KEY,
\&      name  VARCHAR(255)
\&    );
\&
\&    CREATE TABLE colors
\&    (
\&      id    SERIAL PRIMARY KEY,
\&      name  VARCHAR(255)
\&    );
\&
\&    CREATE TABLE widget_color_map
\&    (
\&      id         SERIAL PRIMARY KEY,
\&      widget_id  INT NOT NULL REFERENCES widgets (id),
\&      color_id   INT NOT NULL REFERENCES colors (id),
\&      UNIQUE(widget_id, color_id)
\&    );
.Ve
.PP
Given these tables, each widget can have zero or more colors, and each color can be applied to zero or more widgets.  This is the type of \*(L"many to many\*(R" relationship that this class is designed to handle.
.PP
In order to do so, each of the three of the tables that participate in the relationship must be fronted by its own Rose::DB::Object\-derived class.  Let's call those classes \f(CW\*(C`Widget\*(C'\fR, \f(CW\*(C`Color\*(C'\fR, and \f(CW\*(C`WidgetColorMap\*(C'\fR.
.PP
The class that maps between the other two classes is called the "map class."  In this example, it's \f(CW\*(C`WidgetColorMap\*(C'\fR.  The map class \fBmust\fR have a foreign key and/or \*(L"many to one\*(R" relationship pointing to each of the two classes that it maps between.
.PP
When it comes to actually creating the three classes that participate in a \*(L"many to many\*(R" relationship, there's a bit of a \*(L"chicken and egg\*(R" problem.  All these classes need to know about each other more or less \*(L"simultaneously,\*(R" but they must be defined in a serial fashion, and may be loaded in any order by the user.
.PP
In order to account for this, method creation may be deferred for any foreign key or relationship that does not yet have all the information it requires to do its job.  This should be transparent to the developer.
.PP
Here's a complete example using the \f(CW\*(C`Widget\*(C'\fR, \f(CW\*(C`Color\*(C'\fR, and \f(CW\*(C`WidgetColorMap\*(C'\fR classes.  First, the \f(CW\*(C`Widget\*(C'\fR class which has a \*(L"many to many\*(R" relationship through which it can retrieve its colors.
.PP
.Vb 1
\&  package Widget;
\&
\&  use base \*(AqRose::DB::Object\*(Aq;
\&
\&  _\|_PACKAGE_\|_\->meta\->setup
\&  (
\&    table => \*(Aqwidgets\*(Aq,
\&
\&    columns =>
\&    [
\&      id   => { type => \*(Aqint\*(Aq, primary_key => 1 },
\&      name => { type => \*(Aqvarchar\*(Aq, length => 255 },
\&    ],
\&
\&    relationships =>
\&    [
\&      # Define "many to many" relationship to get colors
\&      colors =>
\&      {
\&        type      => \*(Aqmany to many\*(Aq,
\&        map_class => \*(AqWidgetColorMap\*(Aq,
\&
\&        # These are only necessary if the relationship is ambiguous
\&        #map_from  => \*(Aqwidget\*(Aq,
\&        #map_to    => \*(Aqcolor\*(Aq,
\&      },
\&    ],
\&  );
\&
\&  1;
.Ve
.PP
Next, the \f(CW\*(C`Color\*(C'\fR class which has a \*(L"many to many\*(R" relationship through which it can retrieve all the widgets that have this color.
.PP
.Vb 1
\&  package Color;
\&
\&  use base \*(AqRose::DB::Object\*(Aq;
\&
\&  _\|_PACKAGE_\|_\->meta\->setup
\&  (
\&    table => \*(Aqcolors\*(Aq,
\&
\&    columns =>
\&    [
\&      id   => { type => \*(Aqint\*(Aq, primary_key => 1 },
\&      name => { type => \*(Aqvarchar\*(Aq, length => 255 },
\&    ],
\&
\&    relationships =>
\&    [
\&      # Define "many to many" relationship to get widgets
\&      widgets =>
\&      {
\&        type      => \*(Aqmany to many\*(Aq,
\&        map_class => \*(AqWidgetColorMap\*(Aq,
\&
\&        # These are only necessary if the relationship is ambiguous
\&        #map_from  => \*(Aqcolor\*(Aq,
\&        #map_to    => \*(Aqwidget\*(Aq,
\&      },
\&    ],
\&  );
\&
\&  1;
.Ve
.PP
Finally, the \f(CW\*(C`WidgetColorMap\*(C'\fR class must have a foreign key or \*(L"many to one\*(R" relationship for each of the two classes that it maps between (\f(CW\*(C`Widget\*(C'\fR and \f(CW\*(C`Color\*(C'\fR).
.PP
.Vb 1
\&  package WidgetColorMap;
\&
\&  use base \*(AqRose::DB::Object\*(Aq;
\&
\&  _\|_PACKAGE_\|_\->meta\->setup
\&  (
\&    table => \*(Aqwidget_color_map\*(Aq,
\&
\&    columns =>
\&    [
\&      id        => { type => \*(Aqint\*(Aq, primary_key => 1 },
\&      widget_id => { type => \*(Aqint\*(Aq },
\&      color_id  => { type => \*(Aqint\*(Aq },
\&    ],
\&
\&    foreign_keys =>
\&    [
\&      # Define foreign keys that point to each of the two classes 
\&      # that this class maps between.
\&      color => 
\&      {
\&        class => \*(AqColor\*(Aq,
\&        key_columns => { color_id => \*(Aqid\*(Aq },
\&      },
\&
\&      widget => 
\&      {
\&        class => \*(AqWidget\*(Aq,
\&        key_columns => { widget_id => \*(Aqid\*(Aq },
\&      },
\&    ],
\&  );
\&
\&  1;
.Ve
.PP
Here's an initial set of data and some examples of the above classes in action.  First, the data:
.PP
.Vb 2
\&  INSERT INTO widgets (id, name) VALUES (1, \*(AqSprocket\*(Aq);
\&  INSERT INTO widgets (id, name) VALUES (2, \*(AqFlange\*(Aq);
\&
\&  INSERT INTO colors (id, name) VALUES (1, \*(AqRed\*(Aq);
\&  INSERT INTO colors (id, name) VALUES (2, \*(AqGreen\*(Aq);
\&  INSERT INTO colors (id, name) VALUES (3, \*(AqBlue\*(Aq);
\&
\&  INSERT INTO widget_color_map (widget_id, color_id) VALUES (1, 1);
\&  INSERT INTO widget_color_map (widget_id, color_id) VALUES (1, 2);
\&  INSERT INTO widget_color_map (widget_id, color_id) VALUES (2, 3);
.Ve
.PP
Now the code:
.PP
.Vb 2
\&  use Widget;
\&  use Color;
\&
\&  $widget = Widget\->new(id => 1);
\&  $widget\->load;
\&
\&  @colors = map { $_\->name } $widget\->colors; # (\*(AqRed\*(Aq, \*(AqGreen\*(Aq)
\&
\&  $color = Color\->new(id => 1);
\&  $color\->load;
\&
\&  @widgets = map { $_\->name } $color\->widgets; # (\*(AqSprocket\*(Aq)
.Ve
.SH "METHOD MAP"
.IX Header "METHOD MAP"
.ie n .IP """count""" 4
.el .IP "\f(CWcount\fR" 4
.IX Item "count"
Rose::DB::Object::MakeMethods::Generic, objects_by_map, \f(CW\*(C`interface => \*(Aqcount\*(Aq\*(C'\fR ...
.ie n .IP """find""" 4
.el .IP "\f(CWfind\fR" 4
.IX Item "find"
Rose::DB::Object::MakeMethods::Generic, objects_by_map, \f(CW\*(C`interface => \*(Aqfind\*(Aq\*(C'\fR ...
.ie n .IP """iterator""" 4
.el .IP "\f(CWiterator\fR" 4
.IX Item "iterator"
Rose::DB::Object::MakeMethods::Generic, objects_by_map, \f(CW\*(C`interface => \*(Aqiterator\*(Aq\*(C'\fR ...
.ie n .IP """get_set""" 4
.el .IP "\f(CWget_set\fR" 4
.IX Item "get_set"
Rose::DB::Object::MakeMethods::Generic, objects_by_map, 
\&\f(CW\*(C`interface => \*(Aqget_set\*(Aq\*(C'\fR ...
.ie n .IP """get_set_now""" 4
.el .IP "\f(CWget_set_now\fR" 4
.IX Item "get_set_now"
Rose::DB::Object::MakeMethods::Generic, objects_by_map, \f(CW\*(C`interface => \*(Aqget_set_now\*(Aq\*(C'\fR ...
.ie n .IP """get_set_on_save""" 4
.el .IP "\f(CWget_set_on_save\fR" 4
.IX Item "get_set_on_save"
Rose::DB::Object::MakeMethods::Generic, objects_by_map, \f(CW\*(C`interface => \*(Aqget_set_on_save\*(Aq\*(C'\fR ...
.ie n .IP """add_now""" 4
.el .IP "\f(CWadd_now\fR" 4
.IX Item "add_now"
Rose::DB::Object::MakeMethods::Generic, objects_by_map, \f(CW\*(C`interface => \*(Aqadd_now\*(Aq\*(C'\fR ...
.ie n .IP """add_on_save""" 4
.el .IP "\f(CWadd_on_save\fR" 4
.IX Item "add_on_save"
Rose::DB::Object::MakeMethods::Generic, objects_by_map, \f(CW\*(C`interface => \*(Aqadd_on_save\*(Aq\*(C'\fR ...
.PP
See the Rose::DB::Object::Metadata::Relationship documentation for an explanation of this method map.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.IP "\fBdefault_auto_method_types [\s-1TYPES\s0]\fR" 4
.IX Item "default_auto_method_types [TYPES]"
Get or set the default list of auto_method_types.   \s-1TYPES\s0 should be a list of relationship method types.  Returns the list of default relationship method types (in list context) or a reference to an array of the default relationship method types (in scalar context).  The default list contains  \*(L"get_set_on_save\*(R" and \*(L"add_on_save\*(R".
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.IP "\fBbuild_method_name_for_type \s-1TYPE\s0\fR" 4
.IX Item "build_method_name_for_type TYPE"
Return a method name for the relationship method type \s-1TYPE\s0.
.Sp
For the method types \*(L"get_set\*(R", \*(L"get_set_now\*(R", and \*(L"get_set_on_save\*(R", the relationship's name is returned.
.Sp
For the method types \*(L"add_now\*(R" and \*(L"add_on_save\*(R", the relationship's  name prefixed with \*(L"add_\*(R" is returned.
.Sp
For the method type \*(L"find\*(R", the relationship's name prefixed with \*(L"find_\*(R" is returned.
.Sp
For the method type \*(L"count\*(R", the relationship's name suffixed with \*(L"_count\*(R" is returned.
.Sp
For the method type \*(L"iterator\*(R", the relationship's name suffixed with \*(L"_iterator\*(R" is returned.
.Sp
Otherwise, undef is returned.
.IP "\fBis_singular\fR" 4
.IX Item "is_singular"
Returns false.
.IP "\fBmanager_class [\s-1CLASS\s0]\fR" 4
.IX Item "manager_class [CLASS]"
Get or set the name of the Rose::DB::Object::Manager\-derived class that the map_class will use to fetch records.  The make_methods method will use Rose::DB::Object::Manager if this value is left undefined.
.IP "\fBmanager_method [\s-1METHOD\s0]\fR" 4
.IX Item "manager_method [METHOD]"
Get or set the name of the manager_class class method to call when fetching records.  The make_methods method will use get_objects if this value is left undefined.
.IP "\fBmanager_count_method [\s-1METHOD\s0]\fR" 4
.IX Item "manager_count_method [METHOD]"
Get or set the name of the manager_class class method to call when counting objects.  The make_methods method will use get_objects_count if this value is left undefined.
.IP "\fBmanager_iterator_method [\s-1METHOD\s0]\fR" 4
.IX Item "manager_iterator_method [METHOD]"
Get or set the name of the manager_class class method to call when creating an iterator.  The make_methods method will use get_objects_iterator if this value is left undefined.
.IP "\fBmanager_args [\s-1HASHREF\s0]\fR" 4
.IX Item "manager_args [HASHREF]"
Get or set a reference to a hash of name/value arguments to pass to the manager_method when fetching objects.  For example, this can be used to enforce a particular sort order for objects fetched via this relationship.  Modifying the example above:
.Sp
.Vb 9
\&  Widget\->meta\->add_relationship
\&  (
\&    colors =>
\&    {
\&      type         => \*(Aqmany to many\*(Aq,
\&      map_class    => \*(AqWidgetColorMap\*(Aq,
\&      manager_args => { sort_by => Color\->meta\->table . \*(Aq.name\*(Aq },
\&    },
\&  );
.Ve
.Sp
This would ensure that a \f(CW\*(C`Widget\*(C'\fR's \f(CW\*(C`colors()\*(C'\fR are listed in alphabetical order.  Note that the \*(L"name\*(R" column is prefixed by the name of the table fronted by the \f(CW\*(C`Color\*(C'\fR class.  This is important because several tables may have a column named \*(L"name.\*(R"  If this relationship is used to form a \s-1JOIN\s0 in a query along with one of those tables, then the \*(L"name\*(R" column will be ambiguous.  Adding a table name prefix disambiguates the column name.
.Sp
Also note that the table name is not hard-coded.  Instead, it is fetched from the Rose::DB::Object\-derived class that fronts the table.  This is more verbose, but is a much better choice than including the literal table name when it comes to long-term maintenance of the code.
.Sp
See the documentation for Rose::DB::Object::Manager's get_objects method for a full list of valid arguments for use with the \f(CW\*(C`manager_args\*(C'\fR parameter, but remember that you can define your own custom manager_class and thus can also define what kinds of arguments \f(CW\*(C`manager_args\*(C'\fR will accept.
.Sp
\&\fBNote:\fR when the name of a relationship that has \f(CW\*(C`manager_args\*(C'\fR is used in a Rose::DB::Object::Manager with_objects or require_objects parameter value, \fIonly\fR the sort_by argument will be copied from \f(CW\*(C`manager_args\*(C'\fR and incorporated into the query.
.IP "\fBmap_class [\s-1CLASS\s0]\fR" 4
.IX Item "map_class [CLASS]"
Get or set the name of the Rose::DB::Object\-derived class that fronts the table that maps between the other two tables.  This class must have a foreign key and/or \*(L"many to one\*(R" relationship for each of the two tables that it maps between.
.Sp
In the example above, the map class is \f(CW\*(C`WidgetColorMap\*(C'\fR.
.IP "\fBmap_from [\s-1NAME\s0]\fR" 4
.IX Item "map_from [NAME]"
Get or set the name of the \*(L"many to one\*(R" relationship or foreign key in map_class that points to the object of the current class.  Setting this value is only necessary if the map class has more than one foreign key or \*(L"many to one\*(R" relationship that points to one of the classes that it maps between.
.Sp
In the example above, the value of map_from would be \*(L"widget\*(R" when defining the \*(L"many to many\*(R" relationship in the \f(CW\*(C`Widget\*(C'\fR class, or \*(L"color\*(R" when defining the \*(L"many to many\*(R" relationship in the \f(CW\*(C`Color\*(C'\fR class.  Neither of these settings is necessary in the example because the \f(CW\*(C`WidgetColorMap\*(C'\fR class has one foreign key that points to each class, so there is no ambiguity.
.IP "\fBmap_to [\s-1NAME\s0]\fR" 4
.IX Item "map_to [NAME]"
Get or set the name of the \*(L"many to one\*(R" relationship or foreign key in map_class that points to the \*(L"foreign\*(R" object to be fetched.  Setting this value is only necessary if the map class has more than one foreign key or \*(L"many to one\*(R" relationship that points to one of the classes that it maps between.
.Sp
In the example above, the value of map_from would be \*(L"color\*(R" when defining the \*(L"many to many\*(R" relationship in the \f(CW\*(C`Widget\*(C'\fR class, or \*(L"widget\*(R" when defining the \*(L"many to many\*(R" relationship in the \f(CW\*(C`Color\*(C'\fR class.  Neither of these settings is necessary in the example because the \f(CW\*(C`WidgetColorMap\*(C'\fR class has one foreign key that points to each class, so there is no ambiguity.
.IP "\fBquery_args [\s-1ARRAYREF\s0]\fR" 4
.IX Item "query_args [ARRAYREF]"
Get or set a reference to an array of query arguments to add to the query passed to the manager_method when fetching objects.
.Sp
This can be used to limit the objects fetched via this relationship.  For example, modifying the example above:
.Sp
.Vb 9
\&  Widget\->meta\->add_relationship
\&  (
\&    colors =>
\&    {
\&      type       => \*(Aqmany to many\*(Aq,
\&      map_class  => \*(AqWidgetColorMap\*(Aq,
\&      query_args => [ name => { like => \*(Aq%e%\*(Aq } ],
\&    },
\&  );
.Ve
.Sp
See the documentation for Rose::DB::Object::Manager's get_objects method for a full list of valid \f(CW\*(C`query\*(C'\fR arguments.
.IP "\fBshare_db [\s-1BOOL\s0]\fR" 4
.IX Item "share_db [BOOL]"
Get or set a boolean flag that indicates whether or not all of the classes involved in fetching objects via this relationship (including the objects themselves) will share the same Rose::DB\-derived db object.  Defaults to true.
.IP "\fBtype\fR" 4
.IX Item "type"
Returns \*(L"many to many\*(R".
.SH "AUTHOR"
.IX Header "AUTHOR"
John C. Siracusa (siracusa@gmail.com)
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2010 by John C. Siracusa.  All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same terms
as Perl itself.
