.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.19)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Rose::DB::Object::Manager 3"
.TH Rose::DB::Object::Manager 3 "2012-01-19" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Rose::DB::Object::Manager \- Fetch multiple Rose::DB::Object\-derived objects from the database using complex queries.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  ##
\&  ## Given the following Rose::DB::Object\-derived classes...
\&  ##
\&
\&  package Category;
\&
\&  use base \*(AqRose::DB::Object\*(Aq;
\&
\&  _\|_PACKAGE_\|_\->meta\->setup
\&  (
\&    table   => \*(Aqcategories\*(Aq,
\&    columns =>
\&    [
\&      id          => { type => \*(Aqint\*(Aq, primary_key => 1 },
\&      name        => { type => \*(Aqvarchar\*(Aq, length => 255 },
\&      description => { type => \*(Aqtext\*(Aq },
\&    ],
\&
\&    unique_key => \*(Aqname\*(Aq,
\&  );
\&
\&  ...
\&
\&  package CodeName;
\&
\&  use base \*(AqRose::DB::Object\*(Aq;
\&
\&  _\|_PACKAGE_\|_\->meta\->setup
\&  (
\&    table   => \*(Aqcode_names\*(Aq,
\&    columns =>
\&    [
\&      id          => { type => \*(Aqint\*(Aq, primary_key => 1 },
\&      product_id  => { type => \*(Aqint\*(Aq },
\&      name        => { type => \*(Aqvarchar\*(Aq, length => 255 },
\&      applied     => { type => \*(Aqdate\*(Aq, not_null => 1 },
\&    ],
\&
\&    foreign_keys =>
\&    [
\&      product =>
\&      {
\&        class       => \*(AqProduct\*(Aq,
\&        key_columns => { product_id => \*(Aqid\*(Aq },
\&      },
\&    ],
\&  );
\&
\&  ...
\&
\&  package Product;
\&
\&  use base \*(AqRose::DB::Object\*(Aq;
\&
\&  _\|_PACKAGE_\|_\->meta\->setup
\&  (
\&    table   => \*(Aqproducts\*(Aq,
\&    columns =>
\&    [
\&      id          => { type => \*(Aqint\*(Aq, primary_key => 1 },
\&      name        => { type => \*(Aqvarchar\*(Aq, length => 255 },
\&      description => { type => \*(Aqtext\*(Aq },
\&      category_id => { type => \*(Aqint\*(Aq },
\&      region_num  => { type => \*(Aqint\*(Aq },
\&
\&      status => 
\&      {
\&        type      => \*(Aqvarchar\*(Aq, 
\&        check_in  => [ \*(Aqactive\*(Aq, \*(Aqinactive\*(Aq ],
\&        default   => \*(Aqinactive\*(Aq,
\&      },
\&
\&      start_date  => { type => \*(Aqdatetime\*(Aq },
\&      end_date    => { type => \*(Aqdatetime\*(Aq },
\&
\&      date_created  => { type => \*(Aqtimestamp\*(Aq, default => \*(Aqnow\*(Aq },  
\&      last_modified => { type => \*(Aqtimestamp\*(Aq, default => \*(Aqnow\*(Aq },
\&    ],
\&
\&    unique_key => \*(Aqname\*(Aq,
\&
\&    foreign_keys =>
\&    [
\&      category =>
\&      {
\&        class       => \*(AqCategory\*(Aq,
\&        key_columns =>
\&        {
\&          category_id => \*(Aqid\*(Aq,
\&        }
\&      },
\&    ],
\&
\&    relationships =>
\&    [
\&      code_names =>
\&      {
\&        type  => \*(Aqone to many\*(Aq,
\&        class => \*(AqCodeName\*(Aq,
\&        column_map   => { id => \*(Aqproduct_id\*(Aq },
\&        manager_args => 
\&        {
\&          sort_by => CodeName\->meta\->table . \*(Aq.applied DESC\*(Aq,
\&        },
\&      },
\&    ],
\&  );
\&
\&  ...
\&
\&  ##
\&  ## Create a manager class
\&  ##
\&
\&  package Product::Manager;
\&
\&  use base \*(AqRose::DB::Object::Manager\*(Aq;
\&
\&  sub object_class { \*(AqProduct\*(Aq }
\&
\&  _\|_PACKAGE_\|_\->make_manager_methods(\*(Aqproducts\*(Aq);
\&
\&  # The call above creates the methods shown below.  (The actual 
\&  # method bodies vary slightly, but this is the gist of it...)
\&  #
\&  # sub get_products
\&  # {
\&  #   shift\->get_objects(@_, object_class => \*(AqProduct\*(Aq);
\&  # }
\&  #
\&  # sub get_products_iterator
\&  # {
\&  #   shift\->get_objects_iterator(@_, object_class => \*(AqProduct\*(Aq);
\&  # }
\&  #
\&  # sub get_products_count
\&  # {
\&  #   shift\->get_objects_count(@_, object_class => \*(AqProduct\*(Aq);
\&  # }
\&  #
\&  # sub update_products
\&  # {
\&  #   shift\->update_objects(@_, object_class => \*(AqProduct\*(Aq);
\&  # }
\&  #
\&  # sub delete_products
\&  # {
\&  #   shift\->delete_objects(@_, object_class => \*(AqProduct\*(Aq);
\&  # }
\&
\&  ...
\&
\&  ##
\&  ## Use the manager class
\&  ##
\&
\&  #
\&  # Get a reference to an array of objects
\&  #
\&
\&  $products = 
\&    Product::Manager\->get_products
\&    (
\&      query =>
\&      [
\&        category_id => [ 5, 7, 22 ],
\&        status      => \*(Aqactive\*(Aq,
\&        start_date  => { lt => \*(Aq15/12/2005 6:30 p.m.\*(Aq },
\&        name        => { like => [ \*(Aq%foo%\*(Aq, \*(Aq%bar%\*(Aq ] },
\&      ],
\&      sort_by => \*(Aqcategory_id, start_date DESC\*(Aq,
\&      limit   => 100,
\&      offset  => 80,
\&    );
\&
\&  foreach my $product (@$products)
\&  {
\&    print $product\->id, \*(Aq \*(Aq, $product\->name, "\en";
\&  }
\&
\&  #
\&  # Get objects iterator
\&  #
\&
\&  $iterator = 
\&    Product::Manager\->get_products_iterator
\&    (
\&      query =>
\&      [
\&        category_id => [ 5, 7, 22 ],
\&        status      => \*(Aqactive\*(Aq,
\&        start_date  => { lt => \*(Aq15/12/2005 6:30 p.m.\*(Aq },
\&        name        => { like => [ \*(Aq%foo%\*(Aq, \*(Aq%bar%\*(Aq ] },
\&      ],
\&      sort_by => \*(Aqcategory_id, start_date DESC\*(Aq,
\&      limit   => 100,
\&      offset  => 80,
\&    );
\&
\&  while($product = $iterator\->next)
\&  {
\&    print $product\->id, \*(Aq \*(Aq, $product\->name, "\en";
\&  }
\&
\&  print $iterator\->total;
\&
\&  #
\&  # Get objects count
\&  #
\&
\&  $count =
\&    Product::Manager\->get_products_count
\&    (
\&      query =>
\&      [
\&        category_id => [ 5, 7, 22 ],
\&        status      => \*(Aqactive\*(Aq,
\&        start_date  => { lt => \*(Aq15/12/2005 6:30 p.m.\*(Aq },
\&        name        => { like => [ \*(Aq%foo%\*(Aq, \*(Aq%bar%\*(Aq ] },
\&      ],
\&    ); 
\&
\&   die Product::Manager\->error  unless(defined $count);
\&
\&  print $count; # or Product::Manager\->total()
\&
\&  #
\&  # Get objects and sub\-objects in a single query
\&  #
\&
\&  $products = 
\&    Product::Manager\->get_products
\&    (
\&      with_objects => [ \*(Aqcategory\*(Aq, \*(Aqcode_names\*(Aq ],
\&      query =>
\&      [
\&        category_id => [ 5, 7, 22 ],
\&        status      => \*(Aqactive\*(Aq,
\&        start_date  => { lt => \*(Aq15/12/2005 6:30 p.m.\*(Aq },
\&
\&        # We need to disambiguate the "name" column below since it
\&        # appears in more than one table referenced by this query. 
\&        # When more than one table is queried, the tables have numbered
\&        # aliases starting from the "main" table ("products").  The
\&        # "products" table is t1, "categories" is t2, and "code_names"
\&        # is t3.  You can read more about automatic table aliasing in
\&        # the documentation for the get_objects() method below.
\&        #
\&        # "category.name" and "categories.name" would work too, since
\&        # table and relationship names are also valid prefixes.
\&
\&        \*(Aqt2.name\*(Aq   => { like => [ \*(Aq%foo%\*(Aq, \*(Aq%bar%\*(Aq ] },
\&      ],
\&      sort_by => \*(Aqcategory_id, start_date DESC\*(Aq,
\&      limit   => 100,
\&      offset  => 80,
\&    );
\&
\&  foreach my $product (@$products)
\&  {
\&    # The call to $product\->category does not hit the database
\&    print $product\->name, \*(Aq: \*(Aq, $product\->category\->name, "\en";
\&
\&    # The call to $product\->code_names does not hit the database
\&    foreach my $code_name ($product\->code_names)
\&    {
\&      # This call doesn\*(Aqt hit the database either
\&      print $code_name\->name, "\en";
\&    }
\&  }
\&
\&  #
\&  # Update objects
\&  #
\&
\&  $num_rows_updated =
\&    Product::Manager\->update_products(
\&      set =>
\&      {
\&        end_date   => DateTime\->now,
\&        region_num => { sql => \*(Aqregion_num * \-1\*(Aq }
\&        status     => \*(Aqdefunct\*(Aq,
\&      },
\&      where =>
\&      [
\&        start_date => { lt => \*(Aq1/1/1980\*(Aq },
\&        status     => [ \*(Aqactive\*(Aq, \*(Aqpending\*(Aq ],
\&      ]);
\&
\&  #
\&  # Delete objects
\&  #
\&
\&  $num_rows_deleted =
\&    Product::Manager\->delete_products(
\&      where =>
\&      [
\&        status  => [ \*(Aqstale\*(Aq, \*(Aqold\*(Aq ],
\&        name    => { like => \*(AqWax%\*(Aq },
\&        or =>
\&        [
\&          start_date => { gt => \*(Aq2008\-12\-30\*(Aq },
\&          end_date   => { gt => \*(Aqnow\*(Aq },
\&        ],
\&      ]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Rose::DB::Object::Manager is a base class for classes that select rows from tables fronted by Rose::DB::Object\-derived classes.  Each row in the table(s) queried is converted into the equivalent Rose::DB::Object\-derived object.
.PP
Class methods are provided for fetching objects all at once, one at a time through the use of an iterator, or just getting the object count.  Subclasses are expected to create syntactically pleasing wrappers for Rose::DB::Object::Manager class methods, either manually or with the make_manager_methods method.  A very minimal example is shown in the synopsis above.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.IP "\fBdbi_prepare_cached [\s-1BOOL\s0]\fR" 4
.IX Item "dbi_prepare_cached [BOOL]"
Get or set a boolean value that indicates whether or not this class will use \s-1DBI\s0's prepare_cached method by default (instead of the prepare method) when preparing \s-1SQL\s0 queries.  The default value is false.
.IP "\fBdefault_limit_with_subselect [\s-1BOOL\s0]\fR" 4
.IX Item "default_limit_with_subselect [BOOL]"
Get or set a boolean value that determines whether or not this class will consider using a sub-query to express \f(CW\*(C`limit\*(C'\fR/\f(CW\*(C`offset\*(C'\fR constraints when fetching sub-objects related through one of the \*(L"...\-to\-many\*(R" relationship types.  Not all databases support this syntax, and not all queries can use it even in supported databases.  If this parameter is true, the feature will be used when possible, by default.  The default value is true.
.IP "\fBdefault_manager_method_types [ \s-1LIST\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "default_manager_method_types [ LIST | ARRAYREF ]"
Get or set the default list of method types used by the make_manager_methods method.  The default list is \f(CW\*(C`objects\*(C'\fR, \f(CW\*(C`iterator\*(C'\fR, \f(CW\*(C`count\*(C'\fR, \f(CW\*(C`delete\*(C'\fR, and \f(CW\*(C`update\*(C'\fR.
.IP "\fBdefault_nested_joins [\s-1BOOL\s0]\fR" 4
.IX Item "default_nested_joins [BOOL]"
Get or set a boolean value that determines whether or not this class will consider using nested \s-1JOIN\s0 syntax when fetching related objects.  Not all databases support this syntax, and not all queries can use it even in supported databases.  If this parameter is true, the feature will be used when possible, by default.  The default value is true.
.IP "\fBdefault_objects_per_page [\s-1NUM\s0]\fR" 4
.IX Item "default_objects_per_page [NUM]"
Get or set the default number of items per page, as returned by the get_objects method when used with the \f(CW\*(C`page\*(C'\fR and/or \f(CW\*(C`per_page\*(C'\fR parameters.  The default value is 20.
.IP "\fBdelete_objects [ \s-1PARAMS\s0 | \s-1ARRAYREF\s0 | \s-1HASHREF\s0 ]\fR" 4
.IX Item "delete_objects [ PARAMS | ARRAYREF | HASHREF ]"
Delete rows from a table fronted by a Rose::DB::Object\-derived class based on \s-1PARAMS\s0, where \s-1PARAMS\s0 are name/value pairs.  Returns the number of rows deleted, or undef if there was an error.
.Sp
If the first argument is a reference to a hash or array, it is converted to a reference to an array (if necessary) and taken as the value of the \f(CW\*(C`where\*(C'\fR parameter.
.Sp
Valid parameters are:
.RS 4
.IP "\fBall \s-1BOOL\s0\fR" 4
.IX Item "all BOOL"
If set to a true value, this parameter indicates an explicit request to delete all rows from the table.  If both the \f(CW\*(C`all\*(C'\fR and the \f(CW\*(C`where\*(C'\fR parameters are passed, a fatal error will occur.
.IP "\fBdb \s-1DB\s0\fR" 4
.IX Item "db DB"
A Rose::DB\-derived object used to access the database.  If omitted, one will be created by calling the init_db method of the object_class.
.IP "\fBprepare_cached \s-1BOOL\s0\fR" 4
.IX Item "prepare_cached BOOL"
If true, then \s-1DBI\s0's prepare_cached method will be used (instead of the prepare method) when preparing the \s-1SQL\s0 statement that will delete the objects.  If omitted, the default value is determined by the dbi_prepare_cached class method.
.IP "\fBobject_class \s-1CLASS\s0\fR" 4
.IX Item "object_class CLASS"
The name of the Rose::DB::Object\-derived class that fronts the table from which rows are to be deleted.  This parameter is required; a fatal error will occur if it is omitted.  Defaults to the value returned by the object_class class method.
.IP "\fBwhere \s-1ARRAYREF\s0\fR" 4
.IX Item "where ARRAYREF"
The query parameters, passed as a reference to an array of name/value pairs.  These pairs are used to formulate the \*(L"where\*(R" clause of the \s-1SQL\s0 query that is used to delete the rows from the table.  Arbitrarily nested boolean logic is supported.
.Sp
For the complete list of valid parameter names and values, see the documentation for the \f(CW\*(C`query\*(C'\fR parameter of the build_select function in the Rose::DB::Object::QueryBuilder module.
.Sp
If this parameter is omitted, this method will refuse to delete all rows from the table and a fatal error will occur.  To delete all rows from a table, you must pass the \f(CW\*(C`all\*(C'\fR parameter with a true value.  If both the \f(CW\*(C`all\*(C'\fR and the \f(CW\*(C`where\*(C'\fR parameters are passed, a fatal error will occur.
.RE
.RS 4
.RE
.IP "\fBerror\fR" 4
.IX Item "error"
Returns the text message associated with the last error, or false if there was no error.
.IP "\fBerror_mode [\s-1MODE\s0]\fR" 4
.IX Item "error_mode [MODE]"
Get or set the error mode for this class.  The error mode determines what happens when a method of this class encounters an error.  The default setting is \*(L"fatal\*(R", which means that methods will croak if they encounter an error.
.Sp
\&\fB\s-1PLEASE\s0 \s-1NOTE:\s0\fR The error return values described in the method documentation in the rest of this document are only relevant when the error mode is set to something \*(L"non-fatal.\*(R"  In other words, if an error occurs, you'll never see any of those return values if the selected error mode dies or croaks or otherwise throws an exception when an error occurs.
.Sp
Valid values of \s-1MODE\s0 are:
.RS 4
.IP "carp" 4
.IX Item "carp"
Call Carp::carp with the value of the object error as an argument.
.IP "cluck" 4
.IX Item "cluck"
Call Carp::cluck with the value of the object error as an argument.
.IP "confess" 4
.IX Item "confess"
Call Carp::confess with the value of the object error as an argument.
.IP "croak" 4
.IX Item "croak"
Call Carp::croak with the value of the object error as an argument.
.IP "fatal" 4
.IX Item "fatal"
An alias for the \*(L"croak\*(R" mode.
.IP "return" 4
.IX Item "return"
Return a value that indicates that an error has occurred, as described in the documentation for each method.
.RE
.RS 4
.Sp
In all cases, the class's \f(CW\*(C`error\*(C'\fR attribute will also contain the error message.
.RE
.IP "\fBget_objects [ \s-1PARAMS\s0 | \s-1HASHREF\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "get_objects [ PARAMS | HASHREF | ARRAYREF ]"
Get Rose::DB::Object\-derived objects based on \s-1PARAMS\s0, where \s-1PARAMS\s0 are name/value pairs.  Returns a reference to a (possibly empty) array, or undef if there was an error.
.Sp
If the first argument is a reference to a hash or array, it is converted to a reference to an array (if necessary) and taken as the value of the \f(CW\*(C`query\*(C'\fR parameter.
.Sp
Each table that participates in the query will be aliased.  Each alias is in the form \*(L"tN\*(R" where \*(L"N\*(R" is an ascending number starting with 1.  The tables are numbered as follows.
.RS 4
.IP "\(bu" 4
The primary table is always \*(L"t1\*(R"
.IP "\(bu" 4
The table(s) that correspond to each relationship or foreign key named in the \f(CW\*(C`with_objects\*(C'\fR parameter are numbered in order, starting with \*(L"t2\*(R"
.IP "\(bu" 4
The table(s) that correspond to each relationship or foreign key named in the \f(CW\*(C`require_objects\*(C'\fR parameter are numbered in order, starting where the \f(CW\*(C`with_objects\*(C'\fR table aliases left off.
.RE
.RS 4
.Sp
\&\*(L"Many to many\*(R" relationships have two corresponding tables, and therefore will use two \*(L"tN\*(R" numbers.  All other supported of relationship types only have just one table and will therefore use a single \*(L"tN\*(R" number.
.Sp
For example, imagine that the \f(CW\*(C`Product\*(C'\fR class shown in the synopsis also has a \*(L"many to many\*(R" relationship named \*(L"colors.\*(R"  Now consider this call:
.Sp
.Vb 7
\&    $products = 
\&      Product::Manager\->get_products(
\&        require_objects => [ \*(Aqcategory\*(Aq ],
\&        with_objects    => [ \*(Aqcode_names\*(Aq, \*(Aqcolors\*(Aq ],
\&        multi_many_ok   => 1,
\&        query           => [ status => \*(Aqdefunct\*(Aq ],
\&        sort_by         => \*(Aqt1.name\*(Aq);
.Ve
.Sp
The \*(L"products\*(R" table is \*(L"t1\*(R" since it's the primary table\*(--the table behind the \f(CW\*(C`Product\*(C'\fR class that \f(CW\*(C`Product::Manager\*(C'\fR manages.  Next, the \f(CW\*(C`with_objects\*(C'\fR tables are aliased.  The \*(L"code_names\*(R" table is \*(L"t2\*(R".  Since \*(L"colors\*(R" is a \*(L"many to many\*(R" relationship, it gets two numbers: \*(L"t3\*(R" and \*(L"t4\*(R".  Finally, the \f(CW\*(C`require_objects\*(C'\fR tables are numbered: the table behind the foreign key \*(L"category\*(R" is \*(L"t5\*(R".  Here's an annotated version of the example above:
.Sp
.Vb 10
\&    # Table aliases in the comments
\&    $products = 
\&      Product::Manager\->get_products(
\&                           # t5
\&        require_objects => [ \*(Aqcategory\*(Aq ],
\&                           # t2            t3, t4
\&        with_objects    => [ \*(Aqcode_names\*(Aq, \*(Aqcolors\*(Aq ],
\&        multi_many_ok   => 1,
\&        query           => [ status => \*(Aqdefunct\*(Aq ],
\&        sort_by         => \*(Aqt1.name\*(Aq); # "products" is "t1"
.Ve
.Sp
Also note that the \f(CW\*(C`multi_many_ok\*(C'\fR parameter was used in order to suppress the warning that occurs when more than one \*(L"... to many\*(R" relationship is included in the combination of \f(CW\*(C`require_objects\*(C'\fR and \f(CW\*(C`with_objects\*(C'\fR (\*(L"code_names\*(R" (one to many) and \*(L"colors\*(R" (many to many) in this case).  See the documentation for \f(CW\*(C`multi_many_ok\*(C'\fR below.
.Sp
The \*(L"tN\*(R" table aliases are for convenience, and to isolate end-user code from the actual table names.  Ideally, the actual table names should only exist in one place in the entire code base: in the class definitions for each Rose::DB::OBject\-derived class.
.Sp
That said, when using Rose::DB::Object::Manager, the actual table names can be used as well.  But be aware that some databases don't like a mix of table aliases and real table names in some kinds of queries.
.Sp
Valid parameters to get_objects are:
.IP "\fBallow_empty_lists \s-1BOOL\s0\fR" 4
.IX Item "allow_empty_lists BOOL"
If set to true, \f(CW\*(C`query\*(C'\fR parameters with empty lists as values are allowed.  For example:
.Sp
.Vb 1
\&    @ids = (); # empty list
\&
\&    Product::Manager\->get_products(
\&      query =>
\&      [
\&        id => \e@ids,
\&        ...
\&      ]);
.Ve
.Sp
By default, passing an empty list as a value will cause a fatal error.
.IP "\fBdb \s-1DB\s0\fR" 4
.IX Item "db DB"
A Rose::DB\-derived object used to access the database.  If omitted, one will be created by calling the init_db method of the \f(CW\*(C`object_class\*(C'\fR.
.IP "\fBdebug \s-1BOOL\s0\fR" 4
.IX Item "debug BOOL"
If true, print the generated \s-1SQL\s0 to \s-1STDERR\s0.
.IP "\fBdistinct [ \s-1BOOL\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "distinct [ BOOL | ARRAYREF ]"
If set to any kind of true value, then the \*(L"\s-1DISTINCT\s0\*(R" \s-1SQL\s0 keyword will be added to the \*(L"\s-1SELECT\s0\*(R" statement.  Specific values trigger the behaviors described below.
.Sp
If set to a simple scalar value that is true, then only the columns in the primary table (\*(L"t1\*(R") are fetched from the database.
.Sp
If set to a reference to an array of table names, \*(L"tN\*(R" table aliases, or relationship or foreign key names, then only the columns from the corresponding tables will be fetched.  In the case of relationships that involve more than one table, only the \*(L"most distant\*(R" table is considered.  (e.g., The map table is ignored in a \*(L"many to many\*(R" relationship.)  Columns from the primary table (\*(L"t1\*(R") are always selected, regardless of whether or not it appears in the list.
.Sp
This parameter conflicts with the \f(CW\*(C`fetch_only\*(C'\fR parameter in the case where both provide a list of table names or aliases.  In this case, if the value of the \f(CW\*(C`distinct\*(C'\fR parameter is also reference to an array table names or aliases, then a fatal error will occur.
.IP "\fBfetch_only \s-1ARRAYREF\s0\fR" 4
.IX Item "fetch_only ARRAYREF"
\&\s-1ARRAYREF\s0 should be a reference to an array of table names or \*(L"tN\*(R" table aliases. Only the columns from the corresponding tables will be fetched.  In the case of relationships that involve more than one table, only the \*(L"most distant\*(R" table is considered.  (e.g., The map table is ignored in a \*(L"many to many\*(R" relationship.)  Columns from the primary table (\*(L"t1\*(R") are always selected, regardless of whether or not it appears in the list.
.Sp
This parameter conflicts with the \f(CW\*(C`distinct\*(C'\fR parameter in the case where both provide a list of table names or aliases.  In this case, then a fatal error will occur.
.IP "\fBfor_update \s-1BOOL\s0\fR" 4
.IX Item "for_update BOOL"
If true, this parameter is translated to be the equivalent of passing the lock parameter and setting the \f(CW\*(C`type\*(C'\fR to \f(CW\*(C`for update\*(C'\fR.  For example, this:
.Sp
.Vb 1
\&    for_update => 1
.Ve
.Sp
is equivalent to this:
.Sp
.Vb 1
\&    lock => { type => \*(Aqfor update\*(Aq }
.Ve
.Sp
See the lock parameter below for more information.
.IP "\fBhints \s-1HASHREF\s0\fR" 4
.IX Item "hints HASHREF"
A reference to a hash of hints that influence the \s-1SQL\s0 generated to fetch the objects.  Hints are just \*(L"suggestions\*(R" and may be ignored, depending on the actual features of the database being queried.  Use the debug parameter to see the generated \s-1SQL\s0.  Most of the current hints apply to MySQL only.  See the relevant documentation for more details:
.Sp
<http://dev.mysql.com/doc/refman/5.0/en/select.html>
.Sp
The hints hash is keyed by tN table aliases or relationship names.  The value of each key is a reference to a hash of hint directives.  In the absence of any key for \*(L"t1\*(R" or the name of the primary table, the entire hints hash is considered applicable to the primary table.
.Sp
Valid hint directives are:
.RS 4
.IP "\fBall_rows \s-1BOOL\s0\fR" 4
.IX Item "all_rows BOOL"
If true, direct the database to choose the query plan that returns all the records as quickly as possible.
.IP "\fBbig_result \s-1BOOL\s0\fR" 4
.IX Item "big_result BOOL"
If true, indicate to the database that the result set is expected to be big.
.IP "\fBbuffer_result \s-1BOOL\s0\fR" 4
.IX Item "buffer_result BOOL"
If true, force the result to be put into a temporary table.
.IP "\fBcache \s-1BOOL\s0\fR" 4
.IX Item "cache BOOL"
If true, ask the database to store the result in its query cache.
.IP "\fBcalc_found_rows \s-1BOOL\s0\fR" 4
.IX Item "calc_found_rows BOOL"
If true, ask the database to internally calculate the number of rows found, ignoring any limit or offset arguments.
.IP "\fBcomment \s-1TEXT\s0\fR" 4
.IX Item "comment TEXT"
Add a comment after the \*(L"\s-1SELECT\s0\*(R" keyword in the query.  \s-1TEXT\s0 should \fBnot\fR be surrounded by any comment delimiters.  The appropriate delimiters will be added automatically.
.IP "\fBfirst_rows \s-1BOOL\s0\fR" 4
.IX Item "first_rows BOOL"
If true, direct the database to choose the query plan that returns the first result record as soon as possible.
.IP "\fBforce_index [ \s-1INDEX\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "force_index [ INDEX | ARRAYREF ]"
Force the use of the named indexes, specified by an index name or a reference to an array of index names.
.IP "\fBhigh_priority \s-1BOOL\s0\fR" 4
.IX Item "high_priority BOOL"
If true, give this query higher priority.
.IP "\fBignore_index [ \s-1INDEX\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "ignore_index [ INDEX | ARRAYREF ]"
Ignore the named indexes, specified by an index name or a reference to an array of index names.
.IP "\fBno_cache \s-1BOOL\s0\fR" 4
.IX Item "no_cache BOOL"
If true, ask the database not to store the result in its query cache.
.IP "\fBsmall_result \s-1BOOL\s0\fR" 4
.IX Item "small_result BOOL"
If true, indicate to the database that the result set is expected to be small.
.IP "\fBstraight_join \s-1BOOL\s0\fR" 4
.IX Item "straight_join BOOL"
If true, ask the database to join the tables in the order that they are listed in the \*(L"\s-1FROM\s0\*(R" clause of the \s-1SQL\s0 statement.
.IP "\fBstrict_ops \s-1BOOL\s0\fR" 4
.IX Item "strict_ops BOOL"
If true, any comparison operator used in the \f(CW\*(C`query\*(C'\fR that is not listed in the Rose::DB::Object::QueryBuilder documentation will cause a fatal error.  The default value is determined by the strict_ops class method.
.IP "\fBuse_index [ \s-1INDEX\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "use_index [ INDEX | ARRAYREF ]"
Prefer to use the named indexes, specified by an index name or a reference to an array of index names.
.RE
.RS 4
.RE
.IP "\fBinject_results \s-1BOOL\s0\fR" 4
.IX Item "inject_results BOOL"
If true, then the data returned from the database will be directly \*(L"injected\*(R" into the objects returned by this method, bypassing the constructor and column mutator methods for each object class.  The default is false.  This parameter is ignored (i.e., treated as if it were false) if the \f(CW\*(C`select\*(C'\fR parameter is passed.
.Sp
This parameter is useful for situations where the performance of get_objects is limited by the speed at which Rose::DB::Object\-derived objects can be created.  It's safe to set this parameter to true only if the constructor and column mutator methods for all of the classes involved do not have any side-effects (or if it's is okay to bypass any side-effects).
.Sp
The default Rose::DB::Object constructor and the column mutator methods created by the column classes included in the Rose::DB::Object module distribution do not have any side-effects and should therefore be safe to use with this parameter.
.IP "\fBlimit \s-1NUM\s0\fR" 4
.IX Item "limit NUM"
Return a maximum of \s-1NUM\s0 objects.
.IP "\fBlimit_with_subselect \s-1BOOL\s0\fR" 4
.IX Item "limit_with_subselect BOOL"
This parameter controls whether or not this method will consider using a sub-query to express  \f(CW\*(C`limit\*(C'\fR/\f(CW\*(C`offset\*(C'\fR constraints when fetching sub-objects related through one of the \*(L"...\-to\-many\*(R" relationship types.  Not all databases support this syntax, and not all queries can use it even in supported databases.  If this parameter is true, the feature will be used when possible.
.Sp
The default value is determined by the default_limit_with_subselect class method.
.IP "\fBlock [ \s-1TYPE\s0 | \s-1HASHREF\s0 ]\fR" 4
.IX Item "lock [ TYPE | HASHREF ]"
Select the objects using some form of locking.  These lock directives have database-specific behavior and not all directives are supported by all databases.  Consult your database's documentation to find out more.  Use the debug parameter to see the generated \s-1SQL\s0.
.Sp
The value should be a reference to a hash or a \s-1TYPE\s0 string, which is equivalent to setting the value of the \f(CW\*(C`type\*(C'\fR key in the hash reference form.  For example, these are both equivalent:
.Sp
.Vb 2
\&    lock => \*(Aqfor update\*(Aq
\&    lock => { type => \*(Aqfor update\*(Aq }
.Ve
.Sp
Valid hash keys are:
.RS 4
.IP "\fBcolumns \s-1ARRAYREF\s0\fR" 4
.IX Item "columns ARRAYREF"
A reference to an array of column names to lock.  The columns may be prefixed with their table name or their \f(CW\*(C`tN\*(C'\fR alias (e.g., \f(CW\*(C`mytable.mycol\*(C'\fR or \f(CW\*(C`t2.mycol\*(C'\fR) or left unadorned if they are not ambiguous.  References to scalars will be de-referenced and used as-is, included literally in the \s-1SQL\s0 locking clause.
.IP "\fBnowait \s-1BOOL\s0\fR" 4
.IX Item "nowait BOOL"
If true, do not wait to acquire the lock.  If supported, this is usually by adding a \f(CW\*(C`NOWAIT\*(C'\fR directive to the \s-1SQL\s0.
.IP "\fBon \s-1ARRAYREF\s0\fR" 4
.IX Item "on ARRAYREF"
A reference to an array of items to lock.  Depending on the database, these may be column or tables.  Both column and table names should be specified using dot-separated relationship paths.
.Sp
For example, \f(CW\*(C`vendor.region.name\*(C'\fR would lock the \f(CW\*(C`name\*(C'\fR column in the table arrived at by traversing the \f(CW\*(C`vendor\*(C'\fR and then the \f(CW\*(C`region\*(C'\fR relationships, starting from the primary table (\f(CW\*(C`t1\*(C'\fR).  Lone column names may also be used, provided they're not ambiguous.
.Sp
For locking whole tables, \f(CW\*(C`vendor.region\*(C'\fR would lock the table arrived at by traversing the \f(CW\*(C`vendor\*(C'\fR and then the \f(CW\*(C`region\*(C'\fR relationships.  (See the require_objects parameter for more information on relationship traversal.)
.Sp
Finally, references to scalars will be de-referenced and used as-is, included literally in the \s-1SQL\s0 locking clause.
.IP "\fBskip_locked \s-1BOOL\s0\fR" 4
.IX Item "skip_locked BOOL"
If true, skip any locked rows.  If supported, this is usually by adding a \f(CW\*(C`SKIP LOCKED\*(C'\fR clause to the \s-1SQL\s0.
.IP "\fBtables \s-1ARRAYREF\s0\fR" 4
.IX Item "tables ARRAYREF"
A reference to an array of tables to lock.  Table named or \f(CW\*(C`tN\*(C'\fR aliases may be used.  References to scalars will be de-referenced and used as-is, included literally in the \s-1SQL\s0 locking clause.
.IP "\fBtype \s-1TYPE\s0\fR" 4
.IX Item "type TYPE"
The type of lock to acquire.  Valid values for \s-1TYPE\s0 are \f(CW\*(C`for update\*(C'\fR and \f(CW\*(C`shared\*(C'\fR.  This hash key is required unless the for_update parameter was passed with a true value.
.IP "\fBwait \s-1TIME\s0\fR" 4
.IX Item "wait TIME"
Wait for the specified \s-1TIME\s0 (generally seconds) before giving up acquiring the lock. If supported, this is usually by adding a \f(CW\*(C`WAIT ...\*(C'\fR clause to the \s-1SQL\s0.
.RE
.RS 4
.Sp
You may pass only one of the parameters that specifies \*(L"what to lock\*(R" (i.e., \f(CW\*(C`columns\*(C'\fR, \f(CW\*(C`on\*(C'\fR, or \f(CW\*(C`tables\*(C'\fR).
.RE
.IP "\fBnested_joins \s-1BOOL\s0\fR" 4
.IX Item "nested_joins BOOL"
This parameter controls whether or not this method will consider using nested \s-1JOIN\s0 syntax when fetching related objects.  Not all databases support this syntax, and not all queries will use it even in supported databases.  If this parameter is true, the feature will be used when possible.
.Sp
The default value is determined by the default_nested_joins class method.
.IP "\fBmulti_many_ok \s-1BOOL\s0\fR" 4
.IX Item "multi_many_ok BOOL"
If true, do not print a warning when attempting to do multiple \s-1LEFT\s0 \s-1OUTER\s0 JOINs against tables related by \*(L"... to many\*(R" relationships.  See the documentation for the \f(CW\*(C`with_objects\*(C'\fR parameter for more information.
.IP "\fBnonlazy [ \s-1BOOL\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "nonlazy [ BOOL | ARRAYREF ]"
By default, get_objects will honor all load-on-demand columns when fetching objects.  Use this parameter to override that behavior and select all columns instead.
.Sp
If the value is a true boolean value (typically \*(L"1\*(R"), then all columns will be fetched for all participating classes (i.e., the main object class as well as any sub-object classes).
.Sp
The value can also be a reference to an array of relationship names.  The sub-objects corresponding to each relationship name will have all their columns selected.  To refer to the main class (the \*(L"t1\*(R" table), use the special name \*(L"self\*(R".
.IP "\fBobject_args \s-1HASHREF\s0\fR" 4
.IX Item "object_args HASHREF"
A reference to a hash of name/value pairs to be passed to the constructor of each \f(CW\*(C`object_class\*(C'\fR object fetched, in addition to the values from the database.
.IP "\fBobject_class \s-1CLASS\s0\fR" 4
.IX Item "object_class CLASS"
The name of the Rose::DB::Object\-derived objects to be fetched.  This parameter is required; a fatal error will occur if it is omitted.  Defaults to the value returned by the object_class class method.
.IP "\fBoffset \s-1NUM\s0\fR" 4
.IX Item "offset NUM"
Skip the first \s-1NUM\s0 rows.  If the database supports some sort of \*(L"limit with offset\*(R" syntax (e.g., \*(L"\s-1LIMIT\s0 10 \s-1OFFSET\s0 20\*(R") then it will be used.  Otherwise, the first \s-1NUM\s0 rows will be fetched and then discarded.
.Sp
This parameter can only be used along with the \f(CW\*(C`limit\*(C'\fR parameter, otherwise a fatal error will occur.
.IP "\fBpage \s-1NUM\s0\fR" 4
.IX Item "page NUM"
Show page number \s-1NUM\s0 of objects.  Pages are numbered starting from 1.  A page number less than or equal to zero causes the page number to default to 1.
.Sp
The number of objects per page can be set by the \f(CW\*(C`per_page\*(C'\fR parameter.  If the \f(CW\*(C`per_page\*(C'\fR parameter is supplied and this parameter is omitted, it defaults to 1 (the first page).
.Sp
If this parameter is included along with either of the \f(CW\*(C`limit\*(C'\fR or <offset> parameters, a fatal error will occur.
.IP "\fBper_page \s-1NUM\s0\fR" 4
.IX Item "per_page NUM"
The number of objects per \f(CW\*(C`page\*(C'\fR.   Defaults to the value returned by the default_objects_per_page class method (20, by default).
.Sp
If this parameter is included along with either of the \f(CW\*(C`limit\*(C'\fR or <offset> parameters, a fatal error will occur.
.IP "\fBprepare_cached \s-1BOOL\s0\fR" 4
.IX Item "prepare_cached BOOL"
If true, then \s-1DBI\s0's prepare_cached method will be used (instead of the prepare method) when preparing the \s-1SQL\s0 statement that will fetch the objects.  If omitted, the default value is determined by the dbi_prepare_cached class method.
.IP "\fBquery \s-1ARRAYREF\s0\fR" 4
.IX Item "query ARRAYREF"
The query parameters, passed as a reference to an array of name/value pairs.  These pairs are used to formulate the \*(L"where\*(R" clause of the \s-1SQL\s0 query that, in turn, is used to fetch the objects from the database.  Arbitrarily nested boolean logic is supported.
.Sp
For the complete list of valid parameter names and values, see the documentation for the \f(CW\*(C`query\*(C'\fR parameter of the build_select function in the Rose::DB::Object::QueryBuilder module.
.Sp
This class also supports an extension to the query syntax supported by Rose::DB::Object::QueryBuilder.  In addition to table names and aliases, column (or column method) names may be prefixed with foreign key or relationship names.  These names may be chained, with dots (\*(L".\*(R") separating the components.
.Sp
For example, imagine three tables, \f(CW\*(C`products\*(C'\fR, \f(CW\*(C`vendors\*(C'\fR, and \f(CW\*(C`regions\*(C'\fR, fronted by three Rose::DB::Object\-derived classes, \f(CW\*(C`Product\*(C'\fR, \f(CW\*(C`Vendor\*(C'\fR, and \f(CW\*(C`Region\*(C'\fR, respectively.  Each \f(CW\*(C`Product\*(C'\fR has a \f(CW\*(C`Vendor\*(C'\fR, and each \f(CW\*(C`Vendor\*(C'\fR has a \f(CW\*(C`Region\*(C'\fR.
.Sp
To select only products whose vendors are in the United States, use a query argument like this:
.Sp
.Vb 1
\&    query => [ \*(Aqvendor.region.name\*(Aq => \*(AqUS\*(Aq ],
.Ve
.Sp
This assumes that the \f(CW\*(C`Product\*(C'\fR class has a relationship or foreign key named \*(L"vendor\*(R" that points to the product's \f(CW\*(C`Vendor\*(C'\fR, and that the \f(CW\*(C`Vendor\*(C'\fR class has a foreign key or relationship named \*(L"region\*(R" that points to the vendor's \f(CW\*(C`Region\*(C'\fR, and that 'vendor.region' (or any foreign key or relationship name chain that begins with 'vendor.region.') is an argument to the \f(CW\*(C`with_objects\*(C'\fR or \f(CW\*(C`require_objects\*(C'\fR parameters.
.Sp
Please note that the "tN\*(L" table aliases are not allowed in front of these kinds of chained relationship parameters.  (The chain of relationship names specifies the target table, so any \*(R"tN" alias would be redundant at best, or present a conflict at worst.)
.IP "\fBrequire_objects \s-1ARRAYREF\s0\fR" 4
.IX Item "require_objects ARRAYREF"
Only fetch rows from the primary table that have all of the associated sub-objects listed in \s-1ARRAYREF\s0, a reference to an array of foreign key or relationship names defined for \f(CW\*(C`object_class\*(C'\fR.  The supported relationship types are "one to one,\*(L" \*(R"one to many,\*(L" and  \*(R"many to many".
.Sp
For each foreign key or relationship name listed in \s-1ARRAYREF\s0, another table will be added to the query via an implicit inner join.  The join conditions will be constructed automatically based on the foreign key or relationship definitions.  Note that each related table must have a Rose::DB::Object\-derived class fronting it.
.Sp
Foreign key and relationship names may be chained, with dots (\*(L".\*(R") separating each name.  For example, imagine three tables, \f(CW\*(C`products\*(C'\fR, \f(CW\*(C`vendors\*(C'\fR, and \f(CW\*(C`regions\*(C'\fR, fronted by three Rose::DB::Object\-derived classes, \f(CW\*(C`Product\*(C'\fR, \f(CW\*(C`Vendor\*(C'\fR, and \f(CW\*(C`Region\*(C'\fR, respectively.  Each \f(CW\*(C`Product\*(C'\fR has a \f(CW\*(C`Vendor\*(C'\fR, and each \f(CW\*(C`Vendor\*(C'\fR has a \f(CW\*(C`Region\*(C'\fR.
.Sp
To fetch \f(CW\*(C`Product\*(C'\fRs along with their \f(CW\*(C`Vendor\*(C'\fRs, and their vendors' \f(CW\*(C`Region\*(C'\fRs, provide a \f(CW\*(C`with_objects\*(C'\fR argument like this:
.Sp
.Vb 1
\&    require_objects => [ \*(Aqvendor.region\*(Aq ],
.Ve
.Sp
This assumes that the \f(CW\*(C`Product\*(C'\fR class has a relationship or foreign key named \*(L"vendor\*(R" that points to the product's \f(CW\*(C`Vendor\*(C'\fR, and that the \f(CW\*(C`Vendor\*(C'\fR class has a foreign key or relationship named \*(L"region\*(R" that points to the vendor's \f(CW\*(C`Region\*(C'\fR.
.Sp
This chaining syntax can be used to traverse relationships of any kind, including \*(L"one to many\*(R" and \*(L"many to many\*(R" relationships, to an arbitrary depth.
.Sp
The following optional suffixes may be added after any name in the chain in order to override the join type used:
.Sp
.Vb 4
\&    Suffix    Join Type
\&    \-\-\-\-\-\-    \-\-\-\-\-\-\-\-\-\-
\&    !         Inner join
\&    ?         Left outer join
.Ve
.Sp
Each link in a \f(CW\*(C`require_objects\*(C'\fR chain uses an inner join by default.  In other words, the following \f(CW\*(C`require_objects\*(C'\fR parameters are all equivalent:
.Sp
.Vb 5
\&    # These all mean the same thing
\&    require_objects => [ \*(Aqvendor.region\*(Aq   ]
\&    require_objects => [ \*(Aqvendor!.region!\*(Aq ]
\&    require_objects => [ \*(Aqvendor.region!\*(Aq  ]
\&    require_objects => [ \*(Aqvendor!.region\*(Aq  ]
.Ve
.Sp
Thus, it is only really useful to use the \f(CW\*(C`?\*(C'\fR suffix in \f(CW\*(C`require_objects\*(C'\fR parameters (though the \f(CW\*(C`!\*(C'\fR suffixes don't do any harm).  Here's a useful example of a call with hybrid join chain:
.Sp
.Vb 3
\&    $products =
\&      Product::Manager\->get_products(
\&        require_objects => [ \*(Aqvendor.region?\*(Aq ]);
.Ve
.Sp
All product objects returned would have associated vendor objects, but those vendor objects may or may not have associated region objects.
.Sp
Note that inner joins may be implicit and nested_joins may or may not be used.  When in doubt, use the debug parameter to see the generated \s-1SQL\s0.
.Sp
\&\fBWarning:\fR there may be a geometric explosion of redundant data returned by the database if you include more than one \*(L"... to many\*(R" relationship in \s-1ARRAYREF\s0.  Sometimes this may still be more efficient than making additional queries to fetch these sub-objects, but that all depends on the actual data.  A warning will be emitted (via Carp::cluck) if you you include more than one \*(L"... to many\*(R" relationship in \s-1ARRAYREF\s0.  If you're sure you know what you're doing, you can silence this warning by passing the \f(CW\*(C`multi_many_ok\*(C'\fR parameter with a true value.
.Sp
\&\fBNote:\fR the \f(CW\*(C`require_objects\*(C'\fR list currently cannot be used to simultaneously fetch two objects that both front the same database table, \fIbut are of different classes\fR.  One workaround is to make one class use a synonym or alias for one of the tables.  Another option is to make one table a trivial view of the other.  The objective is to get the table names to be different for each different class (even if it's just a matter of letter case, if your database is not case-sensitive when it comes to table names).
.IP "\fBselect [ \s-1CLAUSE\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "select [ CLAUSE | ARRAYREF ]"
Select only the columns specified in either a comma-separated string of column names or a reference to an array of column names.  Strings are naively split between each comma.  If you need more complex parsing, please use the array-reference argument format instead.
.Sp
Column names should be prefixed by the appropriate \*(L"tN\*(R" table alias, the table name, or the foreign key or relationship name.  The prefix should be joined to the column name with a dot (\*(L".\*(R").  Examples: \f(CW\*(C`t2.name\*(C'\fR, \f(CW\*(C`vendors.age\*(C'\fR.
.Sp
Unprefixed columns are assumed to belong to the primary table (\*(L"t1\*(R") and are explicitly prefixed as such when selecting from more than one table.  If a column name matches \f(CW\*(C`/ AS \ew+$/\*(C'\fR then no prefix is applied.
.Sp
If the column name is \*(L"*\*(R" (e.g., \f(CW\*(C`t1.*\*(C'\fR) then all columns from that table are selected.
.Sp
If an item in the referenced array is itself a reference to a scalar, then that item will be dereferenced and passed through unmodified.
.Sp
If selecting sub-objects via the \f(CW\*(C`with_objects\*(C'\fR or \f(CW\*(C`require_objects\*(C'\fR parameters, you must select the primary key columns from each sub-object table.  Failure to do so will cause those sub-objects \fInot\fR to be created.
.Sp
Be warned that you should provide some way to determine which column or method and which class an item belongs to: a tN prefix, a column name, or at the very least an \*(L"... \s-1AS\s0 ...\*(R" alias clause.
.Sp
If any \f(CW\*(C`with_objects\*(C'\fR or \f(CW\*(C`require_objects\*(C'\fR arguments are included in this call, the \f(CW\*(C`select\*(C'\fR list must include at least the primary key column(s) from each table that contributes to the named relationships.
.Sp
This parameter conflicts with the \f(CW\*(C`fetch_only\*(C'\fR parameter.  A fatal error will occur if both are used in the same call.
.Sp
If this parameter is omitted, then all columns from all participating tables are selected (optionally modified by the \f(CW\*(C`nonlazy\*(C'\fR parameter).
.IP "\fBshare_db \s-1BOOL\s0\fR" 4
.IX Item "share_db BOOL"
If true, \f(CW\*(C`db\*(C'\fR will be passed to each Rose::DB::Object\-derived object when it is constructed.  Defaults to true.
.IP "\fBsort_by [ \s-1CLAUSE\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "sort_by [ CLAUSE | ARRAYREF ]"
A fully formed \s-1SQL\s0 \*(L"\s-1ORDER\s0 \s-1BY\s0 ...\*(R" clause, sans the words \*(L"\s-1ORDER\s0 \s-1BY\s0\*(R", or a reference to an array of strings or scalar references to be de-refrenced as needed, joined with a comma, and appended to the \*(L"\s-1ORDER\s0 \s-1BY\s0\*(R" clause.
.Sp
If an argument is a reference to a scalar, then it is passed through to the \s-1ORDER\s0 \s-1BY\s0 clause unmodified.
.Sp
Otherwise, within each string, any instance of \*(L"\s-1NAME\s0.\*(R" will be replaced with the appropriate \*(L"tN.\*(R" table alias, where \s-1NAME\s0 is a table, foreign key, or relationship name.  All unprefixed simple column names are assumed to belong to the primary table (\*(L"t1\*(R").
.Sp
If selecting sub-objects (via \f(CW\*(C`require_objects\*(C'\fR or \f(CW\*(C`with_objects\*(C'\fR) that are related through \*(L"one to many\*(R" or \*(L"many to many\*(R" relationships, the first condition in the sort order clause must be a column in the primary table (t1).  If this condition is not met, the list of primary key columns will be added to the beginning of the sort order clause automatically.
.IP "\fBtable_aliases \s-1BOOL\s0\fR" 4
.IX Item "table_aliases BOOL"
When only a single table is used in q auery, this parameter controls whether or not the \*(L"tN\*(R" aliases are used.  If the parameter is not passed, then tables are aliased.  If it is passed with a false value, then tables are not aliased.  When more than one table participates in a query, the \*(L"tN\*(R" table aliases are always used and this option is ignored.
.IP "\fBunique_aliases \s-1BOOL\s0\fR" 4
.IX Item "unique_aliases BOOL"
If true, and if there is no explicit value for the \f(CW\*(C`select\*(C'\fR parameter and more than one table is participating in the query, then each selected column will be given a unique alias by prefixing it with its table alias and an underscore.  The default value is false.  Example:
.Sp
.Vb 10
\&    SELECT
\&      t1.id    AS t1_id,
\&      t1.name  AS t1_name,
\&      t2.id    AS t2_id,
\&      t2.name  AS t2_name
\&    FROM
\&      foo AS t1,
\&      bar AS t2
\&    WHERE
\&      ...
.Ve
.Sp
These unique aliases provide a technique of last resort for unambiguously addressing a column in a query clause.
.IP "\fBwhere \s-1ARRAYREF\s0\fR" 4
.IX Item "where ARRAYREF"
This is an alias for the \f(CW\*(C`query\*(C'\fR parameter (see above).
.IP "\fBwith_map_records [ \s-1BOOL\s0 | \s-1METHOD\s0 | \s-1HASHREF\s0 ]\fR" 4
.IX Item "with_map_records [ BOOL | METHOD | HASHREF ]"
When fetching related objects through a "many to many" relationship, objects of the map class are not retrieved by default.  Use this parameter to override the default behavior.
.Sp
If the value is \*(L"1\*(R", then each object fetched through a mapping table will have its associated map record available through a \f(CW\*(C`map_record()\*(C'\fR attribute.
.Sp
If a method name is provided instead, then each object fetched through a mapping table will have its associated map record available through a method of that name.
.Sp
If the value is a reference to a hash, then the keys of the hash should be \*(L"many to many\*(R" relationship names, and the values should be the method names through which the maps records will be available for each relationship.
.IP "\fBwith_objects \s-1ARRAYREF\s0\fR" 4
.IX Item "with_objects ARRAYREF"
Also fetch sub-objects (if any) associated with rows in the primary table based on a reference to an array of foreign key or relationship names defined for \f(CW\*(C`object_class\*(C'\fR.  The supported relationship types are "one to one,\*(L" \*(R"one to many,\*(L" and  \*(R"many to many".
.Sp
For each foreign key or relationship name listed in \s-1ARRAYREF\s0, another table will be added to the query via an explicit \s-1LEFT\s0 \s-1OUTER\s0 \s-1JOIN\s0.  (Foreign keys whose columns are all \s-1NOT\s0 \s-1NULL\s0 are the exception, however.  They are always fetched via inner joins.)   The join conditions will be constructed automatically based on the foreign key or relationship definitions.  Note that each related table must have a Rose::DB::Object\-derived class fronting it.  See the synopsis for an example.
.Sp
\&\*(L"Many to many\*(R" relationships are a special case.  They will add two tables to the query (the \*(L"map\*(R" table plus the table with the actual data), which will offset the \*(L"tN\*(R" table numbering by one extra table.
.Sp
Foreign key and relationship names may be chained, with dots (\*(L".\*(R") separating each name.  For example, imagine three tables, \f(CW\*(C`products\*(C'\fR, \f(CW\*(C`vendors\*(C'\fR, and \f(CW\*(C`regions\*(C'\fR, fronted by three Rose::DB::Object\-derived classes, \f(CW\*(C`Product\*(C'\fR, \f(CW\*(C`Vendor\*(C'\fR, and \f(CW\*(C`Region\*(C'\fR, respectively.  Each \f(CW\*(C`Product\*(C'\fR has a \f(CW\*(C`Vendor\*(C'\fR, and each \f(CW\*(C`Vendor\*(C'\fR has a \f(CW\*(C`Region\*(C'\fR.
.Sp
To fetch \f(CW\*(C`Product\*(C'\fRs along with their \f(CW\*(C`Vendor\*(C'\fRs, and their vendors' \f(CW\*(C`Region\*(C'\fRs, provide a \f(CW\*(C`with_objects\*(C'\fR argument like this:
.Sp
.Vb 1
\&    with_objects => [ \*(Aqvendor.region\*(Aq ],
.Ve
.Sp
This assumes that the \f(CW\*(C`Product\*(C'\fR class has a relationship or foreign key named \*(L"vendor\*(R" that points to the product's \f(CW\*(C`Vendor\*(C'\fR, and that the \f(CW\*(C`Vendor\*(C'\fR class has a foreign key or relationship named \*(L"region\*(R" that points to the vendor's \f(CW\*(C`Region\*(C'\fR.
.Sp
This chaining syntax can be used to traverse relationships of any kind, including \*(L"one to many\*(R" and \*(L"many to many\*(R" relationships, to an arbitrary depth.
.Sp
The following optional suffixes may be added after any name in the chain in order to override the join type used:
.Sp
.Vb 4
\&    Suffix    Join Type
\&    \-\-\-\-\-\-    \-\-\-\-\-\-\-\-\-\-
\&    !         Inner join
\&    ?         Left outer join
.Ve
.Sp
Each link in a \f(CW\*(C`with_objects\*(C'\fR chain uses a left outer join by default.  In other words, the following \f(CW\*(C`with_objects\*(C'\fR parameters are all equivalent:
.Sp
.Vb 5
\&    # These all mean the same thing
\&    with_objects => [ \*(Aqvendor.region\*(Aq   ]
\&    with_objects => [ \*(Aqvendor?.region?\*(Aq ]
\&    with_objects => [ \*(Aqvendor.region?\*(Aq  ]
\&    with_objects => [ \*(Aqvendor?.region\*(Aq  ]
.Ve
.Sp
Thus, it is only really useful to use the \f(CW\*(C`!\*(C'\fR suffix in \f(CW\*(C`with_objects\*(C'\fR parameters (though the \f(CW\*(C`?\*(C'\fR suffixes don't do any harm).  Here's a useful example of a call with hybrid join chain:
.Sp
.Vb 3
\&    $products =
\&      Product::Manager\->get_products(
\&        with_objects => [ \*(Aqvendor!.region\*(Aq ]);
.Ve
.Sp
All product objects returned would have associated vendor objects, but those vendor object may or may not have associated region objects.
.Sp
Note that inner joins may be implicit and nested_joins may or may not be used.  When in doubt, use the debug parameter to see the generated \s-1SQL\s0.
.Sp
\&\fBWarning:\fR there may be a geometric explosion of redundant data returned by the database if you include more than one \*(L"... to many\*(R" relationship in \s-1ARRAYREF\s0.  Sometimes this may still be more efficient than making additional queries to fetch these sub-objects, but that all depends on the actual data.  A warning will be emitted (via Carp::cluck) if you you include more than one \*(L"... to many\*(R" relationship in \s-1ARRAYREF\s0.  If you're sure you know what you're doing, you can silence this warning by passing the \f(CW\*(C`multi_many_ok\*(C'\fR parameter with a true value.
.Sp
\&\fBNote:\fR the \f(CW\*(C`with_objects\*(C'\fR list currently cannot be used to simultaneously fetch two objects that both front the same database table, \fIbut are of different classes\fR.  One workaround is to make one class use a synonym or alias for one of the tables.  Another option is to make one table a trivial view of the other.  The objective is to get the table names to be different for each different class (even if it's just a matter of letter case, if your database is not case-sensitive when it comes to table names).
.RE
.RS 4
.RE
.IP "\fBget_objects_count [\s-1PARAMS\s0]\fR" 4
.IX Item "get_objects_count [PARAMS]"
Accepts the same arguments as get_objects, but just returns the number of objects that would have been fetched, or undef if there was an error.
.IP "\fBget_objects_from_sql [ \s-1SQL\s0 | \s-1PARAMS\s0 ]\fR" 4
.IX Item "get_objects_from_sql [ SQL | PARAMS ]"
Fetch objects using a custom \s-1SQL\s0 query.  Pass either a single \s-1SQL\s0 query string or name/value parameters as arguments.  Valid parameters are:
.RS 4
.IP "\fBargs \s-1ARRAYREF\s0\fR" 4
.IX Item "args ARRAYREF"
A reference to an array of arguments to be passed to \s-1DBI\s0's execute method when the query is run.  The number of items in this array must exactly match the number of placeholders in the \s-1SQL\s0 query.
.IP "\fBdb \s-1DB\s0\fR" 4
.IX Item "db DB"
A Rose::DB\-derived object used to access the database.  If omitted, one will be created by calling the init_db method of the \f(CW\*(C`object_class\*(C'\fR.
.IP "\fBobject_class \s-1CLASS\s0\fR" 4
.IX Item "object_class CLASS"
The class name of the Rose::DB::Object\-derived objects to be fetched.  Defaults to the value returned by the object_class class method.
.IP "\fBprepare_cached \s-1BOOL\s0\fR" 4
.IX Item "prepare_cached BOOL"
If true, then \s-1DBI\s0's prepare_cached method will be used (instead of the prepare method) when preparing the \s-1SQL\s0 statement that will fetch the objects.  If omitted, the default value is determined by the dbi_prepare_cached class method.
.IP "\fBshare_db \s-1BOOL\s0\fR" 4
.IX Item "share_db BOOL"
If true, \f(CW\*(C`db\*(C'\fR will be passed to each Rose::DB::Object\-derived object when it is constructed.  Defaults to true.
.IP "\fBsql \s-1SQL\s0\fR" 4
.IX Item "sql SQL"
The \s-1SQL\s0 query string.  This parameter is required.
.RE
.RS 4
.Sp
Each column returned by the \s-1SQL\s0 query must be either a column or method name in \f(CW\*(C`object_class\*(C'\fR.  Column names take precedence in the case of a conflict.
.Sp
Returns a reference to an array of \f(CW\*(C`object_class\*(C'\fR objects.
.Sp
Examples:
.Sp
.Vb 5
\&    package Product::Manager;    
\&    use Product;
\&    use base \*(AqRose::DB::Object::Manager\*(Aq;
\&    sub object_class { \*(AqProduct\*(Aq }
\&    ...
\&
\&    $products = Product::Manager\->get_objects_from_sql(<<"EOF");
\&    SELECT * FROM products WHERE sku % 2 != 0 ORDER BY status, type
\&    EOF
\&
\&    $products = 
\&      Product::Manager\->get_objects_from_sql(
\&        args => [ \*(Aq2005\-01\-01\*(Aq ],
\&        sql  => \*(AqSELECT * FROM products WHERE release_date > ?\*(Aq);
.Ve
.RE
.IP "\fBget_objects_iterator [\s-1PARAMS\s0]\fR" 4
.IX Item "get_objects_iterator [PARAMS]"
Accepts any valid get_objects arguments, but return a Rose::DB::Object::Iterator object, or undef if there was an error.
.IP "\fBget_objects_iterator_from_sql [\s-1PARAMS\s0]\fR" 4
.IX Item "get_objects_iterator_from_sql [PARAMS]"
Accepts any valid get_objects_from_sql arguments, but return a Rose::DB::Object::Iterator object, or undef if there was an error.
.IP "\fBget_objects_sql [\s-1PARAMS\s0]\fR" 4
.IX Item "get_objects_sql [PARAMS]"
Accepts the same arguments as get_objects, but return the \s-1SQL\s0 query string that would have been used to fetch the objects (in scalar context), or the \s-1SQL\s0 query string and a reference to an array of bind values (in list context).
.IP "\fBmake_manager_methods \s-1PARAMS\s0\fR" 4
.IX Item "make_manager_methods PARAMS"
Create convenience wrappers for Rose::DB::Object::Manager's get_objects, get_objects_iterator, and get_objects_count class methods in the target class.  These wrapper methods will not overwrite any existing methods in the target class.  If there is an existing method with the same name, a fatal error will occur.
.Sp
\&\s-1PARAMS\s0 can take several forms, depending on the calling context.  For a call to make_manager_methods to succeed, the following information must be determined:
.RS 4
.IP "\(bu" 4
\&\fBobject class\fR
.Sp
The class of the Rose::DB::Object\-derived objects to be fetched or counted.
.IP "\(bu" 4
\&\fBbase name\fR or \fBmethod name\fR
.Sp
The base name is a string used as the basis of the method names.  For example, the base name \*(L"products\*(R" might be used to create methods named "get_\fBproducts\fR\*(L", \*(R"get_\fBproducts\fR_count\*(L", \*(R"get_\fBproducts\fR_iterator\*(L", \*(R"delete_\fBproducts\fR\*(L", and \*(R"update_\fBproducts\fR".
.Sp
In the absence of a base name, an explicit method name may be provided instead.  The method name will be used as is.
.IP "\(bu" 4
\&\fBmethod types\fR
.Sp
The types of methods that should be generated.  Each method type is a wrapper for a Rose::DB::Object::Manager class method.  The mapping of method type names to actual Rose::DB::Object::Manager class methods defaults to the following:
.Sp
.Vb 7
\&    Type        Method
\&    \-\-\-\-\-\-\-\-    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    objects     get_objects()
\&    iterator    get_objects_iterator()
\&    count       get_objects_count()
\&    delete      delete_objects()
\&    update      update_objects()
.Ve
.Sp
You may override the auto_manager_method_name method in the object_class's convention manager class to customize one or more of these names.
.IP "\(bu" 4
\&\fBtarget class\fR
.Sp
The class that the methods should be installed in.
.RE
.RS 4
.Sp
Here are all of the different ways that each of those pieces of information can be provided, either implicitly or explicitly as part of \s-1PARAMS\s0.
.IP "\(bu" 4
\&\fBobject class\fR
.Sp
If an \f(CW\*(C`object_class\*(C'\fR parameter is passed in \s-1PARAMS\s0, then its value is used as the object class.  Example:
.Sp
.Vb 1
\&    $class\->make_manager_methods(object_class => \*(AqProduct\*(Aq, ...);
.Ve
.Sp
If the \f(CW\*(C`object_class\*(C'\fR parameter is not passed, and if the \fBtarget class\fR inherits from Rose::DB::Object::Manager and has also defined an \f(CW\*(C`object_class\*(C'\fR method, then the return value of that method is used as the object class.  Example:
.Sp
.Vb 1
\&  package Product::Manager;
\&
\&  use Rose::DB::Object::Manager;
\&  our @ISA = qw(Rose::DB::Object::Manager);
\&
\&  sub object_class { \*(AqProduct\*(Aq }
\&
\&  # Assume object_class parameter is not part of the ... below
\&  _\|_PACKAGE_\|_\->make_manager_methods(...);
.Ve
.Sp
In this case, the object class would be \f(CW\*(C`Product\*(C'\fR.
.Sp
Finally, if none of the above conditions are met, one final option is considered.  If the \fBtarget class\fR inherits from Rose::DB::Object, then the object class is set to the \fBtarget class\fR.
.Sp
If the object class cannot be determined in one of the ways described above, then a fatal error will occur.
.IP "\(bu" 4
\&\fBbase name\fR or \fBmethod name\fR
.Sp
If a \f(CW\*(C`base_name\*(C'\fR parameter is passed in \s-1PARAMS\s0, then its value is used as the base name for the generated methods.  Example:
.Sp
.Vb 1
\&    $class\->make_manager_methods(base_name => \*(Aqproducts\*(Aq, ...);
.Ve
.Sp
If the \f(CW\*(C`base_name\*(C'\fR parameter is not passed, and if there is only one argument passed to the method, then the lone argument is used as the base name.  Example:
.Sp
.Vb 1
\&    $class\->make_manager_methods(\*(Aqproducts\*(Aq);
.Ve
.Sp
(Note that, since the \fBobject class\fR must be derived somehow, this will only work in one of the situations (described above) where the \fBobject class\fR can be derived from the calling context or class.)
.Sp
If a \f(CW\*(C`methods\*(C'\fR parameter is passed with a hash ref value, then each key of the hash is used as the base name for the method types listed in the corresponding value.  (See \fBmethod types\fR below for more information.)
.Sp
If a key of the \f(CW\*(C`methods\*(C'\fR hash ends in \*(L"()\*(R", then it is taken as the method name and is used as is.  For example, the key \*(L"foo\*(R" will be used as a base name, but the key \*(L"\fIfoo()\fR\*(R" will be used as a method name.
.Sp
If the base name cannot be determined in one of the ways described above, then the auto_manager_base_name method in the object_class's convention manager is called on to supply a base name.
.IP "\(bu" 4
\&\fBmethod types\fR
.Sp
If an explicit list of mehod types is not passed to the method, then all of the default_manager_method_types are created.  Example:
.Sp
.Vb 3
\&    # Base name is determined by convention manager auto_manager_base_name()
\&    # method, all default method types created
\&    $class\->make_manager_methods();
\&
\&    # Base name is "products", all default method types created
\&    $class\->make_manager_methods(\*(Aqproducts\*(Aq);
\&
\&    # Base name is "products", all default method types created
\&    $class\->make_manager_methods(base_name => products\*(Aq, ...);
.Ve
.Sp
(Again, note that the \fBobject class\fR must be derived somehow.)
.Sp
If a \f(CW\*(C`methods\*(C'\fR parameter is passed, then its value must be a reference to a hash whose keys are base names or method names, and whose values are method types or references to arrays of method types.
.Sp
If a key ends in \*(L"()\*(R", then it is taken as a method name and is used as is.  Otherwise, it is used as a base name.  For example, the key \*(L"foo\*(R" will be used as a base name, but the key \*(L"\fIfoo()\fR\*(R" will be used as a method name.
.Sp
If a key is a method name and its value specifies more than one method type, then a fatal error will occur.  (It's impossible to have more than one method with the same name.)
.Sp
Example:
.Sp
.Vb 10
\&    # Make the following methods:
\&    #
\&    # * Base name: products; method types: objects, iterators
\&    #
\&    #     get_products()
\&    #     get_products_iterator()
\&    #
\&    # * Method name: product_count; method type: count
\&    #
\&    #     product_count()
\&    #
\&    $class\->make_manager_methods(...,
\&      methods =>
\&      {
\&        \*(Aqproducts\*(Aq        => [ qw(objects iterator) ],
\&        \*(Aqproduct_count()\*(Aq => \*(Aqcount\*(Aq
\&      });
.Ve
.Sp
If the value of the \f(CW\*(C`methods\*(C'\fR parameter is not a reference to a hash, or if both the \f(CW\*(C`methods\*(C'\fR and \f(CW\*(C`base_name\*(C'\fR parameters are passed, then a fatal error will occur.
.IP "\(bu" 4
\&\fBtarget class\fR
.Sp
If a \f(CW\*(C`target_class\*(C'\fR parameter is passed in \s-1PARAMS\s0, then its value is used as the target class.  Example:
.Sp
.Vb 1
\&    $class\->make_manager_methods(target_class => \*(AqProduct\*(Aq, ...);
.Ve
.Sp
If a \f(CW\*(C`target_class\*(C'\fR parameter is not passed, and if the calling class is not Rose::DB::Object::Manager, then the calling class is used as the target class.  Otherwise, the class from which the method was called is used as the target class.  Examples:
.Sp
.Vb 3
\&    # Target class is Product, regardless of the calling
\&    # context or the value of $class
\&    $class\->make_manager_methods(target_class => \*(AqProduct\*(Aq, ...);
\&
\&    package Foo;
\&
\&    # Target class is Foo: no target_class parameter is passed
\&    # and the calling class is Rose::DB::Object::Manager, so 
\&    # the class from which the method was called (Foo) is used.
\&    Rose::DB::Object::Manager\->make_manager_methods(
\&      object_class => \*(AqBar\*(Aq,
\&      base_name    => \*(AqBaz\*(Aq);
\&
\&    package Bar;
\&
\&    # Target class is Foo: no target_class parameter is passed 
\&    # and the calling class is not Rose::DB::Object::Manager,
\&    # so the calling class (Foo) is used.
\&    Foo\->make_manager_methods(object_class => \*(AqBar\*(Aq,
\&                              base_name    => \*(AqBaz\*(Aq);
.Ve
.RE
.RS 4
.Sp
There's a lot of flexibility in this method's arguments (although some might use the word \*(L"confusion\*(R" instead), but the examples can be pared down to a few common usage scenarios.
.Sp
The first is the recommended technique, as seen in the synopsis. Create a separate manager class that inherits from Rose::DB::Object::Manager, override the \f(CW\*(C`object_class\*(C'\fR method to specify the class of the objects being fetched, and then pass a lone base name argument to the call to make_manager_methods.
.Sp
.Vb 1
\&  package Product::Manager;
\&
\&  use Rose::DB::Object::Manager;
\&  our @ISA = qw(Rose::DB::Object::Manager);
\&
\&  sub object_class { \*(AqProduct\*(Aq }
\&
\&  _\|_PACKAGE_\|_\->make_manager_methods(\*(Aqproducts\*(Aq);
.Ve
.Sp
The second example is used to install object manager methods directly into a Rose::DB::Object\-derived class.  I do not recommend this practice; I consider it \*(L"semantically impure\*(R" for the class that represents a single object to also be the class that's used to fetch multiple objects.  Inevitably, classes grow, and I'd like the \*(L"object manager\*(R" class to be separate from the object class itself so they can grow happily in isolation, with no potential clashes.
.Sp
Also, keep in mind that Rose::DB::Object and Rose::DB::Object::Manager have separate error_mode settings which must be synchronized or otherwise dealt with.  Another advantage of using a separate Rose::DB::Object::Manager subclass (as described earlier) is that you can override the error_mode in your Rose::DB::Object::Manager subclass only, rather than overriding the base class Rose::DB::Object::Manager error_mode, which may affect other classes.
.Sp
If none of that dissuades you, here's how to do it:
.Sp
.Vb 1
\&  package Product;
\&
\&  use Rose::DB::Object:;
\&  our @ISA = qw(Rose::DB::Object);
\&
\&  _\|_PACKAGE_\|_\->make_manager_methods(\*(Aqproducts\*(Aq);
.Ve
.Sp
Finally, sometimes you don't want or need to use make_manager_methods at all.  In fact, this method did not exist in earlier versions of this module.  The formerly recommended way to use this class is  still perfectly valid: subclass it and then call through to the base class methods.
.Sp
.Vb 1
\&  package Product::Manager;
\&
\&  use Rose::DB::Object::Manager;
\&  our @ISA = qw(Rose::DB::Object::Manager);
\&
\&  sub get_products
\&  {
\&    shift\->get_objects(object_class => \*(AqProduct\*(Aq, @_);
\&  }
\&
\&  sub get_products_iterator
\&  {
\&    shift\->get_objects_iterator(object_class => \*(AqProduct\*(Aq, @_);
\&  }
\&
\&  sub get_products_count
\&  {
\&    shift\->get_objects_count(object_class => \*(AqProduct\*(Aq, @_);
\&  }
\&
\&  sub delete_products
\&  {
\&    shift\->delete_objects(object_class => \*(AqProduct\*(Aq, @_);
\&  }
\&
\&  sub update_products
\&  {
\&    shift\->update_objects(object_class => \*(AqProduct\*(Aq, @_);
\&  }
.Ve
.Sp
Of course, these methods will all look very similar in each Rose::DB::Object::Manager\-derived class.  Creating these identically structured methods is exactly what make_manager_methods automates for you.
.Sp
But sometimes you want to customize these methods, in which case the \*(L"longhand\*(R" technique above becomes essential.  For example, imagine that we want to extend the code in the synopsis, adding support for a \f(CW\*(C`with_categories\*(C'\fR parameter to the \f(CW\*(C`get_products()\*(C'\fR method.
.Sp
.Vb 2
\&  Product::Manager\->get_products(date_created    => \*(Aq10/21/2001\*(Aq, 
\&                                 with_categories => 1);
\&
\&  ...
\&
\&  sub get_products
\&  {
\&    my($class, %args) @_;
\&
\&    if(delete $args{\*(Aqwith_categories\*(Aq}) # boolean flag
\&    {
\&      push(@{$args{\*(Aqwith_objects\*(Aq}}, \*(Aqcategory\*(Aq);
\&    }
\&
\&    Rose::DB::Object::Manager\->get_objects(
\&      %args, object_class => \*(AqProduct\*(Aq)
\&  }
.Ve
.Sp
Here we've coerced the caller-friendly \f(CW\*(C`with_categories\*(C'\fR boolean flag parameter into the \f(CW\*(C`with_objects => [ \*(Aqcategory\*(Aq ]\*(C'\fR pair that Rose::DB::Object::Manager's get_objects method can understand.
.Sp
This is the typical evolution of an object manager method.  It starts out as being auto-generated by make_manager_methods, then becomes customized as new arguments are added.
.RE
.IP "\fBmake_manager_method_from_sql [ \s-1NAME\s0 => \s-1SQL\s0 | \s-1PARAMS\s0 ]\fR" 4
.IX Item "make_manager_method_from_sql [ NAME => SQL | PARAMS ]"
Create a class method in the calling class that will fetch objects using a custom \s-1SQL\s0 query.  The method created will return a reference to an array of objects or a Rose::DB::Object::Iterator object, depending on whether the \f(CW\*(C`iterator\*(C'\fR parameter is set (see below).
.Sp
Pass either a method name and an \s-1SQL\s0 query string or name/value parameters as arguments.  Valid parameters are:
.RS 4
.IP "\fBiterator \s-1BOOL\s0\fR" 4
.IX Item "iterator BOOL"
If true, the method created will return a Rose::DB::Object::Iterator object.
.IP "\fBobject_class \s-1CLASS\s0\fR" 4
.IX Item "object_class CLASS"
The class name of the Rose::DB::Object\-derived objects to be fetched.  Defaults to the value returned by the object_class class method.
.IP "\fBparams \s-1ARRAYREF\s0\fR" 4
.IX Item "params ARRAYREF"
To allow the method that will be created to accept named parameters (name/value pairs) instead of positional parameters, provide a reference to an array of parameter names in the order that they should be passed to the call to \s-1DBI\s0's execute method.
.IP "\fBmethod \s-1NAME\s0\fR" 4
.IX Item "method NAME"
The name of the method to be created.  This parameter is required.
.IP "\fBprepare_cached \s-1BOOL\s0\fR" 4
.IX Item "prepare_cached BOOL"
If true, then \s-1DBI\s0's prepare_cached method will be used (instead of the prepare method) when preparing the \s-1SQL\s0 statement that will fetch the objects.  If omitted, the default value is determined by the dbi_prepare_cached class method.
.IP "\fBshare_db \s-1BOOL\s0\fR" 4
.IX Item "share_db BOOL"
If true, \f(CW\*(C`db\*(C'\fR will be passed to each Rose::DB::Object\-derived object when it is constructed.  Defaults to true.
.IP "\fBsql \s-1SQL\s0\fR" 4
.IX Item "sql SQL"
The \s-1SQL\s0 query string.  This parameter is required.
.RE
.RS 4
.Sp
Each column returned by the \s-1SQL\s0 query must be either a column or method name in \f(CW\*(C`object_class\*(C'\fR.  Column names take precedence in the case of a conflict.
.Sp
Arguments passed to the created method will be passed to \s-1DBI\s0's execute method when the query is run.  The number of arguments must exactly match the number of placeholders in the \s-1SQL\s0 query.  Positional parameters are required unless the \f(CW\*(C`params\*(C'\fR parameter is used.  (See description above.)
.Sp
Returns a code reference to the method created.
.Sp
Examples:
.Sp
.Vb 1
\&    package Product::Manager;
\&
\&    use base \*(AqRose::DB::Object::Manager\*(Aq;
\&    ...
\&
\&    # Make method that takes no arguments
\&    _\|_PACKAGE_\|_\->make_manager_method_from_sql(get_odd_products =><<"EOF");
\&    SELECT * FROM products WHERE sku % 2 != 0 
\&    EOF
\&
\&    # Make method that takes one positional parameter
\&    _\|_PACKAGE_\|_\->make_manager_method_from_sql(get_new_products =><<"EOF");
\&    SELECT * FROM products WHERE release_date > ?
\&    EOF
\&
\&    # Make method that takes named parameters
\&    _\|_PACKAGE_\|_\->make_manager_method_from_sql(
\&      method => \*(Aqget_named_products\*(Aq,
\&      params => [ qw(type name) ],
\&      sql    => <<"EOF");
\&    SELECT * FROM products WHERE type = ? AND name LIKE ?
\&    EOF
\&
\&    ...
\&
\&    $products = Product::Manager\->get_odd_products();
\&
\&    $products = Product::Manager\->get_new_products(\*(Aq2005\-01\-01\*(Aq);
\&
\&    $products = 
\&      Product::Manager\->get_named_products(
\&        name => \*(AqKite%\*(Aq, 
\&        type => \*(Aqtoy\*(Aq);
\&
\&    # Make method that takes named parameters and returns an iterator
\&    _\|_PACKAGE_\|_\->make_manager_method_from_sql(
\&      method   => \*(Aqget_named_products_iterator\*(Aq,
\&      iterator => 1,
\&      params   => [ qw(type name) ],
\&      sql      => <<"EOF");
\&    SELECT * FROM products WHERE type = ? AND name LIKE ?
\&    EOF
\&
\&    $iterator = 
\&      Product::Manager\->get_named_products_iterator(
\&        name => \*(AqKite%\*(Aq, 
\&        type => \*(Aqtoy\*(Aq);
\&
\&    while(my $product = $iterator\->next)
\&    {
\&      ... # do something with $product
\&
\&      $iterator\->finish  if(...); # finish early?
\&    }
.Ve
.RE
.IP "\fBnormalize_get_objects_args [\s-1ARGS\s0]\fR" 4
.IX Item "normalize_get_objects_args [ARGS]"
This method takes \s-1ARGS\s0 in the forms accepted by get_objects (and other similar methods) and normalizes them into name/value pairs.  Since get_objects can take arguments in many forms, this method is useful when overriding get_objects in a custom Rose::DB::Object::Manager subclass.  Example:
.Sp
.Vb 1
\&    package Product::Manager;
\&
\&    use base \*(AqRose::DB::Object::Manager\*(Aq; 
\&
\&    use Product;
\&
\&    sub object_class { \*(AqProduct\*(Aq }
\&    ...
\&
\&    sub get_products
\&    {
\&      my($class, %args) = shift\->normalize_get_objects_args(@_);
\&
\&      # Detect, extract, and handle custom argument
\&      if(delete $args{\*(Aqactive_only\*(Aq})
\&      {
\&        push(@{$args{\*(Aqquery\*(Aq}}, status => \*(Aqactive\*(Aq);
\&      }
\&
\&      return $class\->get_objects(%args); # call through to normal method
\&    }
.Ve
.Sp
Now all of the following calls will work:
.Sp
.Vb 2
\&    $products =
\&      Product::Manager\->get_products([ type => \*(Aqboat\*(Aq ], sort_by => \*(Aqname\*(Aq);
\&
\&    $products =
\&      Product::Manager\->get_products({ name => { like => \*(Aq%Dog%\*(Aq } });
\&
\&    $products =
\&      Product::Manager\->get_products([ id => { gt => 123 } ], active_only => 1);
.Ve
.IP "\fBobject_class\fR" 4
.IX Item "object_class"
Returns the class name of the Rose::DB::Object\-derived objects to be managed by this class.  Override this method in your subclass.  The default implementation returns undef.
.IP "\fBperl_class_definition\fR" 4
.IX Item "perl_class_definition"
Attempts to create the Perl source code that is equivalent to the current class.  This works best for classes created via Rose::DB::Object::Metadata's make_manager_class method, but it will also work most of the time for classes whose methods were created using make_manager_methods.
.Sp
The Perl code is returned as a string.  Here's an example:
.Sp
.Vb 1
\&  package My::Product::Manager;
\&
\&  use My::Product;
\&
\&  use Rose::DB::Object::Manager;
\&  our @ISA = qw(Rose::DB::Object::Manager);
\&
\&  sub object_class { \*(AqMy::Product\*(Aq }
\&
\&  _\|_PACKAGE_\|_\->make_manager_methods(\*(Aqproducts\*(Aq);
\&
\&  1;
.Ve
.IP "\fBupdate_objects [\s-1PARAMS\s0]\fR" 4
.IX Item "update_objects [PARAMS]"
Update rows in a table fronted by a Rose::DB::Object\-derived class based on \s-1PARAMS\s0, where \s-1PARAMS\s0 are name/value pairs.  Returns the number of rows updated, or undef if there was an error.
.Sp
Valid parameters are:
.RS 4
.IP "\fBall \s-1BOOL\s0\fR" 4
.IX Item "all BOOL"
If set to a true value, this parameter indicates an explicit request to update all rows in the table.  If both the \f(CW\*(C`all\*(C'\fR and the \f(CW\*(C`where\*(C'\fR parameters are passed, a fatal error will occur.
.IP "\fBdb \s-1DB\s0\fR" 4
.IX Item "db DB"
A Rose::DB\-derived object used to access the database.  If omitted, one will be created by calling the init_db method of the \f(CW\*(C`object_class\*(C'\fR.
.IP "\fBobject_class \s-1CLASS\s0\fR" 4
.IX Item "object_class CLASS"
The class name of the Rose::DB::Object\-derived class that fronts the table whose rows will to be updated.  This parameter is required; a fatal error will occur if it is omitted.  Defaults to the value returned by the object_class class method.
.IP "\fBset \s-1PARAMS\s0\fR" 4
.IX Item "set PARAMS"
The names and values of the columns to be updated.  \s-1PARAMS\s0 should be a reference to a hash.  Each key of the hash should be a column name or column get/set method name.  If a value is a simple scalar, then it is passed through the get/set method that services the column before being incorporated into the \s-1SQL\s0 query.
.Sp
If a value is a reference to a scalar, then it is dereferenced and incorporated into the \s-1SQL\s0 query as-is.
.Sp
If a value is a reference to a hash, then it must contain a single key named \*(L"sql\*(R" and a corresponding value that will be incorporated into the \s-1SQL\s0 query as-is.
.Sp
Example:
.Sp
.Vb 10
\&  $num_rows_updated =
\&    Product::Manager\->update_products(
\&      set =>
\&      {
\&        end_date   => DateTime\->now,
\&        region_num => { sql => \*(Aqregion_num * \-1\*(Aq }
\&        count      => \eq(count + 1),
\&        status     => \*(Aqdefunct\*(Aq,
\&      },
\&      where =>
\&      [
\&        status  => [ \*(Aqstale\*(Aq, \*(Aqold\*(Aq ],
\&        name    => { like => \*(AqWax%\*(Aq }
\&        or =>
\&        [
\&          start_date => { gt => \*(Aq2008\-12\-30\*(Aq },
\&          end_date   => { gt => \*(Aqnow\*(Aq },
\&        ],
\&      ]);
.Ve
.Sp
The call above would execute an \s-1SQL\s0 statement something like the one shown below (depending on the database vendor, and assuming the current date was September 20th, 2005):
.Sp
.Vb 12
\&    UPDATE products SET
\&      end_date   = \*(Aq2005\-09\-20\*(Aq,
\&      region_num = region_num * \-1,
\&      count      = count + 1, 
\&      status     = \*(Aqdefunct\*(Aq
\&    WHERE
\&      status IN (\*(Aqstale\*(Aq, \*(Aqold\*(Aq) AND
\&      name LIKE \*(AqWax%\*(Aq AND
\&      (
\&        start_date > \*(Aq2008\-12\-30\*(Aq OR
\&        end_date   > \*(Aq2005\-09\-20\*(Aq
\&      )
.Ve
.IP "\fBwhere \s-1PARAMS\s0\fR" 4
.IX Item "where PARAMS"
The query parameters, passed as a reference to an array of name/value pairs.  These \s-1PARAMS\s0 are used to formulate the \*(L"where\*(R" clause of the \s-1SQL\s0 query that is used to update the rows in the table.  Arbitrarily nested boolean logic is supported.
.Sp
For the complete list of valid parameter names and values, see the documentation for the \f(CW\*(C`query\*(C'\fR parameter of the build_select function in the Rose::DB::Object::QueryBuilder module.
.Sp
If this parameter is omitted, this method will refuse to update all rows in the table and a fatal error will occur.  To update all rows in a table, you must pass the \f(CW\*(C`all\*(C'\fR parameter with a true value.  If both the \f(CW\*(C`all\*(C'\fR and the \f(CW\*(C`where\*(C'\fR parameters are passed, a fatal error will occur.
.RE
.RS 4
.RE
.IP "\fBstrict_ops [\s-1BOOL\s0]\fR" 4
.IX Item "strict_ops [BOOL]"
Get or set a boolean value that indicates whether using a comparison operator in the \f(CW\*(C`query\*(C'\fR that is not listed in the Rose::DB::Object::QueryBuilder documentation will cause a fatal error.  The default value is false.
.SH "SUPPORT"
.IX Header "SUPPORT"
For an informal overview of Rose::DB::Object, including Rose::DB::Object::Manager, consult the Rose::DB::Object::Tutorial.
.PP
.Vb 1
\&    perldoc Rose::DB::Object::Tutorial
.Ve
.PP
Any Rose::DB::Object::Manager questions or problems can be posted to the Rose::DB::Object mailing list.  To subscribe to the list or view the archives, go here:
.PP
http://groups.google.com/group/rose\-db\-object <http://groups.google.com/group/rose-db-object>
.PP
Although the mailing list is the preferred support mechanism, you can also email the author (see below) or file bugs using the \s-1CPAN\s0 bug tracking system:
.PP
http://rt.cpan.org/NoAuth/Bugs.html?Dist=Rose\-DB\-Object <http://rt.cpan.org/NoAuth/Bugs.html?Dist=Rose-DB-Object>
.PP
There's also a wiki and other resources linked from the Rose project home page:
.PP
<http://rose.googlecode.com>
.SH "AUTHOR"
.IX Header "AUTHOR"
John C. Siracusa (siracusa@gmail.com)
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2010 by John C. Siracusa.  All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same terms
as Perl itself.
