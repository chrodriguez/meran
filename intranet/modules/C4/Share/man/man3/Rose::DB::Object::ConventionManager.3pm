.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Rose::DB::Object::ConventionManager 3"
.TH Rose::DB::Object::ConventionManager 3 "2011-01-31" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Rose::DB::Object::ConventionManager \- Provide missing metadata by convention.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package My::Product;
\&
\&  use base \*(AqRose::DB::Object\*(Aq;
\&
\&  _\|_PACKAGE_\|_\->meta\->setup(columns => [ ... ]);
\&
\&  # No table is set above, but look at this: the
\&  # convention manager provided one for us.
\&  print _\|_PACKAGE_\|_\->meta\->table; # "products"
\&
\&  ##
\&  ## See the EXAMPLE section below for a more complete demonstration.
\&  ##
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Each Rose::DB::Object\-derived object has a convention manager that it uses to fill in missing metadata.  The convention manager encapsulates a set of rules (conventions) for generating various pieces of metadata in the absence of explicitly specified values: table names, column names, etc.
.PP
Each Rose::DB::Object\-derived class's convention manager object is stored in the convention_manager attribute of its Rose::DB::Object::Metadata (meta) object.  Rose::DB::Object::ConventionManager is the default convention manager class.
.PP
The object method documentation below describes both the purpose of each convention manager method and the particular rules that Rose::DB::Object::ConventionManager follows to fulfill that purpose.  Subclasses must honor the purpose of each method, but are free to use any rules they choose.
.PP
\&\fBNote well:\fR When reading the descriptions of the rules used by each convention manager method below, remember that only values that are \fImissing\fR will be set by the convention manager.  Explicitly providing a value for a piece of metadata obviates the need for the convention manager to generate one.
.PP
If insufficient information is available, or if the convention manager simply declines to fulfill a request, undef may be returned from any metadata-generating method.
.PP
In the documentation, the adjectives \*(L"local\*(R" and \*(L"foreign\*(R" are used to distinguish between the things that belong to the the convention manager's class and the class on \*(L"the other side\*(R" of the inter-table relationship, respectively.
.SH "SUMMARY OF DEFAULT CONVENTIONS"
.IX Header "SUMMARY OF DEFAULT CONVENTIONS"
Although the object method documentation below includes all the information required to understand the default conventions, it's also quite spread out.  What follows is a summary of the default conventions.  Some details have necessarily been omitted or simplified for the sake of brevity, but this summary should give you a good starting point for further exploration.
.PP
Here's a brief summary of the default conventions as implemented in Rose::DB::Object::ConventionManager.
.IP "\fBTable, column, foreign key, and relationship names are lowercase, with underscores separating words.\fR" 4
.IX Item "Table, column, foreign key, and relationship names are lowercase, with underscores separating words."
Examples:  \f(CW\*(C`products\*(C'\fR, \f(CW\*(C`street_address\*(C'\fR, \f(CW\*(C`date_created\*(C'\fR, \f(CW\*(C`vendor_id\*(C'\fR.
.IP "\fBTable names are plural.\fR" 4
.IX Item "Table names are plural."
Examples: \f(CW\*(C`products\*(C'\fR, \f(CW\*(C`vendors\*(C'\fR, \f(CW\*(C`codes\*(C'\fR, \f(CW\*(C`customer_details\*(C'\fR, \f(CW\*(C`employee_addresses\*(C'\fR.
.Sp
(This convention can be overridden via the tables_are_singular method.)
.IP "\fBClass names are singular, title-cased, with nothing separating words.\fR" 4
.IX Item "Class names are singular, title-cased, with nothing separating words."
Examples: \f(CW\*(C`Product\*(C'\fR, \f(CW\*(C`Vendor\*(C'\fR, \f(CW\*(C`Code\*(C'\fR, \f(CW\*(C`CustomerDetail\*(C'\fR, \f(CW\*(C`EmployeeAddress\*(C'\fR.
.IP "\fBPrimary key column names do not contain the table name.\fR" 4
.IX Item "Primary key column names do not contain the table name."
For example, the primary key column name in the \f(CW\*(C`products\*(C'\fR table might be \f(CW\*(C`id\*(C'\fR or \f(CW\*(C`sku\*(C'\fR, but should \fBnot\fR be \f(CW\*(C`product_id\*(C'\fR or \f(CW\*(C`product_sku\*(C'\fR.
.IP "\fBForeign key column names are made from the singular version of the foreign table's name joined (with an underscore) to the foreign table's key column name.\fR" 4
.IX Item "Foreign key column names are made from the singular version of the foreign table's name joined (with an underscore) to the foreign table's key column name."
Examples: \f(CW\*(C`product_sku\*(C'\fR, \f(CW\*(C`vendor_id\*(C'\fR, \f(CW\*(C`employee_address_id\*(C'\fR.
.IP "\fBOne-to-one and many-to-one relationship names are singular.\fR" 4
.IX Item "One-to-one and many-to-one relationship names are singular."
Examples: \f(CW\*(C`product\*(C'\fR, \f(CW\*(C`vendor\*(C'\fR, \f(CW\*(C`code\*(C'\fR.  These relationships may point to zero or one foreign object.  The default method names generated from such relationships are based on the relationship names, so singular names make the most sense.
.IP "\fBOne-to-many and many-to-many relationship names are plural.\fR" 4
.IX Item "One-to-many and many-to-many relationship names are plural."
Examples: \f(CW\*(C`colors\*(C'\fR, \f(CW\*(C`prices\*(C'\fR, \f(CW\*(C`customer_details\*(C'\fR.  These relationships may point to more than one foreign object.  The default method names generated from such relationships are based on the relationship names, so plural names make the most sense.
.IP "\fBMapping tables and their associated classes that participate in many-to-many relationships are named according a formula that combines the names of the two classes/tables that are being linked.\fR" 4
.IX Item "Mapping tables and their associated classes that participate in many-to-many relationships are named according a formula that combines the names of the two classes/tables that are being linked."
See the auto_relationship, looks_like_map_class, and looks_like_map_table documentation for all the details.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "\fBnew \s-1PARAMS\s0\fR" 4
.IX Item "new PARAMS"
Constructs a new object based on \s-1PARAMS\s0, where \s-1PARAMS\s0 are
name/value pairs.  Any object attribute is a valid parameter name.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.IP "\fBauto_column_method_name \s-1TYPE\s0, \s-1COLUMN\s0, \s-1NAME\s0, \s-1OBJECT_CLASS\s0\fR" 4
.IX Item "auto_column_method_name TYPE, COLUMN, NAME, OBJECT_CLASS"
Given a Rose::DB::Object::Metadata::Column column type, a Rose::DB::Object::Metadata::Column object or column name, a default method name, and a Rose::DB::Object\-derived class name, return an appropriate method name.  The default implementation simply returns undef, relying on the hard-coded default method-type-to-name mapping implemented in Rose::DB::Object::Metadata's  method_name_from_column method.
.IP "\fBauto_foreign_key \s-1NAME\s0 [, \s-1SPEC\s0]\fR" 4
.IX Item "auto_foreign_key NAME [, SPEC]"
Given a foreign key name and an optional reference to a hash \s-1SPEC\s0 of the type passed to Rose::DB::Object::Metadata's add_foreign_keys method, return an appropriately constructed Rose::DB::Object::Metadata::ForeignKey object.
.Sp
The foreign key's class name is generated by calling related_table_to_class, passing \s-1NAME\s0 and the convention manager's class as arguments.  An attempt is made is load the class.  If this fails, the foreign key's class name is not set.
.Sp
The foreign key's key_columns are only set if both the \*(L"local\*(R" and \*(L"foreign\*(R" tables have single-column primary keys.  The foreign class's primary key column name is used as the foreign column in the  key_columns map.  If there is a local column with the same name as the foreign key name, and if that column is aliased (making way for the foreign key method to use that name), then that is used as as the local column.  If not, then the local column name is generated by joining the foreign key name and the foreign class's primary key column name with an underscore.  If no column by that name exists, then the search is abandoned.  Example:
.Sp
Given these pieces:
.Sp
.Vb 5
\&    Name        Description                        Value
\&    \-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-
\&    NAME        Foreign key name                   vendor
\&    FCLASS      Foreign class                      My::Vendor
\&    FPK         Foreign primary key column name    id
.Ve
.Sp
Consider column maps in this order:
.Sp
.Vb 4
\&    Value                   Formula                         
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    { vendor => \*(Aqid\*(Aq }      { NAME => FPK }
\&    { vendor_id => \*(Aqid\*(Aq }   { <NAME>_<FPK> => FPK }
.Ve
.IP "\fBauto_foreign_key_name \s-1FOREIGN_CLASS\s0, \s-1CURRENT_NAME\s0, \s-1KEY_COLUMNS\s0, \s-1USED_NAMES\s0\fR" 4
.IX Item "auto_foreign_key_name FOREIGN_CLASS, CURRENT_NAME, KEY_COLUMNS, USED_NAMES"
Given the name of a foreign class, the current foreign key name (if any), a reference to a hash of key columns, and a reference to a hash whose keys are foreign key names already used in this class, return a name for the foreign key.
.Sp
If there is more than one pair of columns in \s-1KEY_COLUMNS\s0, then the name is generated by calling plural_to_singular, passing the table name of the foreign class.  The \s-1CURRENT_NAME\s0 is used if the call to plural_to_singular does not return a true value.
.Sp
If there is just one pair of columns in \s-1KEY_COLUMNS\s0, and if the name of the local column ends with an underscore and the name of the referenced column, then that part of the column name is removed and the remaining string is used as the foreign key name.  For example, given the following tables:
.Sp
.Vb 5
\&    CREATE TABLE categories
\&    (
\&      id  SERIAL PRIMARY KEY,
\&      ...
\&    );
\&
\&    CREATE TABLE products
\&    (
\&      category_id  INT REFERENCES categories (id),
\&      ...
\&    );
.Ve
.Sp
The foreign key name would be \*(L"category\*(R", which is the name of the referring column (\*(L"category_id\*(R") with an underscore and the name of the referenced column (\*(L"_id\*(R") removed from the end of it.
.Sp
If the foreign key has only one column, but it does not meet the criteria described above, then the name is generated by calling plural_to_singular, passing the table name of the foreign class.  The \s-1CURRENT_NAME\s0 is used if the call to plural_to_singular does not return a true value.
.Sp
If the name selected using the above techniques is in the \s-1USED_NAMES\s0 hash, or is the same as that of an existing or potential method in the target class, then the suffixes \*(L"_obj\*(R" and \*(L"_object\*(R" are tried in that order.  If neither of those suffixes resolves the situation, then ascending numeric suffixes starting with \*(L"1\*(R" are tried until a unique name is found.
.IP "\fBauto_manager_base_name \s-1TABLE\s0, \s-1CLASS\s0\fR" 4
.IX Item "auto_manager_base_name TABLE, CLASS"
Given a table name and the name of the Rose::DB::Object\-derived class that fronts it, return a base name suitable for use as the value of the \f(CW\*(C`base_name\*(C'\fR parameter to Rose::DB::Object::Manager's make_manager_methods method.
.Sp
If no table is specified then the table name is derived from the current class
name by calling class_to_table_plural.
.Sp
If tables_are_singular is true, then \s-1TABLE\s0 is passed to the singular_to_plural method and the result is returned.  Otherwise, \s-1TABLE\s0 is returned as-is.
.IP "\fBauto_manager_base_class\fR" 4
.IX Item "auto_manager_base_class"
Return the class that all manager classes will default to inheriting from.  By
default this will be Rose::DB::Object::Manager.
.IP "\fBauto_manager_class_name \s-1CLASS\s0\fR" 4
.IX Item "auto_manager_class_name CLASS"
Given the name of a Rose::DB::Object\-derived class, returns a class name for a Rose::DB::Object::Manager\-derived class to manage such objects.  The default implementation simply appends \*(L"::Manager\*(R" to the Rose::DB::Object\-derived class name.
.IP "\fBauto_manager_method_name \s-1TYPE\s0, \s-1BASE_NAME\s0, \s-1OBJECT_CLASS\s0\fR" 4
.IX Item "auto_manager_method_name TYPE, BASE_NAME, OBJECT_CLASS"
Given the specified Rose::DB::Object::Manager method type,
base name, and object class return an appropriate manager method name.  The default implementation simply returns undef, relying on the hard-coded default method-type-to-name mapping implemented in Rose::DB::Object::Manager's  make_manager_methods method.
.IP "\fBauto_relationship_name_many_to_many \s-1FK\s0, \s-1MAPCLASS\s0\fR" 4
.IX Item "auto_relationship_name_many_to_many FK, MAPCLASS"
Return the name of a \*(L"many to many\*(R" relationship that fetches objects from the table pointed to by the Rose::DB::Object::Metadata::ForeignKey object \s-1FK\s0 by going through the class \s-1MAPCLASS\s0.
.Sp
The default implementation passes the name of the table pointed to by \s-1FK\s0 through the singular_to_plural method in order to build the name.
.Sp
If the selected name is the name of an existing or potential method in the target class, then the suffixes \*(L"_objs\*(R" and \*(L"_objects\*(R" are tried in that order.  If neither of those suffixes resolves the situation, then ascending numeric suffixes starting with \*(L"1\*(R" are tried until a unique name is found.
.IP "\fBauto_relationship_name_one_to_many \s-1TABLE\s0, \s-1CLASS\s0\fR" 4
.IX Item "auto_relationship_name_one_to_many TABLE, CLASS"
Return the name of a \*(L"one to many\*(R" relationship that fetches objects from the specified \s-1TABLE\s0 and \s-1CLASS\s0.
.Sp
If tables_are_singular is true, then \s-1TABLE\s0 is passed to the singular_to_plural method and the result is used as the name.  Otherwise, \s-1TABLE\s0 is used as-is.
.Sp
If the selected name is the name of an existing or potential method in the target class, then the suffixes \*(L"_objs\*(R" and \*(L"_objects\*(R" are tried in that order.  If neither of those suffixes resolves the situation, then ascending numeric suffixes starting with \*(L"1\*(R" are tried until a unique name is found.
.IP "\fBauto_relationship_name_one_to_one \s-1TABLE\s0, \s-1CLASS\s0\fR" 4
.IX Item "auto_relationship_name_one_to_one TABLE, CLASS"
Return the name of a \*(L"one to one\*(R" relationship that fetches an object from the specified \s-1TABLE\s0 and \s-1CLASS\s0.  The default implementation returns a singular version of the table name.
.Sp
If the selected name is the name of an existing or potential method in the target class, then the suffixes \*(L"obj_\*(R" and \*(L"_object\*(R" are tried in that order.  If neither of those suffixes resolves the situation, then ascending numeric suffixes starting with \*(L"1\*(R" are tried until a unique name is found.
.IP "\fBauto_primary_key_column_names\fR" 4
.IX Item "auto_primary_key_column_names"
Returns a reference to an array of primary key column names.
.Sp
If a column named \*(L"id\*(R" exists, it is selected as the sole primary key column name.  If not, the column name generated by joining the return value of class_to_table_singular with \*(L"_id\*(R" is considered.  If no column with that name exists, then the first column (sorted alphabetically) whose type is \*(L"serial\*(R" is selected.  If all of the above fails, then the first column is selected as the primary key column (assuming one exists).
.Sp
Examples:
.Sp
.Vb 2
\&    My::A\->meta\->columns(qw(a a_id id));
\&    print My::A\->meta\->primary_key_columns; # "id"
\&
\&    My::B\->meta\->columns(qw(b b_id foo));
\&    print My::B\->meta\->primary_key_columns; # "a_id"
\&
\&    My::D\->meta\->columns
\&    (
\&      cnt  => { type => \*(Aqint\*(Aq }, 
\&      dub  => { type => \*(Aqserial\*(Aq }, 
\&      foo  => { type => \*(Aqserial\*(Aq},
\&      a_id => { type => \*(Aqint\*(Aq }
\&    )
\&
\&    print My::D\->meta\->primary_key_columns; # "dub"
\&
\&    My::C\->meta\->columns(qw(foo bar baz));
\&    print My::C\->meta\->primary_key_columns; # "foo"
.Ve
.IP "\fBauto_relationship \s-1NAME\s0, \s-1RELATIONSHIP_CLASS\s0 [, \s-1SPEC\s0]\fR" 4
.IX Item "auto_relationship NAME, RELATIONSHIP_CLASS [, SPEC]"
Given a relationship name, a Rose::DB::Object::Metadata::Relationship\-derived class name, and an optional reference to a hash \s-1SPEC\s0 of the type passed to Rose::DB::Object::Metadata's add_relationships method, return an appropriately constructed Rose::DB::Object::Metadata::Relationship\-derived object.
.Sp
If the relationship's type is \*(L"one to one\*(R" or \*(L"many to one\*(R", then the relationship's class name is generated by calling related_table_to_class, passing \s-1NAME\s0 and the convention manager's class as arguments.  An attempt is made is load the class.  If this fails, the relationship's class name is not set.
.Sp
The column map for \*(L"one to one\*(R" and \*(L"many to one\*(R" relationships is generated using the same rules used to generate key_columns in the auto_foreign_key method.
.Sp
If the relationship's type is \*(L"one to many\*(R" then the relationship's class name is generated by calling plural_to_singular on \s-1NAME\s0, then passing that value along with the convention manager's class to the related_table_to_class method.  An attempt is made is load the class.  If this fails, the relationship's class name is not set.
.Sp
The column map for a \*(L"one to many\*(R" relationship is only set if both the \*(L"local\*(R" and \*(L"foreign\*(R" tables have single-column primary keys.  The following ordered list of combinations is considered.
.Sp
Given:
.Sp
.Vb 3
\&   Local class:   My::Product
\&   Foreign class: My::Price
\&   Relationship:  prices
.Ve
.Sp
Generate these pieces:
.Sp
.Vb 5
\&    Name        Description                         Value
\&    \-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-
\&    LTABLE_S    Local class_to_table_singular()     product
\&    LPK         Local primary key column name       id
\&    FPK         Foreign primary key column name     id
.Ve
.Sp
Consider column maps in this order:
.Sp
.Vb 4
\&    Value                     Formula                         
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    { id => \*(Aqproduct\*(Aq }       { LPK => LTABLE_S }
\&    { id => \*(Aqproduct_id\*(Aq }    { LPK => <LTABLE_S>_<PK> }
.Ve
.Sp
The first value whose foreign column actually exists in the foreign table is chosen.
.Sp
If the relationship's type is \*(L"many to many\*(R" then the relationship's map_class is chosen from a list of possibilities.  This list is generated by constructing singular and plural versions of the local and foreign class names (sans prefixes) and then joining them in various ways, all re-prefixed by the the class prefix of the convention manager's class.  Example:
.Sp
Given:
.Sp
.Vb 3
\&   Local class:   My::Product
\&   Foreign class: My::Color
\&   Relationship:  colors
.Ve
.Sp
Generate these pieces:
.Sp
.Vb 7
\&    Name        Description                         Value
\&    \-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-
\&    PREFIX      Local class prefix                  My::
\&    LCLASS_S    Unprefixed local class, singular    Product
\&    LCLASS_P    Unprefixed local class, plural      Products
\&    FCLASS_S    Unprefixed foreign class, singular  Color
\&    FCLASS_P    Unprefixed foreign class, plural    Colors
.Ve
.Sp
Consider map class names in this order:
.Sp
.Vb 10
\&    Value                   Formula                         
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-         \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-           
\&    My::ProductsColorsMap   <PREFIX><LCLASS_P><FCLASS_P>Map 
\&    My::ProductColorMap     <PREFIX><LCLASS_S><FCLASS_S>Map 
\&    My::ColorsProductsMap   <PREFIX><FCLASS_P><LCLASS_P>Map 
\&    My::ColorProductMap     <PREFIX><FCLASS_S><LCLASS_S>Map 
\&    My::ProductsColors      <PREFIX><LCLASS_P><FCLASS_P>
\&    My::ProductColors       <PREFIX><LCLASS_S><FCLASS_P>
\&    My::ColorsProducts      <PREFIX><FCLASS_P><LCLASS_P>
\&    My::ColorProducts       <PREFIX><FCLASS_S><LCLASS_P>
\&    My::ColorMap            <PREFIX><FCLASS_S>Map 
\&    My::ColorsMap           <PREFIX><FCLASS_P>Map 
\&    My::ProductMap          <PREFIX><LCLASS_S>Map 
\&    My::ProductsMap         <PREFIX><LCLASS_P>Map
.Ve
.Sp
The first class found that inherits from Rose::DB::Object and is loaded successfully will be chosen as the relationship's map_class.
.IP "\fBauto_table_name\fR" 4
.IX Item "auto_table_name"
Returns a table name for the convention manager's class.
.Sp
Class names are singular and table names are plural.  To build the table name, the class prefix is removed from the class name, transitions from lowercase letters or digits to uppercase letters have underscores inserted, and the whole thing is converted to lowercase.
.Sp
Examples:
.Sp
.Vb 6
\&    Class         Table
\&    \-\-\-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-\-
\&    Product       products
\&    My::Product   products
\&    My::BigBox    big_boxes
\&    My5HatPig     my5_hat_pig
.Ve
.IP "\fBclass [\s-1CLASS\s0]\fR" 4
.IX Item "class [CLASS]"
Get or set the Rose::DB::Object\-derived class that this convention manager belongs to.
.IP "\fBclass_prefix \s-1CLASS\s0\fR" 4
.IX Item "class_prefix CLASS"
Given a class name, return the prefix, if any, before the last component of the namespace, including the final \*(L"::\*(R".  If there is no prefix, an empty string is returned.
.Sp
Examples:
.Sp
.Vb 5
\&    Class         Prefix
\&    \-\-\-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    Product       <empty string>
\&    My::Product   My::
\&    A::B::C::D    A::B::C::
.Ve
.IP "\fBclass_to_table_plural [\s-1CLASS\s0]\fR" 4
.IX Item "class_to_table_plural [CLASS]"
Given a class name, or the convention manager's class if omitted, return a plural version of the corresponding table name.
.Sp
To do this, the output of the class_to_table_singular method is passed to a call to the singular_to_plural method.  (The \s-1CLASS\s0 argument, if any, is passed to the call to class_to_table_singular.)
.Sp
Examples:
.Sp
.Vb 5
\&    Class         Table
\&    \-\-\-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-\-
\&    Product       products
\&    My::Product   products
\&    My::Box       boxes
.Ve
.IP "\fBclass_to_table_singular [\s-1CLASS\s0]\fR" 4
.IX Item "class_to_table_singular [CLASS]"
Given a class name, or the convention manager's class if omitted, return a singular version of the corresponding table name.
.Sp
Examples:
.Sp
.Vb 5
\&    Class         Table
\&    \-\-\-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-\-
\&    Product       product
\&    My::Product   product
\&    My::Box       box
.Ve
.IP "\fBforce_lowercase [\s-1BOOL\s0]\fR" 4
.IX Item "force_lowercase [BOOL]"
Get or set a boolean value that indicates whether or not metadata entity names should be forced to lowercase even when the related entity is uppercase or mixed case.  (\*(L"Metadata entities\*(R" are thing like columns, relationships, and foreign keys.)  The default value is false.
.IP "\fBis_map_class \s-1CLASS\s0\fR" 4
.IX Item "is_map_class CLASS"
Returns true if \s-1CLASS\s0 is a map class used as part of a many to many relationship, false if it does not.
.Sp
The default implementations returns true if \s-1CLASS\s0 is derived from Rose::DB::Object and its table name looks like a map table name according to the looks_like_map_table method and the looks_like_map_class method returns either true or undef.
.Sp
Override this method to control which classes are considered map classes.  Note that it may be called several times on the same class at various stages of that class's construction.
.IP "\fBlooks_like_map_class \s-1CLASS\s0\fR" 4
.IX Item "looks_like_map_class CLASS"
Given the class name \s-1CLASS\s0, returns true if it looks like the name of a map class used as part of a many to many relationship, false (but defined) if it does not, and undef if it's unsure.
.Sp
The default implementation returns true if \s-1CLASS\s0 is derived from Rose::DB::Object and has exactly two foreign keys.  It returns false (but defined) if \s-1CLASS\s0 is derived from Rose::DB::Object and has been initialized (or if the foreign keys have been auto-initialized) and the \s-1CLASS\s0 has no deferred foreign keys.  It returns undef otherwise.
.IP "\fBlooks_like_map_table \s-1TABLE\s0\fR" 4
.IX Item "looks_like_map_table TABLE"
Returns true if \s-1TABLE\s0 looks like the name of a mapping table used as part of a many to many relationship, false (but defined) if it does not, and undef if it's unsure.
.Sp
The default implementation returns true if \s-1TABLE\s0 is in one of these forms:
.Sp
.Vb 5
\&    Regex                     Examples
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    (\ew+_){2,}map             pig_toe_map, pig_skin_toe_map
\&    (\ew+_)*\ew+_(\ew+_)*\ew+s    pig_toes, pig_skin_toe_jams
\&    (\ew+_)*\ew+s_(\ew+_)*\ew+s   pigs_toes, pig_skins_toe_jams
.Ve
.Sp
It returns false otherwise.
.IP "\fBmeta [\s-1META\s0]\fR" 4
.IX Item "meta [META]"
Get or set the Rose::DB::Object::Metadata object associated with the class that this convention manager belongs to.
.IP "\fBplural_to_singular \s-1STRING\s0\fR" 4
.IX Item "plural_to_singular STRING"
Returns the singular version of \s-1STRING\s0.  If a plural_to_singular_function is defined, then this method simply passes \s-1STRING\s0 to that function.
.Sp
Otherwise, the following rules are applied, case-insensitively.
.Sp
* If \s-1STRING\s0 ends in \*(L"ies\*(R", then the \*(L"ies\*(R" is replaced with \*(L"y\*(R".
.Sp
* If \s-1STRING\s0 ends in \*(L"ses\*(R" then the \*(L"ses\*(R" is replaced with \*(L"s\*(R".
.Sp
* If \s-1STRING\s0 matches \f(CW\*(C`/[aeiouy]ss$/i\*(C'\fR, it is returned unmodified.
.Sp
For all other cases, the letter \*(L"s\*(R" is removed from the end of \s-1STRING\s0 and the result is returned.
.IP "\fBplural_to_singular_function [\s-1CODEREF\s0]\fR" 4
.IX Item "plural_to_singular_function [CODEREF]"
Get or set a reference to the function used to convert strings to singular.  The function should take a single string as an argument and return a singular version of the string.  This function is undefined by default.
.IP "\fBrelated_table_to_class \s-1TABLE\s0, \s-1LOCAL_CLASS\s0\fR" 4
.IX Item "related_table_to_class TABLE, LOCAL_CLASS"
Given a table name and a local class name, return the name of the related class that fronts the table.
.Sp
To do this, table_to_class is called with \s-1TABLE\s0 and the class_prefix of \s-1LOCAL_CLASS\s0 passed as arguments.
.Sp
Examples:
.Sp
.Vb 5
\&    Table         Local Class     Related Class
\&    \-\-\-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-\-\-\-\-\-    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    prices        My::Product     My::Price
\&    big_hats      A::B::FooBar    A::B::BigHat
\&    a1_steaks     Meat            A1Steak
.Ve
.IP "\fBsingular_to_plural \s-1STRING\s0\fR" 4
.IX Item "singular_to_plural STRING"
Returns the plural version of \s-1STRING\s0.  If a singular_to_plural_function is defined, then this method simply passes \s-1STRING\s0 to that function.  Otherwise, the following rules are applied, case-insensitively, to form the plural.
.Sp
* If \s-1STRING\s0 ends in \*(L"x\*(R", \*(L"ss\*(R", or \*(L"es\*(R", then \*(L"es\*(R" is appended.
.Sp
* If \s-1STRING\s0 ends in \*(L"y\*(R" then the \*(L"y\*(R" is replaced with \*(L"ies\*(R".
.Sp
* If \s-1STRING\s0 ends in \*(L"s\*(R" then it is returned as-is.
.Sp
* Otherwise, \*(L"s\*(R" is appended.
.IP "\fBsingular_to_plural_function [\s-1CODEREF\s0]\fR" 4
.IX Item "singular_to_plural_function [CODEREF]"
Get or set a reference to the function used to convert strings to plural.  The function should take a single string as an argument and return a plural version of the string.  This function is undefined by default.
.IP "\fBtable_singular\fR" 4
.IX Item "table_singular"
Let \s-1TABLE\s0 be the return value of the table method called on the meta attribute of this object.
.Sp
If tables_are_singular is true, then \s-1TABLE\s0 is returned as-is.  Otherwise, \s-1TABLE\s0 is passed to the plural_to_singular method and the result is returned.  Otherwise, \s-1TABLE\s0 is returned as-is.
.IP "\fBtable_plural\fR" 4
.IX Item "table_plural"
Let \s-1TABLE\s0 be the return value of the table method called on the meta attribute of this object.
.Sp
If tables_are_singular is true, then \s-1TABLE\s0 is passed to the singular_to_plural method and the result is returned.  Otherwise, \s-1TABLE\s0 is returned as-is.
.IP "\fBtable_to_class \s-1TABLE\s0 [, \s-1PREFIX\s0]\fR" 4
.IX Item "table_to_class TABLE [, PREFIX]"
Given a table name and an optional class prefix, return the corresponding class name.  The prefix will be appended to the class name, if present.  The prefix should end in \*(L"::\*(R".
.Sp
To do this, any letter that follows an underscore (\*(L"_\*(R") in the table name is replaced with an uppercase version of itself, and the underscore is removed.
.Sp
Examples:
.Sp
.Vb 6
\&    Table         Prefix   Class
\&    \-\-\-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-   \-\-\-\-\-\-\-\-\-\-\-
\&    products      My::     My::Product
\&    products      <none>   Product
\&    big_hats      My::     My::BigHat
\&    my5_hat_pig   <none>   My5HatPig
.Ve
.IP "\fBtables_are_singular [\s-1BOOL\s0]\fR" 4
.IX Item "tables_are_singular [BOOL]"
Get or set a boolean value that indicates whether or not table names are expected to be singular.  The default value is false, meaning that table names are expected to be plural.
.SH "PROTECTED API"
.IX Header "PROTECTED API"
These methods are not part of the public interface, but are supported for use by subclasses.  Put another way, given an unknown object that \*(L"isa\*(R" Rose::DB::Object::Metadata::ConventionManager, there should be no expectation that the following methods exist.  But subclasses, which know the exact class from which they inherit, are free to use these methods in order to implement the public \s-1API\s0 described above.
.IP "\fBinit_plural_to_singular_function\fR" 4
.IX Item "init_plural_to_singular_function"
Override this method and return a reference to a function that takes a single string as an argument and returns a singular version of that string.
.IP "\fBinit_singular_to_plural_function\fR" 4
.IX Item "init_singular_to_plural_function"
Override this method and return a reference to a function that takes a single string as an argument and returns a plural version of that string.
.SH "TIPS AND TRICKS"
.IX Header "TIPS AND TRICKS"
Much of the richness of a convention manager relies upon the quality of the singular_to_plural and plural_to_singular methods.  The default implementations are primitive at best.  For example,  singular_to_plural will not correctly form the plural of the word \*(L"alumnus\*(R".
.PP
One easy way to improve this is by setting a custom singular_to_plural_function.  Here's an example using the handy Lingua::EN::Inflect module:
.PP
.Vb 4
\&    package My::Product;
\&    ...
\&    use Lingua::EN::Inflect;
\&    $cm = _\|_PACKAGE_\|_\->meta\->convention_manager;
\&
\&    $cm\->singular_to_plural_function(\e&Lingua::EN::Inflect::PL);
\&
\&    print $cm\->singular_to_plural(\*(Aqperson\*(Aq); # "people"
.Ve
.PP
But that's a bit of a pain to do in every single class.  An easier way to do it for all of your classes is to make a new Rose::DB::Object::Metadata subclass that overrides the init_convention_manager method, then make a Rose::DB::Object\-derived base class that uses your new metadata class.  Example:
.PP
.Vb 1
\&    package My::DB::Metadata;
\&
\&    use Rose::DB::Object::Metadata;
\&    our @ISA = qw(Rose::DB::Object::Metadata);
\&
\&    use Lingua::EN::Inflect;
\&
\&    sub init_convention_manager
\&    {
\&      my $self = shift;
\&
\&      # Let the base class make ths convention manager object
\&      my $cm = $self\->SUPER::init_convention_manager(@_);
\&
\&      # Set the new singular\-to\-plural function
\&      $cm\->singular_to_plural_function(\e&Lingua::EN::Inflect::PL);
\&
\&      # Return the modified convention manager
\&      return $cm;
\&    }
\&
\&    ...
\&
\&    package My::DB::Object;
\&
\&    use My::DB::Metadata;
\&
\&    use Rose::DB::Object;
\&    our @ISA = qw(Rose::DB::Object); 
\&
\&    sub meta_class { \*(AqMy::DB::Metadata\*(Aq }
\&
\&    ...
\&
\&    package My::Person;
\&
\&    use My::DB::Object;
\&    our @ISA = qw(My::DB::Object); 
\&
\&    # The big pay\-off: smart plurals!
\&    print _\|_PACKAGE_\|_\->meta\->table; # "people"
.Ve
.PP
You might wonder why I don't use Lingua::EN::Inflect in Rose::DB::Object::ConventionManager to save you this effort.  The answer is that the Lingua::EN::Inflect module adds almost a megabyte of memory overhead on my system.  I'd rather not incur that overhead just for the sake of being more clever about naming conventions.  Furthermore, as primitive as the default plural-forming is, at least it's deterministic.  Guessing what Lingua::EN::Inflect will return is not always easy, and the results can change depending on which version Lingua::EN::Inflect you have installed.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
Here's a complete example of nearly all of the major features of Rose::DB::Object::ConventionManager.  Let's start with the database schema.  (This example uses PostgreSQL, but any supported database with native foreign key support will work.)
.PP
.Vb 5
\&  CREATE TABLE vendors
\&  (
\&    id    SERIAL NOT NULL PRIMARY KEY,
\&    name  VARCHAR(255)
\&  );
\&
\&  CREATE TABLE colors
\&  (
\&    code  CHAR(3) NOT NULL PRIMARY KEY,
\&    name  VARCHAR(255)
\&  );
\&
\&  CREATE TABLE products
\&  (
\&    id        SERIAL NOT NULL PRIMARY KEY,
\&    name      VARCHAR(255),
\&    vendor_id INT NOT NULL REFERENCES vendors (id)
\&  );
\&
\&  CREATE TABLE prices
\&  (
\&    price_id    SERIAL NOT NULL PRIMARY KEY,
\&    product_id  INT NOT NULL REFERENCES products (id),
\&    region      CHAR(2) NOT NULL DEFAULT \*(AqUS\*(Aq,
\&    price       DECIMAL(10,2) NOT NULL
\&  );
\&
\&  CREATE TABLE product_colors
\&  (
\&    id           SERIAL NOT NULL PRIMARY KEY,
\&    product_id   INT NOT NULL REFERENCES products (id),
\&    color_code   CHAR(3) NOT NULL REFERENCES colors (code)
\&  );
.Ve
.PP
Now the classes:
.PP
.Vb 2
\&  # Rose::DB subclass to handle the db connection
\&  package My::DB;
\&
\&  use base \*(AqRose::DB\*(Aq;
\&
\&  My::DB\->register_db
\&  (
\&    type     => \*(Aqdefault\*(Aq,
\&    domain   => \*(Aqdefault\*(Aq,
\&    driver   => \*(AqPg\*(Aq,
\&    database => \*(Aqtest\*(Aq,
\&    username => \*(Aqpostgres\*(Aq,
\&  );
\&
\&  ...
\&
\&  # Common Rose::DB::Object\-derived base class for the other objects
\&  package My::Object;
\&
\&  use My::DB;
\&
\&  use base \*(AqRose::DB::Object\*(Aq;
\&
\&  sub init_db { My::DB\->new }
\&
\&  ...
\&
\&  package My::Price;
\&
\&  use base \*(AqMy::Object\*(Aq;
\&
\&  _\|_PACKAGE_\|_\->meta\->setup
\&  (
\&    columns =>
\&    [
\&      price_id   => { type => \*(Aqserial\*(Aq, not_null => 1 },
\&      product_id => { type => \*(Aqint\*(Aq },
\&      region     => { type => \*(Aqchar\*(Aq, length => 2, default => \*(AqUS\*(Aq },
\&      price      => { type => \*(Aqdecimal\*(Aq, precision => 10, scale => 2 },
\&    ],
\&
\&    foreign_keys => [ \*(Aqproduct\*(Aq ],
\&  );
\&
\&  ...
\&
\&  package My::Vendor;
\&
\&  use base \*(AqMy::Object\*(Aq;
\&
\&  _\|_PACKAGE_\|_\->meta\->setup
\&  (
\&    columns =>
\&    [
\&      id    => { type => \*(Aqserial\*(Aq, not_null => 1 },
\&      name  => { type => \*(Aqvarchar\*(Aq, length => 255 },
\&    ],
\&  );
\&
\&  ...
\&
\&  package My::Color;
\&
\&  use base \*(AqMy::Object\*(Aq;
\&
\&  _\|_PACKAGE_\|_\->meta\->setup
\&  (
\&    columns =>
\&    [
\&      code => { type => \*(Aqchar\*(Aq, length => 3, not_null => 1 },
\&      name => { type => \*(Aqvarchar\*(Aq, length => 255 },
\&    ],
\&  );
\&
\&  ...
\&
\&  package My::Product;
\&
\&  use base \*(AqMy::Object\*(Aq;
\&
\&  _\|_PACKAGE_\|_\->meta\->setup
\&  (
\&    columns =>
\&    [
\&      id        => { type => \*(Aqserial\*(Aq, not_null => 1 },
\&      name      => { type => \*(Aqvarchar\*(Aq, length => 255 },
\&      vendor_id => { type => \*(Aqint\*(Aq },
\&    ],
\&
\&    foreign_keys => [ \*(Aqvendor\*(Aq ],
\&
\&    relationships =>
\&    [
\&      prices => { type => \*(Aqone to many\*(Aq },
\&      colors => { type => \*(Aqmany to many\*(Aq },
\&    ],
\&  );
\&
\&  ...
\&
\&  package My::ProductColors;
\&
\&  use base \*(AqMy::Object\*(Aq;
\&
\&  _\|_PACKAGE_\|_\->meta\->setup
\&  (
\&    columns      => [ qw(id product_id color_code) ],
\&    foreign_keys => [ \*(Aqproduct\*(Aq, \*(Aqcolor\*(Aq ],
\&  );
.Ve
.PP
Let's add some data:
.PP
.Vb 2
\&  INSERT INTO vendors (id, name) VALUES (1, \*(AqV1\*(Aq);
\&  INSERT INTO vendors (id, name) VALUES (2, \*(AqV2\*(Aq);
\&
\&  INSERT INTO products (id, name, vendor_id) VALUES (1, \*(AqA\*(Aq, 1);
\&  INSERT INTO products (id, name, vendor_id) VALUES (2, \*(AqB\*(Aq, 2);
\&  INSERT INTO products (id, name, vendor_id) VALUES (3, \*(AqC\*(Aq, 1);
\&
\&  INSERT INTO prices (product_id, region, price) VALUES (1, \*(AqUS\*(Aq, 1.23);
\&  INSERT INTO prices (product_id, region, price) VALUES (1, \*(AqDE\*(Aq, 4.56);
\&  INSERT INTO prices (product_id, region, price) VALUES (2, \*(AqUS\*(Aq, 5.55);
\&  INSERT INTO prices (product_id, region, price) VALUES (3, \*(AqUS\*(Aq, 5.78);
\&  INSERT INTO prices (product_id, region, price) VALUES (3, \*(AqUS\*(Aq, 9.99);
\&
\&  INSERT INTO colors (code, name) VALUES (\*(AqCC1\*(Aq, \*(Aqred\*(Aq);
\&  INSERT INTO colors (code, name) VALUES (\*(AqCC2\*(Aq, \*(Aqgreen\*(Aq);
\&  INSERT INTO colors (code, name) VALUES (\*(AqCC3\*(Aq, \*(Aqblue\*(Aq);
\&  INSERT INTO colors (code, name) VALUES (\*(AqCC4\*(Aq, \*(Aqpink\*(Aq);
\&
\&  INSERT INTO product_colors (product_id, color_code) VALUES (1, \*(AqCC1\*(Aq);
\&  INSERT INTO product_colors (product_id, color_code) VALUES (1, \*(AqCC2\*(Aq);
\&
\&  INSERT INTO product_colors (product_id, color_code) VALUES (2, \*(AqCC4\*(Aq);
\&
\&  INSERT INTO product_colors (product_id, color_code) VALUES (3, \*(AqCC2\*(Aq);
\&  INSERT INTO product_colors (product_id, color_code) VALUES (3, \*(AqCC3\*(Aq);
.Ve
.PP
(Be aware that not all databases are smart enough to track explicitly setting serial column values as shown in the \s-1INSERT\s0 statements above.  Subsequent auto-generated serial values may conflict with the explicitly set serial column values already in the table.  Values are set explicitly here to make the examples easier to follow.  In \*(L"real\*(R" code, you should let the serial columns populate automatically.)
.PP
Finally, the classes in action:
.PP
.Vb 1
\&  $p = My::Product\->new(id => 1)\->load;
\&
\&  print $p\->vendor\->name, "\en"; # "V1"
\&
\&  # "US: 1.23, DE: 4.56"
\&  print join(\*(Aq, \*(Aq, map { $_\->region .\*(Aq: \*(Aq. $_\->price } $p\->prices), "\en";
\&
\&  # "red, green"
\&  print join(\*(Aq, \*(Aq, map { $_\->name } $p\->colors), "\en";
.Ve
.SH "AUTO-INIT EXAMPLE"
.IX Header "AUTO-INIT EXAMPLE"
Using Rose::DB::Object's auto-initialization feature, the Perl code can be reduced to an  absurd degree.  Given the same database schema and data shown in the example above, consider the following classes:
.PP
.Vb 4
\&  package My::Auto::Color;
\&  use base \*(AqMy::Object\*(Aq;
\&  _\|_PACKAGE_\|_\->meta\->auto_initialize;
\&  ...
\&
\&  package My::Auto::Price;
\&  use base \*(AqMy::Object\*(Aq;
\&  _\|_PACKAGE_\|_\->meta\->auto_initialize;
\&  ...
\&
\&  package My::Auto::ProductColors;
\&  use base \*(AqMy::Object\*(Aq;
\&  _\|_PACKAGE_\|_\->meta\->auto_initialize;
\&  ...
\&
\&  package My::Auto::Vendor;
\&  use base \*(AqMy::Object\*(Aq;
\&  _\|_PACKAGE_\|_\->meta\->auto_initialize;
\&  ...
\&
\&  package My::Auto::Product;
\&  use base \*(AqMy::Object\*(Aq;
\&  _\|_PACKAGE_\|_\->meta\->auto_initialize;
.Ve
.PP
Not a single table, column, foreign key, or relationship is specified, yet everything still works:
.PP
.Vb 1
\&  $p = My::Auto::Product\->new(id => 1)\->load;
\&
\&  print $p\->vendor\->name, "\en"; # "V1"
\&
\&  # "US: 1.23, DE: 4.56"
\&  print join(\*(Aq, \*(Aq, map { $_\->region .\*(Aq: \*(Aq. $_\->price } $p\->prices), "\en";
\&
\&  # "red, green"
\&  print join(\*(Aq, \*(Aq, map { $_\->name } $p\->colors), "\en";
.Ve
.PP
More precisely, everything still works \fIprovided\fR that you load all the of the related modules.  For example, if you load \f(CW\*(C`My::Auto::Product\*(C'\fR but don't load \f(CW\*(C`My::Auto::Price\*(C'\fR (either from within the \f(CW\*(C`My::Auto::Product\*(C'\fR class or in your program itself), then the \f(CW\*(C`My::Auto::Product\*(C'\fR will not have a \f(CW\*(C`prices()\*(C'\fR method (since your program will have no knowledge of the \f(CW\*(C`My::Auto::Price\*(C'\fR class).  Use the loader if you want to set up a bunch of related classes automatically without worrying about this kind of thing.
.PP
Anyway, I don't recommend this kind of extreme approach, but it is an effective demonstration of the power of the convention manager.
.SH "AUTHOR"
.IX Header "AUTHOR"
John C. Siracusa (siracusa@gmail.com)
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2010 by John C. Siracusa.  All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same terms
as Perl itself.
