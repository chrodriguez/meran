.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Rose::DB::Object::Metadata 3"
.TH Rose::DB::Object::Metadata 3 "2011-01-20" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Rose::DB::Object::Metadata \- Database object metadata.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Rose::DB::Object::Metadata;
\&
\&  $meta = Rose::DB::Object::Metadata\->new(class => \*(AqProduct\*(Aq);
\&  # ...or...
\&  $meta = Rose::DB::Object::Metadata\->for_class(\*(AqProduct\*(Aq);
\&
\&  #
\&  # Auto\-initialization
\&  #
\&
\&  $meta\->table(\*(Aqproducts\*(Aq); # optional if class name ends with "::Product"
\&  $meta\->auto_initialize;
\&
\&  #
\&  # ...or manual setup
\&  #
\&
\&  $meta\->setup
\&  (
\&    table => \*(Aqproducts\*(Aq,
\&
\&    columns =>
\&    [
\&      id          => { type => \*(Aqint\*(Aq, primary_key => 1 },
\&      name        => { type => \*(Aqvarchar\*(Aq, length => 255 },
\&      description => { type => \*(Aqtext\*(Aq },
\&      category_id => { type => \*(Aqint\*(Aq },
\&
\&      status => 
\&      {
\&        type      => \*(Aqvarchar\*(Aq, 
\&        check_in  => [ \*(Aqactive\*(Aq, \*(Aqinactive\*(Aq ],
\&        default   => \*(Aqinactive\*(Aq,
\&      },
\&
\&      start_date  => { type => \*(Aqdatetime\*(Aq },
\&      end_date    => { type => \*(Aqdatetime\*(Aq },
\&
\&      date_created  => { type => \*(Aqtimestamp\*(Aq, default => \*(Aqnow\*(Aq },  
\&      last_modified => { type => \*(Aqtimestamp\*(Aq, default => \*(Aqnow\*(Aq },
\&    ],
\&
\&    unique_key => \*(Aqname\*(Aq,
\&
\&    foreign_keys =>
\&    [
\&      category =>
\&      {
\&        class       => \*(AqCategory\*(Aq,
\&        key_columns =>
\&        {
\&          category_id => \*(Aqid\*(Aq,
\&        }
\&      },
\&    ],
\&
\&    relationships =>
\&    [
\&      prices =>
\&      {
\&        type       => \*(Aqone to many\*(Aq,
\&        class      => \*(AqPrice\*(Aq,
\&        column_map => { id => \*(Aqid_product\*(Aq },
\&      },
\&    ],
\&  );
\&
\&  #
\&  # ...or even more verbose manual setup (old\-style, not recommended)
\&  #
\&
\&  $meta\->table(\*(Aqproducts\*(Aq);
\&
\&  $meta\->columns
\&  (
\&    id          => { type => \*(Aqint\*(Aq, primary_key => 1 },
\&    name        => { type => \*(Aqvarchar\*(Aq, length => 255 },
\&    description => { type => \*(Aqtext\*(Aq },
\&    category_id => { type => \*(Aqint\*(Aq },
\&
\&    status => 
\&    {
\&      type      => \*(Aqvarchar\*(Aq, 
\&      check_in  => [ \*(Aqactive\*(Aq, \*(Aqinactive\*(Aq ],
\&      default   => \*(Aqinactive\*(Aq,
\&    },
\&
\&    start_date  => { type => \*(Aqdatetime\*(Aq },
\&    end_date    => { type => \*(Aqdatetime\*(Aq },
\&
\&    date_created  => { type => \*(Aqtimestamp\*(Aq, default => \*(Aqnow\*(Aq },  
\&    last_modified => { type => \*(Aqtimestamp\*(Aq, default => \*(Aqnow\*(Aq },
\&  );
\&
\&  $meta\->unique_key(\*(Aqname\*(Aq);
\&
\&  $meta\->foreign_keys
\&  (
\&    category =>
\&    {
\&      class       => \*(AqCategory\*(Aq,
\&      key_columns =>
\&      {
\&        category_id => \*(Aqid\*(Aq,
\&      }
\&    },
\&  );
\&
\&  $meta\->relationships
\&  (
\&    prices =>
\&    {
\&      type       => \*(Aqone to many\*(Aq,
\&      class      => \*(AqPrice\*(Aq,
\&      column_map => { id => \*(Aqid_product\*(Aq },
\&    },
\&  );
\&
\&  ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Rose::DB::Object::Metadata objects store information about a single table in a database: the name of the table, the names and types of columns, any foreign or unique keys, etc.  These metadata objects are also responsible for supplying information to, and creating object methods for, the Rose::DB::Object\-derived objects to which they belong.
.PP
Rose::DB::Object::Metadata objects also store information about the Rose::DB::Objects that front the database tables they describe.  What might normally be thought of as \*(L"class data\*(R" for the Rose::DB::Object is stored in the metadata object instead, in order to keep the method namespace of the Rose::DB::Object\-derived class uncluttered.
.PP
Rose::DB::Object::Metadata objects objects are per-class singletons; there is one Rose::DB::Object::Metadata object for each Rose::DB::Object\-derived class.  Metadata objects are almost never explicitly instantiated.  Rather, there are automatically created and accessed through Rose::DB::Object\-derived objects' meta method.
.PP
Once created, metadata objects can be populated manually or automatically.  Both techniques are shown in the synopsis above.  The automatic mode works by asking the database itself for the information.  There are some caveats to this approach.  See the auto-initialization section for more information.
.PP
Rose::DB::Object::Metadata objects contain three categories of objects that are responsible for creating object methods in Rose::DB::Object\-derived classes: columns, foreign keys, and relationships.
.PP
Column objects are subclasses of Rose::DB::Object::Metadata::Column.  They are intended to store as much information as possible about each column.  The particular class of the column object created for a database column is determined by a mapping table.   The column class, in turn, is responsible for creating the accessor/mutator method(s) for the column.  When it creates these methods, the column class can use (or ignore) any information stored in the column object.
.PP
Foreign key objects are of the class Rose::DB::Object::Metadata::ForeignKey.  They store information about columns that refer to columns in other tables that are fronted by their own Rose::DB::Object\-derived classes.  A foreign key object is responsible for creating accessor method(s) to fetch the foreign object from the foreign table.
.PP
Relationship objects are subclasses of Rose::DB::Object::Metadata::Relationship.  They store information about a table's relationship to other tables that are fronted by their own Rose::DB::Object\-derived classes.  The particular class of the relationship object created for each relationship is determined by a mapping table.   A relationship object is responsible for creating accessor method(s) to fetch the foreign objects from the foreign table.
.SH "AUTO-INITIALIZATION"
.IX Header "AUTO-INITIALIZATION"
Manual population of metadata objects can be tedious and repetitive.  Nearly all of the information stored in a Rose::DB::Object::Metadata object exists in the database in some form.  It's reasonable to consider simply extracting this information from the database itself, rather than entering it all manually.  This automatic metadata extraction and subsequent Rose::DB::Object::Metadata object population is called \*(L"auto-initialization.\*(R"
.PP
The example of auto-initialization in the synopsis above is the most succinct variant:
.PP
.Vb 1
\&    $meta\->auto_initialize;
.Ve
.PP
As you can read in the documentation for the auto_initialize method, that's shorthand for individually auto-initializing each part of the metadata object: columns, the primary key, unique keys, and foreign keys.  But this brevity comes at a price.  There are many caveats to auto-initialization.
.SS "Caveats"
.IX Subsection "Caveats"
\fIStart-Up Cost\fR
.IX Subsection "Start-Up Cost"
.PP
In order to retrieve the information required for auto-initialization, a database connection must be opened and queries must be run.  Sometimes these queries include complex joins.  All of these queries must be successfully completed before the Rose::DB::Object\-derived objects that the Rose::DB::Object::Metadata is associated with can be used.
.PP
In an environment like mod_perl, server start-up time is precisely when you want to do any expensive operations.  But in a command-line script or other short-lived process, the overhead of auto-initializing many metadata objects may become prohibitive.
.PP
Also, don't forget that auto-initialization requires a database connection.  Rose::DB::Object\-derived objects can sometimes be useful even without a database connection (e.g., to temporarily store information that will never go into the database, or to synthesize data using object methods that have no corresponding database column).  When using auto-initialization, this is not possible because the  Rose::DB::Object\-derived class won't even load if auto-initialization fails because it could not connect to the database.
.PP
\fIDetail\fR
.IX Subsection "Detail"
.PP
First, auto-initialization cannot generate information that exists only in the mind of the programmer.  The most common example is a relationship between two database tables that is either ambiguous or totally unexpressed by the database itself.
.PP
For example, if a foreign key constraint does not exist, the relationship between rows in two different tables cannot be extracted from the database, and therefore cannot be auto-initialized.
.PP
Even within the realm of information that, by all rights, should be available in the database, there are limitations.  Although there is a handy \s-1DBI\s0 \s-1API\s0 for extracting metadata from databases, unfortunately, very few \s-1DBI\s0 drivers support it fully.  Some don't support it at all.  In almost all cases, some manual work is required to (often painfully) extract information from the database's \*(L"system tables\*(R" or \*(L"catalog.\*(R"
.PP
More troublingly, databases do not always provide all the metadata that a human could extract from the series of \s-1SQL\s0 statement that created the table in the first place.  Sometimes, the information just isn't in the database to be extracted, having been lost in the process of table creation.  Here's just one example.  Consider this MySQL table definition:
.PP
.Vb 8
\&    CREATE TABLE mytable
\&    (
\&      id    INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
\&      code  CHAR(6),
\&      flag  BOOLEAN NOT NULL DEFAULT 1,
\&      bits  BIT(5) NOT NULL DEFAULT \*(Aq00101\*(Aq,
\&      name  VARCHAR(64)
\&    );
.Ve
.PP
Now look at the metadata that MySQL 4 stores internally for this table:
.PP
.Vb 10
\&    mysql> describe mytable;
\&    +\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    | Field | Type             | Null | Key | Default | Extra          |
\&    +\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    | id    | int(10) unsigned |      | PRI | NULL    | auto_increment |
\&    | code  | varchar(6)       | YES  |     | NULL    |                |
\&    | flag  | tinyint(1)       |      |     | 1       |                |
\&    | bits  | tinyint(1)       |      |     | 101     |                |
\&    | name  | varchar(64)      | YES  |     | NULL    |                |
\&    +\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.PP
Note the following divergences from the \*(L"\s-1CREATE\s0 \s-1TABLE\s0\*(R" statement.
.IP "\(bu" 4
\&\fBThe \*(L"code\*(R" column has changed from \s-1\f(BICHAR\s0\fB\|(6) to \s-1\f(BIVARCHAR\s0\fB\|(6).\fR  This is troublesome if you want the traditional semantics of a \s-1CHAR\s0 type, namely the padding with spaces of values that are less than the column length.
.IP "\(bu" 4
\&\fBThe \*(L"flag\*(R" column has changed from \s-1BOOLEAN\s0 to \s-1\f(BITINYINT\s0\fB\|(1).\fR  The default accessor method created for boolean columns has value coercion and formatting properties that are important to this data type.  The default accessor created for integer columns lacks these constraints.  The metadata object has no way of knowing that \*(L"flag\*(R" was supposed to be a boolean column, and thus makes the wrong kind of accessor method.  It is thus possible to store, say, a value of \*(L"7\*(R" in the \*(L"flag\*(R" column.  Oops.
.IP "\(bu" 4
\&\fBThe \*(L"bits\*(R" column has changed from \s-1\f(BIBIT\s0\fB\|(5) to \s-1\f(BITINYINT\s0\fB\|(1).\fR  As in the case of the \*(L"flag\*(R" column above, this type change prevents the correct accessor method from being created.  The default bitfield accessor method auto-inflates column values into Bit::Vector objects, which provide convenient methods for bit manipulation.  The default accessor created for integer columns does no such thing.
.PP
Remember that the auto-initialization process can only consider the metadata actually stored in the database.  It has no access to the original \*(L"create table\*(R" statement.  Thus, the semantics implied by the original table definition are effectively lost.
.PP
Again, this is just one example of the kind of detail that can be lost in the process of converting your table definition into metadata that is stored in the database.  Admittedly, MySQL is perhaps the worst case-scenario, having a well-deserved reputation for disregarding the wishes of table definitions.  (The use of implicit default values for \*(L"\s-1NOT\s0 \s-1NULL\s0\*(R" columns is yet another example.)
.PP
Thankfully, there is a solution to this dilemma.  Remember that auto-initialization is actually a multi-step process hiding behind that single call to the auto_initialize method.  To correct the sins of the database, simply break the auto-initialization process into its components.  For example, here's how to correctly auto-initialize the \*(L"mytable\*(R" example above:
.PP
.Vb 2
\&    # Make a first pass at column setup
\&    $meta\->auto_init_columns;
\&
\&    # Account for inaccuracies in DBD::mysql\*(Aqs column info by
\&    # replacing incorrect column definitions with new ones.
\&
\&    # Fix CHAR(6) column that shows up as VARCHAR(6) 
\&    $meta\->column(code => { type => \*(Aqchar\*(Aq, length => 6 });
\&
\&    # Fix BIT(5) column that shows up as TINYINT(1)
\&    $meta\->column(bits => { type => \*(Aqbits\*(Aq, bits => 5, default => 101 });
\&
\&    # Fix BOOLEAN column that shows up as TINYINT(1)
\&    $meta\->column(flag => { type => \*(Aqboolean\*(Aq, default => 1 });
\&
\&    # Do everything else
\&    $meta\->auto_initialize;
.Ve
.PP
Note that auto_initialize was called at the end.  Without the \f(CW\*(C`replace_existing\*(C'\fR parameter, this call will preserve any existing metadata, rather than overwriting it, so our \*(L"corrections\*(R" are safe.
.PP
\fIMaintenance\fR
.IX Subsection "Maintenance"
.PP
The price of auto-initialization is eternal vigilance.  \*(L"What does that mean?  Isn't auto-initialization supposed to save time and effort?\*(R"  Well, yes, but at a cost.  In addition to the caveats described above, consider what happens when a table definition changes.
.PP
\&\*(L"Ah ha!\*(R" you say, \*(L"My existing class will automatically pick up the changes the next time it's loaded!  Auto-initialization at its finest!\*(R"  But is it?  What if you added a \*(L"\s-1NOT\s0 \s-1NULL\s0\*(R" column with no default value?  Yes, your existing auto-initialized class will pick up the change, but your existing code will no longer be able to save one these objects.  Or what if you're using MySQL and your newly added column is one of the types described above that requires manual tweaking in order to get the desired semantics.  Will you always remember to make this change?
.PP
Auto-initialization is not a panacea.  Every time you make a change to your database schema, you must also revisit each affected Rose::DB::Object\-derived class to at least consider whether or not the metadata needs to be corrected or updated.
.PP
The trade-off may be well worth it, but it's still something to think about.  There is, however, a hybrid solution that might be even better.  Continue on to the next section to learn more.
.SS "Code Generation"
.IX Subsection "Code Generation"
As described in the section above, auto-initializing metadata at runtime by querying the database has many caveats.  An alternate approach is to query the database for metadata just once, and then generate the equivalent Perl code which can be pasted directly into the class definition in place of the call to auto_initialize.
.PP
Like the auto-initialization process itself, perl code generation has a convenient wrapper method as well as separate methods for the individual parts.  All of the perl code generation methods begin with \*(L"perl_\*(R", and they support some rudimentary code formatting options to help the code conform to you preferred style.  Examples can be found with the documentation for each perl_* method.
.PP
This hybrid approach to metadata population strikes a good balance between upfront effort and ongoing maintenance.  Auto-generating the Perl code for the initial class definition saves a lot of tedious typing.  From that point on, manually correcting and maintaining the definition is a small price to pay for the decreased start-up cost, the ability to use the class in the absence of a database connection, and the piece of mind that comes from knowing that your class is stable, and won't change behind your back in response to an \*(L"action at a distance\*(R" (i.e., a database schema update).
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.IP "\fBauto_prime_caches [\s-1BOOL\s0]\fR" 4
.IX Item "auto_prime_caches [BOOL]"
Get or set a boolean value that indicates whether or not the prime_caches method will be called from within the initialize method.  The default is true if the \f(CW\*(C`MOD_PERL\*(C'\fR environment variable (\f(CW$ENV{\*(AqMOD_PERL\*(Aq}\fR) is set to a true value, false otherwise.
.IP "\fBclear_all_dbs\fR" 4
.IX Item "clear_all_dbs"
Clears the db attribute of the metadata object for each registered class.
.IP "\fBcolumn_type_class \s-1TYPE\s0 [, \s-1CLASS\s0]\fR" 4
.IX Item "column_type_class TYPE [, CLASS]"
Given the column type string \s-1TYPE\s0, return the name of the Rose::DB::Object::Metadata::Column\-derived class used to store metadata and create the accessor method(s) for columns of that type.  If a \s-1CLASS\s0 is passed, the column type \s-1TYPE\s0 is mapped to \s-1CLASS\s0.  In both cases, the \s-1TYPE\s0 argument is automatically converted to lowercase.
.IP "\fBcolumn_type_classes [\s-1MAP\s0]\fR" 4
.IX Item "column_type_classes [MAP]"
Get or set the hash that maps column type strings to the names of the Rose::DB::Object::Metadata::Column\-derived classes used to store metadata  and create accessor method(s) for columns of that type.
.Sp
This hash is class data.  If you want to modify it, I suggest making your own subclass of Rose::DB::Object::Metadata and then setting that as the meta_class of your Rose::DB::Object subclass.
.Sp
If passed \s-1MAP\s0 (a list of type/class pairs or a reference to a hash of the same) then \s-1MAP\s0 replaces the current column type mapping.  Returns a list of type/class pairs (in list context) or a reference to the hash of type/class mappings (in scalar context).
.Sp
The default mapping of type names to class names is:
.Sp
.Vb 1
\&  scalar    => Rose::DB::Object::Metadata::Column::Scalar
\&
\&  char      => Rose::DB::Object::Metadata::Column::Character
\&  character => Rose::DB::Object::Metadata::Column::Character
\&  varchar   => Rose::DB::Object::Metadata::Column::Varchar
\&  string    => Rose::DB::Object::Metadata::Column::Varchar
\&
\&  text      => Rose::DB::Object::Metadata::Column::Text
\&  blob      => Rose::DB::Object::Metadata::Column::Blob
\&  bytea     => Rose::DB::Object::Metadata::Column::Pg::Bytea
\&
\&  bits      => Rose::DB::Object::Metadata::Column::Bitfield
\&  bitfield  => Rose::DB::Object::Metadata::Column::Bitfield
\&
\&  bool      => Rose::DB::Object::Metadata::Column::Boolean
\&  boolean   => Rose::DB::Object::Metadata::Column::Boolean
\&
\&  int       => Rose::DB::Object::Metadata::Column::Integer
\&  integer   => Rose::DB::Object::Metadata::Column::Integer
\&
\&  tinyint   => Rose::DB::Object::Metadata::Column::Integer
\&  smallint  => Rose::DB::Object::Metadata::Column::Integer
\&  mediumint => Rose::DB::Object::Metadata::Column::Integer
\&
\&  serial    => Rose::DB::Object::Metadata::Column::Serial
\&  bigserial => Rose::DB::Object::Metadata::Column::BigSerial
\&
\&  enum      => Rose::DB::Object::Metadata::Column::Enum
\&
\&  num       => Rose::DB::Object::Metadata::Column::Numeric
\&  numeric   => Rose::DB::Object::Metadata::Column::Numeric
\&  decimal   => Rose::DB::Object::Metadata::Column::Numeric
\&  float     => Rose::DB::Object::Metadata::Column::Float
\&  float8    => Rose::DB::Object::Metadata::Column::DoublePrecision
\&
\&  \*(Aqdouble precision\*(Aq =>
\&    Rose::DB::Object::Metadata::Column::DoublePrecision
\&
\&  time      => Rose::DB::Object::Metadata::Column::Time
\&  interval  => Rose::DB::Object::Metadata::Column::Interval
\&
\&  date      => Rose::DB::Object::Metadata::Column::Date
\&  datetime  => Rose::DB::Object::Metadata::Column::Datetime
\&  timestamp => Rose::DB::Object::Metadata::Column::Timestamp
\&
\&  timestamptz =>
\&    Rose::DB::Object::Metadata::Column::TimestampWithTimeZone
\&
\&  \*(Aqtimestamp with time zone\*(Aq =>
\&    Rose::DB::Object::Metadata::Column::TimestampWithTimeZone
\&
\&  \*(Aqdatetime year to fraction\*(Aq => 
\&    Rose::DB::Object::Metadata::Column::DatetimeYearToFraction
\&
\&  \*(Aqdatetime year to fraction(1)\*(Aq =>
\&    Rose::DB::Object::Metadata::Column::DatetimeYearToFraction1
\&
\&  \*(Aqdatetime year to fraction(2)\*(Aq =>
\&    Rose::DB::Object::Metadata::Column::DatetimeYearToFraction2
\&
\&  \*(Aqdatetime year to fraction(3)\*(Aq =>
\&    Rose::DB::Object::Metadata::Column::DatetimeYearToFraction3
\&
\&  \*(Aqdatetime year to fraction(4)\*(Aq =>
\&    Rose::DB::Object::Metadata::Column::DatetimeYearToFraction4
\&
\&  \*(Aqdatetime year to fraction(5)\*(Aq =>
\&    Rose::DB::Object::Metadata::Column::DatetimeYearToFraction5
\&
\&  \*(Aqtimestamp with time zone\*(Aq =>
\&    Rose::DB::Object::Metadata::Column::Timestamp
\&
\&  \*(Aqtimestamp without time zone\*(Aq =>
\&    Rose::DB::Object::Metadata::Column::Timestamp
\&
\&  \*(Aqdatetime year to second\*(Aq =>
\&    Rose::DB::Object::Metadata::Column::DatetimeYearToSecond
\&
\&  \*(Aqdatetime year to minute\*(Aq =>
\&    Rose::DB::Object::Metadata::Column::DatetimeYearToMinute
\&
\&  \*(Aqdatetime year to month\*(Aq =>
\&    Rose::DB::Object::Metadata::Column::DatetimeYearToMonth
\&
\&  \*(Aqepoch\*(Aq       => Rose::DB::Object::Metadata::Column::Epoch
\&  \*(Aqepoch hires\*(Aq => Rose::DB::Object::Metadata::Column::Epoch::HiRes
\&
\&  array     => Rose::DB::Object::Metadata::Column::Array
\&  set       => Rose::DB::Object::Metadata::Column::Set
\&
\&  chkpass   => Rose::DB::Object::Metadata::Column::Pg::Chkpass
.Ve
.IP "\fBcolumn_type_names\fR" 4
.IX Item "column_type_names"
Returns the list (in list context) or reference to an array (in scalar context) of registered column type names.
.IP "\fBconvention_manager_class \s-1NAME\s0 [, \s-1CLASS\s0]\fR" 4
.IX Item "convention_manager_class NAME [, CLASS]"
Given the string \s-1NAME\s0, return the name of the Rose::DB::Object::ConventionManager\-derived class mapped to that name.
.Sp
If a \s-1CLASS\s0 is passed, then \s-1NAME\s0 is mapped to \s-1CLASS\s0.
.IP "\fBconvention_manager_classes [\s-1MAP\s0]\fR" 4
.IX Item "convention_manager_classes [MAP]"
Get or set the hash that maps names to Rose::DB::Object::ConventionManager\-derived class names.
.Sp
This hash is class data.  If you want to modify it, I suggest making your own subclass of Rose::DB::Object::Metadata and then setting that as the meta_class of your Rose::DB::Object subclass.
.Sp
If passed \s-1MAP\s0 (a list of name/class pairs or a reference to a hash of the same) then \s-1MAP\s0 replaces the current mapping.  Returns a list of name/class pairs (in list context) or a reference to the hash of name/class mappings (in scalar context).
.Sp
The default mapping of names to classes is:
.Sp
.Vb 2
\&  default => Rose::DB::Object::ConventionManager
\&  null    => Rose::DB::Object::ConventionManager::Null
.Ve
.IP "\fBdbi_prepare_cached [\s-1BOOL\s0]\fR" 4
.IX Item "dbi_prepare_cached [BOOL]"
Get or set a boolean value that indicates whether or not the Rose::DB::Object\-derived class will use \s-1DBI\s0's prepare_cached method by default (instead of the prepare method) when loading, saving, and deleting objects.  The default value is true.
.IP "\fBdefault_column_undef_overrides_default [\s-1BOOL\s0]\fR" 4
.IX Item "default_column_undef_overrides_default [BOOL]"
Get or set the default value of the column_undef_overrides_default attribute.  Defaults to undef.
.IP "\fBdefault_manager_base_class [\s-1CLASS\s0]\fR" 4
.IX Item "default_manager_base_class [CLASS]"
Get or set the default name of the base class used by this metadata class when generating a manager classes.  The default value is \f(CW\*(C`Rose::DB::Object::Manager\*(C'\fR.  See the \f(CW\*(C`default_manager_base_class()\*(C'\fR object method to override this value for a specific metadata object.
.IP "\fBfor_class \s-1CLASS\s0\fR" 4
.IX Item "for_class CLASS"
Returns (or creates, if needed) the single Rose::DB::Object::Metadata object associated with \s-1CLASS\s0, where \s-1CLASS\s0 is the name of a Rose::DB::Object\-derived class.
.IP "\fBinit_column_name_to_method_name_mapper\fR" 4
.IX Item "init_column_name_to_method_name_mapper"
This class method should return a reference to a subroutine that maps column names to method names, or false if it does not want to do any custom mapping.  The default implementation returns zero (0).
.Sp
If defined, the subroutine should take four arguments: the metadata object, the column name, the column method type, and the method name that would be used if the mapper subroutine did not exist.  It should return a method name.
.IP "\fBprime_all_caches [\s-1PARAMS\s0]\fR" 4
.IX Item "prime_all_caches [PARAMS]"
Call prime_caches on all registered_classes, passing \s-1PARAMS\s0 to each call.  \s-1PARAMS\s0 are name/value pairs.  Valid parameters are:
.RS 4
.IP "\fBdb \s-1DB\s0\fR" 4
.IX Item "db DB"
A Rose::DB\-derived object used to determine which data source the cached metadata will be generated on behalf of.  (Each data source has its own set of cached metadata.)  This parameter is optional.  If it is not passed, then the Rose::DB\-derived object returned by the init_db method for each class will be used instead.
.RE
.RS 4
.RE
.IP "\fBrelationship_type_class \s-1TYPE\s0\fR" 4
.IX Item "relationship_type_class TYPE"
Given the relationship type string \s-1TYPE\s0, return the name of the Rose::DB::Object::Metadata::Relationship\-derived class used to store metadata and create the accessor method(s) for relationships of that type.
.IP "\fBrelationship_type_classes [\s-1MAP\s0]\fR" 4
.IX Item "relationship_type_classes [MAP]"
Get or set the hash that maps relationship type strings to the names of the Rose::DB::Object::Metadata::Relationship\-derived classes used to store metadata and create object methods fetch and/or manipulate objects from foreign tables.
.Sp
This hash is class data.  If you want to modify it, I suggest making your own subclass of Rose::DB::Object::Metadata and then setting that as the meta_class of your Rose::DB::Object subclass.
.Sp
If passed \s-1MAP\s0 (a list of type/class pairs or a reference to a hash of the same) then \s-1MAP\s0 replaces the current relationship type mapping.  Returns a list of type/class pairs (in list context) or a reference to the hash of type/class mappings (in scalar context).
.Sp
The default mapping of type names to class names is:
.Sp
.Vb 4
\&  \*(Aqone to one\*(Aq   => Rose::DB::Object::Metadata::Relationship::OneToOne
\&  \*(Aqone to many\*(Aq  => Rose::DB::Object::Metadata::Relationship::OneToMany
\&  \*(Aqmany to one\*(Aq  => Rose::DB::Object::Metadata::Relationship::ManyToOne
\&  \*(Aqmany to many\*(Aq => Rose::DB::Object::Metadata::Relationship::ManyToMany
.Ve
.IP "\fBregistered_classes\fR" 4
.IX Item "registered_classes"
Return a list (in list context) or reference to an array (in scalar context) of the names of all Rose::DB::Object\-derived classes registered under this metadata class's registry_key.
.IP "\fBregistry_key\fR" 4
.IX Item "registry_key"
Returns the string used to group Rose::DB::Object\-derived class names in the class registry.  The default is \*(L"Rose::DB::Object::Metadata\*(R".
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "\fBnew \s-1PARAMS\s0\fR" 4
.IX Item "new PARAMS"
Returns (or creates, if needed) the single Rose::DB::Object::Metadata associated with a particular Rose::DB::Object\-derived class, modifying or initializing it according to \s-1PARAMS\s0, where \s-1PARAMS\s0 are name/value pairs.
.Sp
Any object method is a valid parameter name, but \s-1PARAMS\s0 \fImust\fR include a value for the \f(CW\*(C`class\*(C'\fR parameter, since that's how Rose::DB::Object::Metadata objects are mapped to their corresponding Rose::DB::Object\-derived class.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.IP "\fBadd_column \s-1ARGS\s0\fR" 4
.IX Item "add_column ARGS"
This is an alias for the add_columns method.
.IP "\fBadd_columns \s-1ARGS\s0\fR" 4
.IX Item "add_columns ARGS"
Add the columns specified by \s-1ARGS\s0 to the list of columns for the table.  Returns the list of columns added in list context, or a reference to an array of columns added in scalar context.  Columns can be specified in \s-1ARGS\s0 in several ways.
.Sp
If an argument is a subclass of Rose::DB::Object::Metadata::Column, it is added as-is.
.Sp
If an argument is a plain scalar, it is taken as the name of a scalar column.  A column object of the class returned by the method call \f(CW\*(C`$obj\->column_type_class(\*(Aqscalar\*(Aq)\*(C'\fR is constructed and then added.
.Sp
Otherwise, only name/value pairs are considered, where the name is taken as the column name and the value must be a reference to a hash.
.Sp
If the hash contains the key \*(L"primary_key\*(R" with a true value, then the column is marked as a primary_key_member and the column name is added to the list of primary key columns by calling the add_primary_key_column method with the column name as its argument.
.Sp
If the hash contains the key \*(L"alias\*(R", then the value of that key is used as the alias for the column.  This is a shorthand equivalent to explicitly calling the alias_column column method.
.Sp
If the hash contains the key \*(L"temp\*(R" and its value is true, then the column is actually added to the list of non-persistent columns.
.Sp
If the hash contains a key with the same name as a column trigger event type (e.g., \*(L"on_set\*(R", \*(L"on_load\*(R", \*(L"inflate\*(R") then the value of that key must be a code reference or a reference to an array of code references, which will be added to the list of the column's triggers for the specified event type.
.Sp
If the hash contains the key \*(L"methods\*(R", then its value must be a reference to an array or a reference to a hash.  The auto_method_types of the column are then set to the values of the referenced array, or the keys of the referenced hash.  The values of the referenced hash are used to set the method_name for their corresponding method types.
.Sp
If the hash contains the key \*(L"add_methods\*(R", then its value must be a reference to an array or a reference to a hash.  The values of the referenced array or the keys of the referenced hash are added to the column's auto_method_types.  The values of the referenced hash are used to set the method_name for their corresponding method types.
.Sp
If the \*(L"methods\*(R" and \*(L"add_methods\*(R" keys are both set, a fatal error will occur.
.Sp
Then the column_type_class method is called with the value of the \*(L"type\*(R" hash key as its argument (or \*(L"scalar\*(R" if that key is missing), returning the name of a column class.  Finally, a new column object of that class is constructed and is passed all the remaining pairs in the hash reference, along with the name and type of the column.  That column object is then added to the list of columns.
.Sp
This is done until there are no more arguments to be processed, or until an argument does not conform to one of the required formats, in which case a fatal error occurs.
.Sp
Example:
.Sp
.Vb 4
\&    $meta\->add_columns
\&    (
\&      # Add a scalar column
\&      \*(Aqname\*(Aq, 
\&
\&      # which is roughly equivalent to:
\&      #
\&      # $class = $meta\->column_type_class(\*(Aqscalar\*(Aq);
\&      # $col = $class\->new(name => \*(Aqname\*(Aq);
\&      # (then add $col to the list of columns)
\&
\&      # Add by name/hashref pair with explicit method types
\&      age => { type => \*(Aqint\*(Aq, default => 5, methods => [ \*(Aqget\*(Aq, \*(Aqset\*(Aq ] },
\&
\&      # which is roughly equivalent to:
\&      #
\&      # $class = $meta\->column_type_class(\*(Aqint\*(Aq);
\&      # $col = $class\->new(name    => \*(Aqage\*(Aq,
\&      #                    type    => \*(Aqint\*(Aq, 
\&      #                    default => 5);
\&      # $col\->auto_method_types(\*(Aqget\*(Aq, \*(Aqset\*(Aq);
\&      # (then add $col to the list of columns)
\&
\&      # Add by name/hashref pair with additional method type and name
\&      size => { type => \*(Aqint\*(Aq, add_methods => { \*(Aqset\*(Aq => \*(Aqset_my_size\*(Aq } },
\&
\&      # which is roughly equivalent to:
\&      #
\&      # $class = $meta\->column_type_class(\*(Aqint\*(Aq);
\&      # $col = $class\->new(name    => \*(Aqsize\*(Aq,
\&      #                    type    => \*(Aqint\*(Aq,);
\&      # $col\->add_auto_method_types(\*(Aqset\*(Aq);
\&      # $col\->method_name(set => \*(Aqset_my_size\*(Aq);
\&      # (then add $col to the list of columns)
\&
\&      # Add a column object directly
\&      Rose::DB::Object::Metadata::Column::Date\->new(
\&        name => \*(Aqstart_date\*(Aq),
\&    );
.Ve
.IP "\fBadd_nonpersistent_column \s-1ARGS\s0\fR" 4
.IX Item "add_nonpersistent_column ARGS"
This is an alias for the add_nonpersistent_columns method.
.IP "\fBadd_nonpersistent_columns \s-1ARGS\s0\fR" 4
.IX Item "add_nonpersistent_columns ARGS"
This method behaves like the add_columns method, except that it adds to the list of non-persistent columns.  See the documentation for the nonpersistent_columns method for more information.
.IP "\fBadd_foreign_keys \s-1ARGS\s0\fR" 4
.IX Item "add_foreign_keys ARGS"
Add foreign keys as specified by \s-1ARGS\s0.  Each foreign key must have a name that is unique among all other foreign keys in this class.
.Sp
Foreign keys can be specified in \s-1ARGS\s0 in several ways.
.Sp
If an argument is a Rose::DB::Object::Metadata::ForeignKey object (or subclass thereof), it is added as-is.
.Sp
Otherwise, only name/value pairs are considered, where the name is taken as the foreign key name and the value must be a reference to a hash.
.Sp
If the hash contains the key \*(L"methods\*(R", then its value must be a reference to an array or a reference to a hash.  The auto_method_types of the foreign key are then set to the values of the referenced array, or the keys of the referenced hash.  The values of the referenced hash are used to set the method_name for their corresponding method types.
.Sp
If the hash contains the key \*(L"add_methods\*(R", then its value must be a reference to an array or a reference to a hash.  The values of the referenced array or the keys of the referenced hash are added to the foreign key's auto_method_types.  The values of the referenced hash are used to set the method_name for their corresponding method types.
.Sp
If the \*(L"methods\*(R" and \*(L"add_methods\*(R" keys are both set, a fatal error will occur.
.Sp
A new Rose::DB::Object::Metadata::ForeignKey object is constructed and is passed all the remaining pairs in the hash reference, along with the name of the foreign key as the value of the \*(L"name\*(R" parameter.  That foreign key object is then added to the list of foreign keys.
.Sp
This is done until there are no more arguments to be processed, or until an argument does not conform to one of the required formats, in which case a fatal error occurs.
.Sp
Example:
.Sp
.Vb 9
\&    $meta\->add_foreign_keys
\&    (      
\&      # Add by name/hashref pair with explicit method type
\&      category => 
\&      {
\&        class       => \*(AqCategory\*(Aq, 
\&        key_columns => { category_id => \*(Aqid\*(Aq },
\&        methods => [ \*(Aqget\*(Aq ],
\&      },
\&
\&      # which is roughly equivalent to:
\&      #
\&      # $fk = Rose::DB::Object::Metadata::ForeignKey\->new(
\&      #         class       => \*(AqCategory\*(Aq, 
\&      #         key_columns => { category_id => \*(Aqid\*(Aq },
\&      #         name        => \*(Aqcategory\*(Aq);
\&      # $fk\->auto_method_types(\*(Aqget\*(Aq);
\&      # (then add $fk to the list of foreign keys)
\&
\&      # Add by name/hashref pair with additional method type and name
\&      color => 
\&      {
\&        class       => \*(AqColor\*(Aq, 
\&        key_columns => { color_id => \*(Aqid\*(Aq },
\&        add_methods => { set => \*(Aqset_my_color\*(Aq },
\&      },
\&
\&      # which is roughly equivalent to:
\&      #
\&      # $fk = Rose::DB::Object::Metadata::ForeignKey\->new(
\&      #         class       => \*(AqColor\*(Aq, 
\&      #         key_columns => { color_id => \*(Aqid\*(Aq },
\&      #         name        => \*(Aqcolor\*(Aq);
\&      # $fk\->add_auto_method_types(\*(Aqset\*(Aq);
\&      # $fk\->method_name(set => \*(Aqset_my_color\*(Aq);
\&      # (then add $fk to the list of foreign keys)
\&
\&      # Add a foreign key object directly
\&      Rose::DB::Object::Metadata::ForeignKey\->new(...),
\&    );
.Ve
.Sp
For each foreign key added, a corresponding relationship with the same name is added if it does not already exist.  The relationship type is determined by the value of the foreign key object's relationship attribute.  The default is \*(L"many to one\*(R".  The class of the relationship is chosen by calling relationship_type_class with the relationship type as an argument.
.IP "\fBadd_primary_key_column \s-1COLUMN\s0\fR" 4
.IX Item "add_primary_key_column COLUMN"
This method is an alias for add_primary_key_columns.
.IP "\fBadd_primary_key_columns \s-1COLUMNS\s0\fR" 4
.IX Item "add_primary_key_columns COLUMNS"
Add \s-1COLUMNS\s0 to the list of columns that make up the primary key.  \s-1COLUMNS\s0 can be a list or reference to an array of column names.
.IP "\fBadd_relationship \s-1ARGS\s0\fR" 4
.IX Item "add_relationship ARGS"
This is an alias for the add_relationships method.
.IP "\fBadd_relationships \s-1ARGS\s0\fR" 4
.IX Item "add_relationships ARGS"
Add relationships as specified by \s-1ARGS\s0.  Each relationship must have a name that is unique among all other relationships in this class.
.Sp
Relationships can be specified in \s-1ARGS\s0 in several ways.
.Sp
If an argument is a subclass of Rose::DB::Object::Metadata::Relationship, it is added as-is.
.Sp
Otherwise, only name/value pairs are considered, where the name is taken as the relationship name and the value must be a reference to a hash.
.Sp
If the hash contains the key \*(L"methods\*(R", then its value must be a reference to an array or a reference to a hash.  The auto_method_types of the relationship are then set to the values of the referenced array, or the keys of the referenced hash.  The values of the referenced hash are used to set the method_name for their corresponding method types.
.Sp
If the hash contains the key \*(L"add_methods\*(R", then its value must be a reference to an array or a reference to a hash.  The values of the referenced array or the keys of the referenced hash are added to the relationship's auto_method_types.  The values of the referenced hash are used to set the method_name for their corresponding method types.
.Sp
If the \*(L"methods\*(R" and \*(L"add_methods\*(R" keys are both set, a fatal error will occur.
.Sp
Then the relationship_type_class method is called with the value of the \f(CW\*(C`type\*(C'\fR hash key as its argument, returning the name of a relationship class.
.Sp
Finally, a new relationship object of that class is constructed and is passed all the remaining pairs in the hash reference, along with the name and type of the relationship.  That relationship object is then added to the list of relationships.
.Sp
This is done until there are no more arguments to be processed, or until an argument does not conform to one of the required formats, in which case a fatal error occurs.
.Sp
Example:
.Sp
.Vb 10
\&    $meta\->add_relationships
\&    (      
\&      # Add by name/hashref pair with explicit method type
\&      category => 
\&      {
\&        type       => \*(Aqmany to one\*(Aq,
\&        class      => \*(AqCategory\*(Aq, 
\&        column_map => { category_id => \*(Aqid\*(Aq },
\&        methods    => [ \*(Aqget\*(Aq ],
\&      },
\&
\&      # which is roughly equivalent to:
\&      #
\&      # $class = $meta\->relationship_type_class(\*(Aqmany to one\*(Aq);
\&      # $rel = $class\->new(class      => \*(AqCategory\*(Aq, 
\&      #                    column_map => { category_id => \*(Aqid\*(Aq },
\&      #                    name       => \*(Aqcategory\*(Aq);
\&      # $rel\->auto_method_types(\*(Aqget\*(Aq);
\&      # (then add $rel to the list of relationships)
\&
\&      # Add by name/hashref pair with additional method type and name
\&      color => 
\&      {
\&        type        => \*(Aqmany to one\*(Aq,
\&        class       => \*(AqColor\*(Aq, 
\&        column_map  => { color_id => \*(Aqid\*(Aq },
\&        add_methods => { set => \*(Aqset_my_color\*(Aq },
\&      },
\&
\&      # which is roughly equivalent to:
\&      #
\&      # $class = $meta\->relationship_type_class(\*(Aqmany to one\*(Aq);
\&      # $rel = $class\->new(class      => \*(AqColor\*(Aq, 
\&      #                    column_map => { color_id => \*(Aqid\*(Aq },
\&      #                    name       => \*(Aqcolor\*(Aq);
\&      # $rel\->add_auto_method_types(\*(Aqset\*(Aq);
\&      # $fk\->method_name(set => \*(Aqset_my_color\*(Aq);
\&      # (rel add $fk to the list of foreign keys)
\&
\&      # Add a relationship object directly
\&      Rose::DB::Object::Metadata::Relationship::OneToOne\->new(...),
\&    );
.Ve
.IP "\fBadd_unique_key \s-1KEY\s0\fR" 4
.IX Item "add_unique_key KEY"
This method is an alias for add_unique_keys.
.IP "\fBadd_unique_keys \s-1KEYS\s0\fR" 4
.IX Item "add_unique_keys KEYS"
Add new unique keys specified by \s-1KEYS\s0.  Unique keys can be specified in \s-1KEYS\s0 in two ways.
.Sp
If an argument is a Rose::DB::Object::Metadata::UniqueKey object (or subclass thereof), then its parent is set to the metadata object itself, and it is added.
.Sp
Otherwise, an argument must be a single column name or a reference to an array of column names that make up a unique key.  A new Rose::DB::Object::Metadata::UniqueKey is created, with its parent set to the metadata object itself, and then the unique key object is added to this list of unique keys for this class.
.IP "\fBalias_column \s-1NAME\s0, \s-1ALIAS\s0\fR" 4
.IX Item "alias_column NAME, ALIAS"
Set the alias for the column named \s-1NAME\s0 to \s-1ALIAS\s0.  It is sometimes necessary to use an alias for a column because the column name conflicts with an existing Rose::DB::Object method name.
.Sp
For example, imagine a column named \*(L"save\*(R".  The Rose::DB::Object \s-1API\s0 already defines a method named save, so obviously that name can't be used for the accessor method for the \*(L"save\*(R" column.  To solve this, make an alias:
.Sp
.Vb 1
\&    $meta\->alias_column(save => \*(Aqsave_flag\*(Aq);
.Ve
.Sp
See the Rose::DB::Object documentation or call the method_name_is_reserved method to determine if a method name is reserved.
.IP "\fBallow_inline_column_values [\s-1BOOL\s0]\fR" 4
.IX Item "allow_inline_column_values [BOOL]"
Get or set the boolean flag that indicates whether or not the associated Rose::DB::Object\-derived class should try to inline column values that \s-1DBI\s0 does not handle correctly when they are bound to placeholders using bind_columns.  The default value is false.
.Sp
Enabling this flag reduces the performance of the update and insert operations on the Rose::DB::Object\-derived object.  But it is sometimes necessary to enable the flag because some \s-1DBI\s0 drivers do not (or cannot) always do the right thing when binding values to placeholders in \s-1SQL\s0 statements.  For example, consider the following \s-1SQL\s0 for the Informix database:
.Sp
.Vb 2
\&    CREATE TABLE test (d DATETIME YEAR TO SECOND);
\&    INSERT INTO test (d) VALUES (CURRENT);
.Ve
.Sp
This is valid Informix \s-1SQL\s0 and will insert a row with the current date and time into the \*(L"test\*(R" table.
.Sp
Now consider the following attempt to do the same thing using \s-1DBI\s0 placeholders (assume the table was already created as per the \s-1CREATE\s0 \s-1TABLE\s0 statement above):
.Sp
.Vb 2
\&    $sth = $dbh\->prepare(\*(AqINSERT INTO test (d) VALUES (?)\*(Aq);
\&    $sth\->execute(\*(AqCURRENT\*(Aq); # Error!
.Ve
.Sp
What you'll end up with is an error like this:
.Sp
.Vb 2
\&    DBD::Informix::st execute failed: SQL: \-1262: Non\-numeric 
\&    character in datetime or interval.
.Ve
.Sp
In other words, DBD::Informix has tried to quote the string \*(L"\s-1CURRENT\s0\*(R", which has special meaning to Informix only when it is not quoted.
.Sp
In order to make this work, the value \*(L"\s-1CURRENT\s0\*(R" must be \*(L"inlined\*(R" rather than bound to a placeholder when it is the value of a \*(L"\s-1DATETIME\s0 \s-1YEAR\s0 \s-1TO\s0 \s-1SECOND\s0\*(R" column in an Informix database.
.IP "\fBauto_load_related_classes [\s-1BOOL\s0]\fR" 4
.IX Item "auto_load_related_classes [BOOL]"
Get or set a flag that indicates whether or not classes related to this class through a foreign key or other relationship will be automatically loaded when this class is initialized.  The default value is true.
.IP "\fBcached_objects_expire_in [\s-1DURATION\s0]\fR" 4
.IX Item "cached_objects_expire_in [DURATION]"
This method is only applicable if this metadata object is associated with a Rose::DB::Object::Cached\-derived class.  It simply calls the class method of the same name that belongs to the Rose::DB::Object::Cached\-derived class associated with this metadata object.
.IP "\fBcatalog [\s-1CATALOG\s0]\fR" 4
.IX Item "catalog [CATALOG]"
Get or set the database catalog for this class.  This setting will \fBoverride\fR any setting in the db object.  Use this method only if you know that the class will always point to a specific catalog, regardless of what the Rose::DB\-derived database handle object specifies.
.IP "\fBclass [\s-1CLASS\s0]\fR" 4
.IX Item "class [CLASS]"
Get or set the Rose::DB::Object\-derived class associated with this metadata object.  This is the class where the accessor methods for each column will be created (by make_methods).
.IP "\fBclass_for \s-1PARAMS\s0\fR" 4
.IX Item "class_for PARAMS"
Returns the name of the Rose::DB::Object\-derived class associated with the \f(CW\*(C`catalog\*(C'\fR, \f(CW\*(C`schema\*(C'\fR, and \f(CW\*(C`table\*(C'\fR specified by the name/value paris in \s-1PARAMS\s0.  Catalog and/or schema maybe omitted if unknown or inapplicable, and the \*(L"best\*(R" match will be returned.  Returns undef if there is no class name registered under the specified \s-1PARAMS\s0.
.Sp
Note: This method may also be called as a class method, but may require explicit \f(CW\*(C`catalog\*(C'\fR and/or \f(CW\*(C`schema\*(C'\fR arguments when dealing with databases that support these concepts \fIand\fR have default implicit values for them.
.IP "\fBclear_object_cache\fR" 4
.IX Item "clear_object_cache"
This method is only applicable if this metadata object is associated with a Rose::DB::Object::Cached\-derived class.  It simply calls the class method of the same name that belongs to the Rose::DB::Object::Cached\-derived class associated with this metadata object.
.IP "\fBcolumn \s-1NAME\s0 [, \s-1COLUMN\s0 | \s-1HASHREF\s0]\fR" 4
.IX Item "column NAME [, COLUMN | HASHREF]"
Get or set the column named \s-1NAME\s0.  If just \s-1NAME\s0 is passed, the Rose::DB::Object::Metadata::Column\-derived column object for the column of that name is returned.  If no such column exists, undef is returned.
.Sp
If both \s-1NAME\s0 and \s-1COLUMN\s0 are passed, then \s-1COLUMN\s0 must be a Rose::DB::Object::Metadata::Column\-derived object.  \s-1COLUMN\s0 has its name set to \s-1NAME\s0, and is then stored as the column metadata object for \s-1NAME\s0, replacing any existing column.
.Sp
If both \s-1NAME\s0 and \s-1HASHREF\s0 are passed, then the combination of \s-1NAME\s0 and \s-1HASHREF\s0 must form a name/value pair suitable for passing to the add_columns method.  The new column specified by \s-1NAME\s0 and \s-1HASHREF\s0 replaces any existing column.
.IP "\fBcolumns [\s-1ARGS\s0]\fR" 4
.IX Item "columns [ARGS]"
Get or set the full list of columns.  If \s-1ARGS\s0 are passed, the column list is cleared and then \s-1ARGS\s0 are passed to the add_columns method.
.Sp
Returns a list of column objects in list context, or a reference to an array of column objects in scalar context.
.IP "\fBcolumn_accessor_method_name \s-1NAME\s0\fR" 4
.IX Item "column_accessor_method_name NAME"
Returns the name of the \*(L"get\*(R" method for the column named \s-1NAME\s0.  This is just a shortcut for \f(CW\*(C`$meta\->column(NAME)\->accessor_method_name\*(C'\fR.
.IP "\fBcolumn_accessor_method_names\fR" 4
.IX Item "column_accessor_method_names"
Returns a list (in list context) or a reference to the array (in scalar context) of the names of the \*(L"set\*(R" methods for all the columns, in the order that the columns are returned by column_names.
.IP "\fBcolumn_aliases [\s-1MAP\s0]\fR" 4
.IX Item "column_aliases [MAP]"
Get or set the hash that maps column names to their aliases.  If passed \s-1MAP\s0 (a list of name/value pairs or a reference to a hash) then \s-1MAP\s0 replaces the current alias mapping.  Returns a reference to the hash that maps column names to their aliases.
.Sp
Note that modifying this map has no effect if initialize, make_methods, or make_column_methods has already been called for the current class.
.IP "\fBcolumn_mutator_method_name \s-1NAME\s0\fR" 4
.IX Item "column_mutator_method_name NAME"
Returns the name of the \*(L"set\*(R" method for the column named \s-1NAME\s0.  This is just a shortcut for \f(CW\*(C`$meta\->column(NAME)\->mutator_method_name\*(C'\fR.
.IP "\fBcolumn_mutator_method_names\fR" 4
.IX Item "column_mutator_method_names"
Returns a list (in list context) or a reference to the array (in scalar context) of the names of the \*(L"set\*(R" methods for all the columns, in the order that the columns are returned by column_names.
.IP "\fBcolumn_names\fR" 4
.IX Item "column_names"
Returns a list (in list context) or a reference to an array (in scalar context) of column names.
.IP "\fBcolumn_name_to_method_name_mapper [\s-1CODEREF\s0]\fR" 4
.IX Item "column_name_to_method_name_mapper [CODEREF]"
Get or set the code reference to the subroutine used to map column names to  method names.  If undefined, then the init_column_name_to_method_name_mapper class method is called in order to initialize it.  If still undefined or false, then the \*(L"default\*(R" method name is used.
.Sp
If defined, the subroutine should take four arguments: the metadata object, the column name, the column method type, and the method name that would be used if the mapper subroutine did not exist.  It should return a method name.
.IP "\fBcolumn_rw_method_name \s-1NAME\s0\fR" 4
.IX Item "column_rw_method_name NAME"
Returns the name of the \*(L"get_set\*(R" method for the column named \s-1NAME\s0.  This is just a shortcut for \f(CW\*(C`$meta\->column(NAME)\->rw_method_name\*(C'\fR.
.IP "\fBcolumn_rw_method_names\fR" 4
.IX Item "column_rw_method_names"
Returns a list (in list context) or a reference to the array (in scalar context) of the names of the \*(L"get_set\*(R" methods for all the columns, in the order that the columns are returned by column_names.
.IP "\fBcolumn_undef_overrides_default [\s-1BOOL\s0]\fR" 4
.IX Item "column_undef_overrides_default [BOOL]"
Get or set a boolean value that influences the default value of the undef_overrides_default attribute for each column in this class.  See the documentation for Rose::DB::Object::Metadata::Column's undef_overrides_default attribute for more information.
.Sp
Defaults to the value returned by the default_column_undef_overrides_default class method.
.IP "\fBconvention_manager [ \s-1OBJECT\s0 | \s-1CLASS\s0 | \s-1NAME\s0 ]\fR" 4
.IX Item "convention_manager [ OBJECT | CLASS | NAME ]"
Get or set the convention manager for this class.  Defaults to the return value of the init_convention_manager method.
.Sp
If undef is passed, then a Rose::DB::Object::ConventionManager::Null object is stored instead.
.Sp
If a Rose::DB::Object::ConventionManager\-derived object is passed, its meta attribute set to this metadata object and then it is used as the convention manager for this class.
.Sp
If a Rose::DB::Object::ConventionManager\-derived class name is passed, a new object of that class is created with its meta attribute set to this metadata object.  Then it is used as the convention manager for this class.
.Sp
If a convention manager name is passed, then the corresponding class is looked up in the convention manager class map, a new object of that class is constructed, its meta attribute set to this metadata object, and it is used as the convention manager for this class.  If there is no class mapped to \s-1NAME\s0, a fatal error will occur.
.Sp
See the Rose::DB::Object::ConventionManager documentation for more information on convention managers.
.IP "\fBdb\fR" 4
.IX Item "db"
Returns the Rose::DB\-derived object associated with this metadata object's class.  A fatal error will occur if class is undefined or if the Rose::DB object could not be created.
.IP "\fBdefault_cascade_save [\s-1BOOL\s0]\fR" 4
.IX Item "default_cascade_save [BOOL]"
Get or set a boolean value that indicates whether or not the class associated with this metadata object will save related objects when the parent object is saved.  See the documentation for Rose::DB::Object's \fIsave()\fR method for details.  The default value is false.
.IP "\fBdefault_load_speculative [\s-1BOOL\s0]\fR" 4
.IX Item "default_load_speculative [BOOL]"
Get or set a boolean value that indicates whether or not the class associated with this metadata object will load speculatively by default.  See the documentation for Rose::DB::Object's \fIload()\fR method for details.  The default value is false.
.IP "\fBdefault_update_changes_only [\s-1BOOL\s0]\fR" 4
.IX Item "default_update_changes_only [BOOL]"
Get or set a boolean value that indicates whether or not the class associated with this metadata object will update only an object's modified columns by default (instead of updating all columns).  See the documentation for Rose::DB::Object's \fIupdate()\fR method for details.  The default value is false.
.IP "\fBdelete_column \s-1NAME\s0\fR" 4
.IX Item "delete_column NAME"
Delete the column named \s-1NAME\s0.
.IP "\fBdelete_columns\fR" 4
.IX Item "delete_columns"
Delete all of the columns.
.IP "\fBdelete_column_type_class \s-1TYPE\s0\fR" 4
.IX Item "delete_column_type_class TYPE"
Delete the type/class mapping entry for the column type \s-1TYPE\s0.
.IP "\fBdelete_convention_manager_class \s-1NAME\s0\fR" 4
.IX Item "delete_convention_manager_class NAME"
Delete the name/class mapping entry for the convention manager class mapped to \s-1NAME\s0.
.IP "\fBdelete_nonpersistent_column \s-1NAME\s0\fR" 4
.IX Item "delete_nonpersistent_column NAME"
Delete the non-persistent column named \s-1NAME\s0.
.IP "\fBdelete_nonpersistent_columns\fR" 4
.IX Item "delete_nonpersistent_columns"
Delete all of the nonpersistent_columns.
.IP "\fBdelete_relationship \s-1NAME\s0\fR" 4
.IX Item "delete_relationship NAME"
Delete the relationship named \s-1NAME\s0.
.IP "\fBdelete_relationships\fR" 4
.IX Item "delete_relationships"
Delete all of the relationships.
.IP "\fBdelete_relationship_type_class \s-1TYPE\s0\fR" 4
.IX Item "delete_relationship_type_class TYPE"
Delete the type/class mapping entry for the relationship type \s-1TYPE\s0.
.IP "\fBdelete_unique_keys\fR" 4
.IX Item "delete_unique_keys"
Delete all of the unique key definitions.
.IP "\fBerror_mode [\s-1MODE\s0]\fR" 4
.IX Item "error_mode [MODE]"
Get or set the error mode of the Rose::DB::Object that fronts the table described by this Rose::DB::Object::Metadata object.  If the error mode is false, then it defaults to the return value of the \f(CW\*(C`init_error_mode\*(C'\fR method, which is \*(L"fatal\*(R" by default.
.Sp
The error mode determines what happens when a Rose::DB::Object method encounters an error.  The \*(L"return\*(R" error mode causes the methods to behave as described in the Rose::DB::Object documentation.  All other error modes cause an action to be performed before (possibly) returning as per the documentation (depending on whether or not the \*(L"action\*(R" is some variation on \*(L"throw an exception.\*(R")
.Sp
Valid values of \s-1MODE\s0 are:
.RS 4
.IP "carp" 4
.IX Item "carp"
Call Carp::carp with the value of the object error as an argument.
.IP "cluck" 4
.IX Item "cluck"
Call Carp::cluck with the value of the object error as an argument.
.IP "confess" 4
.IX Item "confess"
Call Carp::confess with the value of the object error as an argument.
.IP "croak" 4
.IX Item "croak"
Call Carp::croak with the value of the object error as an argument.
.IP "fatal" 4
.IX Item "fatal"
An alias for the \*(L"croak\*(R" mode.
.IP "return" 4
.IX Item "return"
Return a value that indicates that an error has occurred, as described in the documentation for each method.
.RE
.RS 4
.Sp
In all cases, the object's error attribute will also contain the error message.
.RE
.IP "\fBfirst_column\fR" 4
.IX Item "first_column"
Returns the first column, determined by the orider that columns were added, or undef if there are no columns.
.IP "\fBforeign_key \s-1NAME\s0 [, \s-1FOREIGNKEY\s0 | \s-1HASHREF\s0 ]\fR" 4
.IX Item "foreign_key NAME [, FOREIGNKEY | HASHREF ]"
Get or set the foreign key named \s-1NAME\s0.  \s-1NAME\s0 should be the name of the thing being referenced by the foreign key, \fInot\fR the name of any of the columns that make up the foreign key.  If called with just a \s-1NAME\s0 argument, the foreign key stored under that name is returned.  Undef is returned if there is no such foreign key.
.Sp
If both \s-1NAME\s0 and \s-1FOREIGNKEY\s0 are passed, then \s-1FOREIGNKEY\s0 must be a Rose::DB::Object::Metadata::ForeignKey\-derived object.  \s-1FOREIGNKEY\s0 has its name set to \s-1NAME\s0, and is then stored, replacing any existing foreign key with the same name.
.Sp
If both \s-1NAME\s0 and \s-1HASHREF\s0 are passed, then the combination of \s-1NAME\s0 and \s-1HASHREF\s0 must form a name/value pair suitable for passing to the add_foreign_keys method.  The new foreign key specified by \s-1NAME\s0 and \s-1HASHREF\s0 replaces any existing foreign key with the same name.
.IP "\fBforeign_keys [\s-1ARGS\s0]\fR" 4
.IX Item "foreign_keys [ARGS]"
Get or set the full list of foreign keys.  If \s-1ARGS\s0 are passed, the foreign key list is cleared and then \s-1ARGS\s0 are passed to the add_foreign_keys method.
.Sp
Returns a list of foreign key objects in list context, or a reference to an array of foreign key objects in scalar context.
.IP "\fBgenerate_primary_key_value \s-1DB\s0\fR" 4
.IX Item "generate_primary_key_value DB"
This method is the same as generate_primary_key_values except that it only returns the generated value for the first primary key column, rather than the entire list of values.  Use this method only when there is a single primary key column (or not at all).
.IP "\fBgenerate_primary_key_values \s-1DB\s0\fR" 4
.IX Item "generate_primary_key_values DB"
Given the Rose::DB\-derived object \s-1DB\s0, generate and return a list of new primary key column values for the table described by this metadata object.
.Sp
If a primary_key_generator is defined, it will be called (passed this metadata object and the \s-1DB\s0) and its value returned.
.Sp
If no primary_key_generator is defined, new primary key values will be generated, if possible, using the native facilities of the current database.  Note that this may not be possible for databases that auto-generate such values only after an insertion.  In that case, undef will be returned.
.IP "\fBinclude_predicated_unique_indexes [\s-1BOOL\s0]\fR" 4
.IX Item "include_predicated_unique_indexes [BOOL]"
Get or set a boolean value that indicates whether or not the auto_init_unique_keys method will create unique keys for unique indexes that have predicates.  The default value is false.  This feature is currently only supported for PostgreSQL.
.Sp
Here's an example of a unique index that has a predicate:
.Sp
.Vb 1
\&    CREATE UNIQUE INDEX my_idx ON mytable (mycolumn) WHERE mycolumn > 123;
.Ve
.Sp
The predicate in this case is \f(CW\*(C`WHERE mycolumn > 123\*(C'\fR.
.Sp
Predicated unique indexes differ semantically from unpredicated unique indexes in that predicates generally cause the index to only  apply to part of a table.  Rose::DB::Object expects unique indexes to uniquely identify a row within a table.  Predicated indexes that fail to do so due to their predicates should therefore not have Rose::DB::Object::Metadata::UniqueKey objects created for them, thus the false default for this attribute.
.IP "\fBinit_convention_manager\fR" 4
.IX Item "init_convention_manager"
Returns the default Rose::DB::Object::ConventionManager\-derived object used as the convention manager for this class.  This object will be of the class returned by convention_manager_class('default').
.Sp
Override this method in your Rose::DB::Object::Metadata subclass, or re-map the \*(L"default\*(R" convention manager class, in order to use a different convention manager class.  See the tips and tricks section of the Rose::DB::Object::ConventionManager documentation for an example of the subclassing approach.
.IP "\fBinitialize [\s-1ARGS\s0]\fR" 4
.IX Item "initialize [ARGS]"
Initialize the Rose::DB::Object\-derived class associated with this metadata object by creating accessor methods for each column and foreign key.  The table name and the primary_key_columns must be defined or a fatal error will occur.
.Sp
If any column name in the primary key or any of the unique keys does not exist in the list of columns, then that primary or unique key is deleted.  (As per the above, this will trigger a fatal error if any column in the primary key is not in the column list.)
.Sp
\&\s-1ARGS\s0, if any, are passed to the call to make_methods that actually creates the methods.
.Sp
If auto_prime_caches is true, then the prime_caches method will be called at the end of the initialization process.
.IP "\fBis_initialized [\s-1BOOL\s0]\fR" 4
.IX Item "is_initialized [BOOL]"
Get or set a boolean value that indicates whether or not this class was initialized.  A successful call to the initialize method will automatically set this flag to true.
.IP "\fBmake_manager_class [\s-1PARAMS\s0 | \s-1CLASS\s0]\fR" 4
.IX Item "make_manager_class [PARAMS | CLASS]"
This method creates a Rose::DB::Object::Manager\-derived class to manage objects of this class.  To do so, it simply calls perl_manager_class, passing all arguments, and then evaluates the result.  See the perl_manager_class documentation for more information.
.IP "\fBmake_methods [\s-1ARGS\s0]\fR" 4
.IX Item "make_methods [ARGS]"
Create object methods in class for each column, foreign key, and relationship.  This is done by calling make_column_methods, make_nonpersistent_column_methods, make_foreign_key_methods, and make_relationship_methods, in that order.
.Sp
\&\s-1ARGS\s0 are name/value pairs which are passed on to the other \f(CW\*(C`make_*_methods\*(C'\fR calls.  They are all optional.  Valid \s-1ARGS\s0 are:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`preserve_existing\*(C'\fR
.Sp
If set to a true value, a method will not be created if there is already an existing method with the same named.
.IP "\(bu" 4
\&\f(CW\*(C`replace_existing\*(C'\fR
.Sp
If set to a true value, override any existing method with the same name.
.RE
.RS 4
.Sp
In the absence of one of these parameters, any method name that conflicts with an existing method name will cause a fatal error.
.RE
.IP "\fBmake_column_methods [\s-1ARGS\s0]\fR" 4
.IX Item "make_column_methods [ARGS]"
Create accessor/mutator methods in class for each column.  \s-1ARGS\s0 are name/value pairs, and are all optional.  Valid \s-1ARGS\s0 are:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`preserve_existing\*(C'\fR
.Sp
If set to a true value, a method will not be created if there is already an existing method with the same named.
.IP "\(bu" 4
\&\f(CW\*(C`replace_existing\*(C'\fR
.Sp
If set to a true value, override any existing method with the same name.
.RE
.RS 4
.Sp
For each auto_method_type in each column, the method name is determined by passing the column name and the method type to method_name_from_column_name.  If the resulting method name is reserved (according to method_name_is_reserved, a fatal error will occur.  The object methods for each column are created by calling the column object's make_methods method.
.RE
.IP "\fBmake_foreign_key_methods [\s-1ARGS\s0]\fR" 4
.IX Item "make_foreign_key_methods [ARGS]"
Create object methods in class for each foreign key.  \s-1ARGS\s0 are name/value pairs, and are all optional.  Valid \s-1ARGS\s0 are:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`preserve_existing\*(C'\fR
.Sp
If set to a true value, a method will not be created if there is already an existing method with the same named.
.IP "\(bu" 4
\&\f(CW\*(C`replace_existing\*(C'\fR
.Sp
If set to a true value, override any existing method with the same name.
.RE
.RS 4
.Sp
For each auto_method_type in each foreign key, the method name is determined by passing the method type to the method_name method of the foreign key object, or the build_method_name_for_type method if the method_name call returns a false value.  If the method name is reserved (according to method_name_is_reserved), a fatal error will occur.  The object methods for each foreign key are created by calling the foreign key  object's make_methods method.
.Sp
Foreign keys and relationships with the type \*(L"one to one\*(R" or \*(L"many to one\*(R" both encapsulate essentially the same information.  They are kept in sync when this method is called by setting the foreign_key attribute of each "one to one\*(L" or \*(R"many to one" relationship object to be the corresponding foreign key object.
.RE
.IP "\fBmake_nonpersistent_column_methods [\s-1ARGS\s0]\fR" 4
.IX Item "make_nonpersistent_column_methods [ARGS]"
This method behaves like the make_column_methods method, except that it works with non-persistent columns.  See the documentation for the nonpersistent_columns method for more information on non-persistent columns.
.IP "\fBmake_relationship_methods [\s-1ARGS\s0]\fR" 4
.IX Item "make_relationship_methods [ARGS]"
Create object methods in class for each relationship.  \s-1ARGS\s0 are name/value pairs, and are all optional.  Valid \s-1ARGS\s0 are:
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`preserve_existing\*(C'\fR
.Sp
If set to a true value, a method will not be created if there is already an existing method with the same named.
.IP "\(bu" 4
\&\f(CW\*(C`replace_existing\*(C'\fR
.Sp
If set to a true value, override any existing method with the same name.
.RE
.RS 4
.Sp
For each auto_method_type in each relationship, the method name is determined by passing the method type to the method_name method of the relationship object, or the build_method_name_for_type method if the method_name call returns a false value.  If the method name is reserved (according to method_name_is_reserved), a fatal error will occur.  The object methods for each relationship are created by calling the relationship  object's make_methods method.
.Sp
Foreign keys and relationships with the type \*(L"one to one\*(R" or \*(L"many to one\*(R" both encapsulate essentially the same information.  They are kept in sync when this method is called by setting the foreign_key attribute of each "one to one\*(L" or \*(R"many to one" relationship object to be the corresponding foreign key object.
.Sp
If a relationship corresponds exactly to a foreign key, and that foreign key already made an object method, then the relationship is not asked to make its own method.
.RE
.IP "\fBdefault_manager_base_class [\s-1CLASS\s0]\fR" 4
.IX Item "default_manager_base_class [CLASS]"
Get or set the default name of the base class used by this specific metadata object when generating a manager class, using either the perl_manager_class or make_manager_class methods.  The default value is determined by the \f(CW\*(C`default_manager_base_class|/default_manager_base_class()\*(C'\fR class method.
.IP "\fBmethod_column \s-1METHOD\s0\fR" 4
.IX Item "method_column METHOD"
Returns the name of the column manipulated by the method named \s-1METHOD\s0.
.IP "\fBmethod_name_from_column_name \s-1NAME\s0, \s-1TYPE\s0\fR" 4
.IX Item "method_name_from_column_name NAME, TYPE"
Looks up the column named \s-1NAME\s0 and calls method_name_from_column with the column and \s-1TYPE\s0 as argument.  If no such column exists, a fatal error will occur.
.IP "\fBmethod_name_from_column \s-1COLUMN\s0, \s-1TYPE\s0\fR" 4
.IX Item "method_name_from_column COLUMN, TYPE"
Given a Rose::DB::Object::Metadata::Column\-derived column object and a column type name, return the corresponding method name that should be used for it.  Several entities are given an opportunity to determine the name.  They are consulted in the following order.
.RS 4
.IP "1. If a custom-defined column_name_to_method_name_mapper exists, then it is used to generate the method name and this name is returned." 4
.IX Item "1. If a custom-defined column_name_to_method_name_mapper exists, then it is used to generate the method name and this name is returned."
.PD 0
.IP "2. If a method name has been explicitly set, for this type in the column object itself, then this name is returned." 4
.IX Item "2. If a method name has been explicitly set, for this type in the column object itself, then this name is returned."
.IP "3. If the convention manager's auto_column_method_name method returns a defined value, then this name is returned." 4
.IX Item "3. If the convention manager's auto_column_method_name method returns a defined value, then this name is returned."
.IP "4. Otherwise, the default naming rules as defined in the column class itself are used." 4
.IX Item "4. Otherwise, the default naming rules as defined in the column class itself are used."
.RE
.RS 4
.RE
.IP "\fBmethod_name_is_reserved \s-1NAME\s0, \s-1CLASS\s0\fR" 4
.IX Item "method_name_is_reserved NAME, CLASS"
.PD
Given the method name \s-1NAME\s0 and the class name \s-1CLASS\s0, returns true if the method name is reserved (i.e., is used by the \s-1CLASS\s0 \s-1API\s0), false otherwise.
.IP "\fBnonpersistent_column \s-1NAME\s0 [, \s-1COLUMN\s0 | \s-1HASHREF\s0]\fR" 4
.IX Item "nonpersistent_column NAME [, COLUMN | HASHREF]"
This method behaves like the column method, except that it works with non-persistent columns.  See the documentation for the nonpersistent_columns method for more information on non-persistent columns.
.IP "\fBnonpersistent_columns [\s-1ARGS\s0]\fR" 4
.IX Item "nonpersistent_columns [ARGS]"
Get or set the full list of non-persistent columns.  If \s-1ARGS\s0 are passed, the non-persistent column list is cleared and then \s-1ARGS\s0 are passed to the add_nonpersistent_columns method.
.Sp
Returns a list of non-persistent column objects in list context, or a reference to an array of non-persistent column objects in scalar context.
.Sp
Non-persistent columns allow the creation of object attributes and associated accessor/mutator methods exactly like those associated with columns, but \fIwithout\fR ever sending any of these attributes to (or pulling any these attributes from) the database.
.Sp
Non-persistent columns are tracked entirely separately from columns.  Adding, deleting, and listing non-persistent columns has no affect on the list of normal (i.e., \*(L"persistent\*(R") columns.
.Sp
You cannot query the database (e.g., using Rose::DB::Object::Manager) and filter on a non-persistent column; non-persistent columns do not exist in the database.  This feature exists solely to leverage the method creation abilities of the various column classes.
.IP "\fBnonpersistent_column_accessor_method_name \s-1NAME\s0\fR" 4
.IX Item "nonpersistent_column_accessor_method_name NAME"
Returns the name of the \*(L"get\*(R" method for the non-persistent column named \s-1NAME\s0.  This is just a shortcut for \f(CW\*(C`$meta\->nonpersistent_column(NAME)\->accessor_method_name\*(C'\fR.
.IP "\fBnonpersistent_column_accessor_method_names\fR" 4
.IX Item "nonpersistent_column_accessor_method_names"
Returns a list (in list context) or a reference to the array (in scalar context) of the names of the \*(L"set\*(R" methods for all the non-persistent columns, in the order that the columns are returned by nonpersistent_column_names.
.IP "\fBnonpersistent_column_mutator_method_name \s-1NAME\s0\fR" 4
.IX Item "nonpersistent_column_mutator_method_name NAME"
Returns the name of the \*(L"set\*(R" method for the non-persistent column named \s-1NAME\s0.  This is just a shortcut for \f(CW\*(C`$meta\->nonpersistent_column(NAME)\->mutator_method_name\*(C'\fR.
.IP "\fBnonpersistent_column_mutator_method_names\fR" 4
.IX Item "nonpersistent_column_mutator_method_names"
Returns a list (in list context) or a reference to the array (in scalar context) of the names of the \*(L"set\*(R" methods for all the non-persistent columns, in the order that the columns are returned by nonpersistent_column_names.
.IP "\fBnonpersistent_column_names\fR" 4
.IX Item "nonpersistent_column_names"
Returns a list (in list context) or a reference to an array (in scalar context) of non-persistent column names.
.IP "\fBpk_columns [\s-1COLUMNS\s0]\fR" 4
.IX Item "pk_columns [COLUMNS]"
This is an alias for the primary_key_columns method.
.IP "\fBpost_init_hook [ \s-1CODEREF\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "post_init_hook [ CODEREF | ARRAYREF ]"
Get or set a reference to a subroutine or a reference to an array of code references that will be called just after the initialize method runs.  Each referenced subroutine will be passed the metadata object itself and any arguments passed to the call to initialize.
.IP "\fBpre_init_hook [ \s-1CODEREF\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "pre_init_hook [ CODEREF | ARRAYREF ]"
Get or set a reference to a subroutine or a reference to an array of code references that will be called just before the initialize method runs.  Each referenced subroutine will be passed the metadata object itself and any arguments passed to the call to initialize.
.IP "\fBprimary_key [\s-1PK\s0]\fR" 4
.IX Item "primary_key [PK]"
Get or set the Rose::DB::Object::Metadata::PrimaryKey object that stores the list of column names that make up the primary key for this table.
.IP "\fBprimary_key_columns [\s-1COLUMNS\s0]\fR" 4
.IX Item "primary_key_columns [COLUMNS]"
Get or set the list of of columns that make up the primary key.  \s-1COLUMNS\s0 should be a list of column names or Rose::DB::Object::Metadata::Column\-derived objects.
.Sp
Returns all of the columns that make up the primary key.  Each column is a Rose::DB::Object::Metadata::Column\-derived column object if a column object with the same name exists, or just the column name otherwise.  In scalar context, a reference to an array of columns is returned.  In list context, a list is returned.
.Sp
This method is just a shortcut for the code:
.Sp
.Vb 1
\&    $meta\->primary_key\->columns(...);
.Ve
.Sp
See the primary_key method and the Rose::DB::Object::Metadata::PrimaryKey class for more information.
.IP "\fBprimary_key_column_names [\s-1NAMES\s0]\fR" 4
.IX Item "primary_key_column_names [NAMES]"
Get or set the names of the columns that make up the table's primary key.  \s-1NAMES\s0 should be a list or reference to an array of column names.
.Sp
Returns the list of column names (in list context) or a reference to the array of column names (in scalar context).
.Sp
This method is just a shortcut for the code:
.Sp
.Vb 1
\&    $meta\->primary_key\->column_names(...);
.Ve
.Sp
See the primary_key method and the Rose::DB::Object::Metadata::PrimaryKey class for more information.
.IP "\fBprimary_key_generator [\s-1CODEREF\s0]\fR" 4
.IX Item "primary_key_generator [CODEREF]"
Get or set the subroutine used to generate new primary key values for the primary key columns of this table.  The subroutine will be passed two arguments: the current metadata object and the Rose::DB\-derived object that points to the current database.
.Sp
The subroutine is expected to return a list of values, one for each primary key column.  The values must be in the same order as the corresponding columns returned by primary_key_columns. (i.e., the first value belongs to the first column returned by primary_key_columns, the second value belongs to the second column, and so on.)
.IP "\fBprimary_key_sequence_names [\s-1NAMES\s0]\fR" 4
.IX Item "primary_key_sequence_names [NAMES]"
Get or set the list of database sequence names used to populate the primary key columns.  The sequence names must be in the same order as the primary_key_columns.  \s-1NAMES\s0 may be a list or reference to an array of sequence names.  Returns a list (in list context) or reference to the array (in scalar context) of sequence names.
.Sp
If you do not set this value, it will be derived for you based on the name of the primary key columns.  In the common case, you do not need to be concerned about this method.  If you are using the built-in \s-1SERIAL\s0 or \s-1AUTO_INCREMENT\s0 types in your database for your primary key columns, everything should just work.
.IP "\fBprime_caches [\s-1PARAMS\s0]\fR" 4
.IX Item "prime_caches [PARAMS]"
By default, secondary metadata derived from the attributes of this object is created and cached on demand.  Call this method to pre-cache this metadata all at once.  This method is useful when running in an environment like mod_perl where it's advantageous to load as much data as possible on start-up.
.Sp
\&\s-1PARAMS\s0 are name/value pairs.  Valid parameters are:
.RS 4
.IP "\fBdb \s-1DB\s0\fR" 4
.IX Item "db DB"
A Rose::DB\-derived object used to determine which data source the cached metadata will be generated on behalf of.  (Each data source has its own set of cached metadata.)  This parameter is optional.  If it is not passed, then the Rose::DB\-derived object returned by the init_db method for this class will be used instead.
.RE
.RS 4
.RE
.IP "\fBrelationship \s-1NAME\s0 [, \s-1RELATIONSHIP\s0 | \s-1HASHREF\s0]\fR" 4
.IX Item "relationship NAME [, RELATIONSHIP | HASHREF]"
Get or set the relationship named \s-1NAME\s0.  If just \s-1NAME\s0 is passed, the Rose::DB::Object::Metadata::Relationship\-derived relationship object for that \s-1NAME\s0 is returned.  If no such relationship exists, undef is returned.
.Sp
If both \s-1NAME\s0 and \s-1RELATIONSHIP\s0 are passed, then \s-1RELATIONSHIP\s0 must be a Rose::DB::Object::Metadata::Relationship\-derived object.  \s-1RELATIONSHIP\s0 has its name set to \s-1NAME\s0, and is then stored as the relationship metadata object for \s-1NAME\s0, replacing any existing relationship.
.Sp
If both \s-1NAME\s0 and \s-1HASHREF\s0 are passed, then the combination of \s-1NAME\s0 and \s-1HASHREF\s0 must form a name/value pair suitable for passing to the add_relationships method.  The new relationship specified by \s-1NAME\s0 and \s-1HASHREF\s0 replaces any existing relationship.
.IP "\fBrelationships [\s-1ARGS\s0]\fR" 4
.IX Item "relationships [ARGS]"
Get or set the full list of relationships.  If \s-1ARGS\s0 are passed, the relationship list is cleared and then \s-1ARGS\s0 are passed to the add_relationships method.
.Sp
Returns a list of relationship objects in list context, or a reference to an array of relationship objects in scalar context.
.IP "\fBreplace_column \s-1NAME\s0, [\s-1COLUMN\s0 | \s-1HASHREF\s0]\fR" 4
.IX Item "replace_column NAME, [COLUMN | HASHREF]"
Replace the column named \s-1NAME\s0 with a newly constructed column.  This method is equivalent to deleting any existing column named \s-1NAME\s0 and then adding a new one.  In other words, this:
.Sp
.Vb 1
\&    $meta\->replace_column($name => $value);
.Ve
.Sp
is equivalent to this:
.Sp
.Vb 2
\&    $meta\->delete_column($name);
\&    $meta\->add_column($name => $value);
.Ve
.Sp
The value of the new column may be a Rose::DB::Object::Metadata::Column\-derived object or a reference to a hash suitable for passing to the add_columns method.
.IP "\fBschema [\s-1SCHEMA\s0]\fR" 4
.IX Item "schema [SCHEMA]"
Get or set the database schema for this class.  This setting will \fBoverride\fR any setting in the db object.  Use this method only if you know that the class will always point to a specific schema, regardless of what the Rose::DB\-derived database handle object specifies.
.IP "\fBsetup \s-1PARAMS\s0\fR" 4
.IX Item "setup PARAMS"
Set up all the metadata for this class in a single method call.  This method is a convenient shortcut.  It does its work by delegating to other methods.
.Sp
The \fIsetup()\fR method does nothing if the metadata object is already initialized (according to the is_initialized method).
.Sp
\&\s-1PARAMS\s0 are method/arguments pairs.  In general, the following transformations apply.
.Sp
Given a method/arrayref pair:
.Sp
.Vb 1
\&    METHOD => [ ARG1, ARG2 ]
.Ve
.Sp
The arguments will be removed from their array reference and passed to \s-1METHOD\s0 like this:
.Sp
.Vb 1
\&    $meta\->METHOD(ARG1, ARG2);
.Ve
.Sp
Given a method/value pair:
.Sp
.Vb 1
\&    METHOD => ARG
.Ve
.Sp
The argument will be passed to \s-1METHOD\s0 as-is:
.Sp
.Vb 1
\&    $meta\->METHOD(ARG);
.Ve
.Sp
There are two exceptions to these transformation rules.
.Sp
If \s-1METHOD\s0 is "unique_key\*(L" or \*(R"add_unique_key" and the argument is a reference to an array containing only non-reference values, then the array reference itself is passed to the method.  For example, this pair:
.Sp
.Vb 1
\&    unique_key => [ \*(Aqname\*(Aq, \*(Aqstatus\*(Aq ]
.Ve
.Sp
will result in this method call:
.Sp
.Vb 1
\&    $meta\->unique_key([ \*(Aqname\*(Aq, \*(Aqstatus\*(Aq ]);
.Ve
.Sp
(Note that these method names are \fIsingular\fR.  This exception does \fInot\fR apply to the \fIplural\fR variants, "unique_keys\*(L" and \*(R"add_unique_keys".)
.Sp
If \s-1METHOD\s0 is \*(L"helpers\*(R", then the argument is dereferenced (if it's an array reference) and passed on to Rose::DB::Object::Helpers.  That is, this:
.Sp
.Vb 1
\&    helpers => [ \*(Aqload_or_save\*(Aq, { load_or_insert => \*(Aqfind_or_create\*(Aq } ],
.Ve
.Sp
Is equivalent to having this in your class:
.Sp
.Vb 2
\&    use Rose::DB::Object::Helpers 
\&      \*(Aqload_or_save\*(Aq, { load_or_insert => \*(Aqfind_or_create\*(Aq };
.Ve
.Sp
Method names may appear more than once in \s-1PARAMS\s0.  The methods are called in the order that they appear in \s-1PARAMS\s0, with the exception of the initialize (or auto_initialize) method, which is always called last.
.Sp
If \*(L"initialize\*(R" is not one of the method names, then it will be called automatically (with no arguments) at the end.  If you do not want to pass any arguments to the initialize method, standard practice is to omit it.
.Sp
If \*(L"auto_initialize\*(R" is one of the method names, then the  auto_initialize method will be called instead of the initialize method.  This is useful if you want to manually set up a few pieces of metadata, but want the auto-initialization system to set up the rest.
.Sp
The name \*(L"auto\*(R" is considered equivalent to \*(L"auto_initialize\*(R", but any arguments are ignored unless they are encapsulated in a reference to an array.  For example, these are equivalent:
.Sp
.Vb 5
\&    $meta\->setup(
\&      table => \*(Aqmytable\*(Aq,
\&      # Call auto_initialize() with no arguments
\&      auto_initialize => [],
\&    );
\&
\&    # This is another way of writing the same thing as the above
\&    $meta\->setup(
\&      table => \*(Aqmytable\*(Aq,
\&      # The value "1" is ignored because it\*(Aqs not an arrayref,
\&      # so auto_initialize() will be called with no arguments.
\&      auto => 1,
\&    );
.Ve
.Sp
Finally, here's a full example of a \fIsetup()\fR method call followed by the equivalent \*(L"long-hand\*(R" implementation.
.Sp
.Vb 3
\&    $meta\->setup
\&    (
\&      table => \*(Aqcolors\*(Aq,
\&
\&      columns => 
\&      [
\&        code => { type => \*(Aqcharacter\*(Aq, length => 3, not_null => 1 },
\&        name => { type => \*(Aqvarchar\*(Aq, length => 255 },
\&      ],
\&
\&      primary_key_columns => [ \*(Aqcode\*(Aq ],
\&
\&      unique_key => [ \*(Aqname\*(Aq ],
\&    );
.Ve
.Sp
The \fIsetup()\fR method call above is equivalent to the following code:
.Sp
.Vb 3
\&    unless($meta\->is_initialized)
\&    {
\&      $meta\->table(\*(Aqcolors\*(Aq);
\&
\&      $meta\->columns(
\&      [
\&        code => { type => \*(Aqcharacter\*(Aq, length => 3, not_null => 1 },
\&        name => { type => \*(Aqvarchar\*(Aq, length => 255 },
\&      ]);
\&
\&      $meta\->primary_key_columns(\*(Aqcode\*(Aq);
\&
\&      $meta\->unique_key([ \*(Aqname\*(Aq ]),
\&
\&      $meta\->initialize;
\&    }
.Ve
.IP "\fBsql_qualify_column_names_on_load [\s-1BOOL\s0]\fR" 4
.IX Item "sql_qualify_column_names_on_load [BOOL]"
Get or set a boolean value that indicates whether or not to prefix the columns with the table name in the \s-1SQL\s0 used to \fIload()\fR an object.  The default value is false.
.Sp
For example, here is some \s-1SQL\s0 that might be used to load an object, as generated with sql_qualify_column_names_on_load set to false:
.Sp
.Vb 1
\&    SELECT id, name FROM dogs WHERE id = 5;
.Ve
.Sp
Now here's how it would look with sql_qualify_column_names_on_load set to true:
.Sp
.Vb 1
\&    SELECT dogs.id, dogs.name FROM dogs WHERE dogs.id = 5;
.Ve
.IP "\fBtable [\s-1TABLE\s0]\fR" 4
.IX Item "table [TABLE]"
Get or set the name of the database table.  The table name should not include any sort of prefix to indicate the schema or catalog.
.IP "\fBunique_key \s-1KEY\s0\fR" 4
.IX Item "unique_key KEY"
This method is an alias for add_unique_keys.
.IP "\fBunique_keys \s-1KEYS\s0\fR" 4
.IX Item "unique_keys KEYS"
Get or set the list of unique keys for this table.  If \s-1KEYS\s0 is passed, any existing keys will be deleted and \s-1KEYS\s0 will be passed to the add_unique_keys method.
.Sp
Returns the list (in list context) or reference to an array (in scalar context) of Rose::DB::Object::Metadata::UniqueKey objects.
.IP "\fBunique_key_by_name \s-1NAME\s0\fR" 4
.IX Item "unique_key_by_name NAME"
Return the unique key named \s-1NAME\s0, or undef if no such key exists.
.IP "\fBunique_keys_column_names\fR" 4
.IX Item "unique_keys_column_names"
Returns a list (in list context) or a reference to an array (in scalar context) or references to arrays of the column names that make up each unique key.  That is:
.Sp
.Vb 2
\&    # Example of a scalar context return value
\&    [ [ \*(Aqid\*(Aq, \*(Aqname\*(Aq ], [ \*(Aqcode\*(Aq ] ]
\&
\&    # Example of a list context return value
\&    ([ \*(Aqid\*(Aq, \*(Aqname\*(Aq ], [ \*(Aqcode\*(Aq ])
.Ve
.SH "AUTO-INITIALIZATION METHODS"
.IX Header "AUTO-INITIALIZATION METHODS"
These methods are associated with the auto-initialization process.  Calling any of them will cause the auto-initialization code to be loaded, which costs memory.  This should be considered an implementation detail for now.
.PP
Regardless of the implementation details, you should still avoid calling any of these methods unless you plan to do some auto-initialization.  No matter how generic they may seem (e.g., default_perl_indent), rest assured that none of these methods are remotely useful \fIunless\fR you are doing auto-initialization.
.SS "\s-1CLASS\s0 \s-1METHODS\s0"
.IX Subsection "CLASS METHODS"
.IP "\fBdefault_perl_braces [\s-1STYLE\s0]\fR" 4
.IX Item "default_perl_braces [STYLE]"
Get or set the default brace style used in the Perl code generated by the perl_* object methods.  \s-1STYLE\s0 must be either \*(L"k&r\*(R" or \*(L"bsd\*(R".  The default value is \*(L"k&r\*(R".
.IP "\fBdefault_perl_indent [\s-1INT\s0]\fR" 4
.IX Item "default_perl_indent [INT]"
Get or set the default integer number of spaces used for each level of indenting in the Perl code generated by the perl_* object methods.  The default value is 4.
.IP "\fBdefault_perl_unique_key_style [\s-1STYLE\s0]\fR" 4
.IX Item "default_perl_unique_key_style [STYLE]"
Get or set the default style of the unique key initialization used in the Perl code generated by the perl_unique_keys_definition method.  \s-1STYLE\s0 must be \*(L"array\*(R" or \*(L"object\*(R".  The default value is \*(L"array\*(R".  See the perl_unique_keys_definition method for examples of the two styles.
.SS "\s-1OBJECT\s0 \s-1METHODS\s0"
.IX Subsection "OBJECT METHODS"
.IP "\fBauto_generate_columns\fR" 4
.IX Item "auto_generate_columns"
Auto-generate Rose::DB::Object::Metadata::Column\-derived objects for each column in the table.  Note that this method does not modify the metadata object's list of columns.  It simply returns a list of column objects.    Calling this method in void context will cause a fatal error.
.Sp
Returns a list of column objects (in list context) or a reference to a hash of column objects, keyed by column name (in scalar context).  The hash reference return value is intended to allow easy modification of the auto-generated column objects.  Example:
.Sp
.Vb 1
\&    $columns = $meta\->auto_generate_columns; # hash ref return value
\&
\&    # Make some changes    
\&    $columns\->{\*(Aqname\*(Aq}\->length(10); # set different length
\&    $columns\->{\*(Aqage\*(Aq}\->default(5);  # set different default
\&    ...
\&
\&    # Finally, set the column list
\&    $meta\->columns(values %$columns);
.Ve
.Sp
If you do not want to modify the auto-generated columns, you should use the auto_init_columns method instead.
.Sp
A fatal error will occur unless at least one column was auto-generated.
.IP "\fBauto_generate_foreign_keys [\s-1PARAMS\s0]\fR" 4
.IX Item "auto_generate_foreign_keys [PARAMS]"
Auto-generate Rose::DB::Object::Metadata::ForeignKey objects for each foreign key in the table.  Note that this method does not modify the metadata object's list of foreign_keys.  It simply returns a list of foreign key objects.  Calling this method in void context will cause a fatal error.  A warning will be issued if a foreign key could not be generated because no Rose::DB::Object\-derived class was found for the foreign table.
.Sp
\&\s-1PARAMS\s0 are optional name/value pairs.  If a \f(CW\*(C`no_warnings\*(C'\fR parameter is passed with a true value, then the warning described above will not be issued.
.Sp
Returns a list of foreign key objects (in list context) or a reference to an array of foreign key objects (in scalar context).
.Sp
If you do not want to inspect or modify the auto-generated foreign keys, but just want them to populate the metadata object's foreign_keys list, you should use the auto_init_foreign_keys method instead.
.Sp
\&\fBNote:\fR This method works with MySQL only when using the InnoDB storage type.
.IP "\fBauto_generate_unique_keys\fR" 4
.IX Item "auto_generate_unique_keys"
Auto-generate Rose::DB::Object::Metadata::UniqueKey objects for each unique key in the table.  Note that this method does not modify the metadata object's list of unique_keys.  It simply returns a list of unique key objects.  Calling this method in void context will cause a fatal error.
.Sp
Returns a list of unique key objects (in list context) or a reference to an array of unique key objects (in scalar context).
.Sp
If you do not want to inspect or modify the auto-generated unique keys, but just want them to populate the metadata object's unique_keys list, you should use the auto_init_unique_keys method instead.
.IP "\fBauto_retrieve_primary_key_column_names\fR" 4
.IX Item "auto_retrieve_primary_key_column_names"
Returns a list (in list context) or a reference to an array (in scalar context) of the names of the columns that make up the primary key for this table.  Note that this method does not modify the metadata object's primary_key.  It simply returns a list of column names.  Calling this method in void context will cause a fatal error.
.Sp
This method is rarely called explicitly.  Usually, you will use the auto_init_primary_key_columns method instead.
.Sp
A fatal error will occur unless at least one column name can be retrieved.
.Sp
(This method uses the word \*(L"retrieve\*(R" instead of \*(L"generate\*(R" like its sibling methods above because it does not generate objects; it simply returns column names.)
.IP "\fBauto_initialize [\s-1PARAMS\s0]\fR" 4
.IX Item "auto_initialize [PARAMS]"
Auto-initialize the entire metadata object.  This is a wrapper for the individual \*(L"auto_init_*\*(R" methods, and is roughly equivalent to this:
.Sp
.Vb 6
\&  $meta\->auto_init_columns(...);
\&  $meta\->auto_init_primary_key_columns;
\&  $meta\->auto_init_unique_keys(...);
\&  $meta\->auto_init_foreign_keys(...);
\&  $meta\->auto_init_relationships(...);
\&  $meta\->initialize;
.Ve
.Sp
\&\s-1PARAMS\s0 are optional name/value pairs.  When applicable, these parameters are passed on to each of the \*(L"auto_init_*\*(R" methods.  Valid parameters are:
.RS 4
.IP "\fBinclude_map_class_relationships \s-1BOOL\s0\fR" 4
.IX Item "include_map_class_relationships BOOL"
By default, if a class is a map class (according to the is_map_class method of the convention manager), then relationships directly between that class and the current class will not be created.  Set this parameter to true to allow such relationships to be created.
.Sp
\&\fBNote:\fR If some classes that are not actually map classes are being skipped, you should not use this parameter to force them to be included.  It's more appropriate to make your own custom convention manager subclass and then override the is_map_class method to make the correct determination.
.IP "\fBreplace_existing \s-1BOOL\s0\fR" 4
.IX Item "replace_existing BOOL"
If true, then the auto-generated columns, unique keys, foreign keys, and relationships entirely replace any existing columns, unique keys, foreign keys, and relationships, respectively.
.IP "\fBstay_connected \s-1BOOL\s0\fR" 4
.IX Item "stay_connected BOOL"
If true, then any database connections retained by the metadata objects belonging to the various Rose::DB::Object\-derived classes participating in the auto-initialization process will remain connected until an explicit call to the clear_all_dbs class method.
.IP "\fBwith_foreign_keys \s-1BOOL\s0\fR" 4
.IX Item "with_foreign_keys BOOL"
A boolean value indicating whether or not foreign key metadata will be auto-initialized.  Defaults to true.
.IP "\fBwith_relationships [ \s-1BOOL\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "with_relationships [ BOOL | ARRAYREF ]"
A boolean value or a reference to an array of relationship type names.  If set to a simple boolean value, then the all types of relationships will be considered for auto-initialization.  If set to a list of relationship type names, then only relationships of those types will be considered.  Defaults to true.
.IP "\fBwith_unique_keys \s-1BOOL\s0\fR" 4
.IX Item "with_unique_keys BOOL"
A boolean value indicating whether or not unique key metadata will be auto-initialized.  Defaults to true.
.RE
.RS 4
.Sp
During initialization, if one of the columns has a method name that clashes with a reserved method name, then the column_alias_generator will be called to remedy the situation by aliasing the column.  If the name still conflicts, then a fatal error will occur.
.Sp
A fatal error will occur if auto-initialization fails.
.RE
.IP "\fBauto_init_columns [\s-1PARAMS\s0]\fR" 4
.IX Item "auto_init_columns [PARAMS]"
Auto-generate Rose::DB::Object::Metadata::Column objects for this table, then populate the list of columns.  \s-1PARAMS\s0 are optional name/value pairs.  If a \f(CW\*(C`replace_existing\*(C'\fR parameter is passed with a true value, then the auto-generated columns replace any existing columns.  Otherwise, any existing columns are left as-is.
.IP "\fBauto_init_foreign_keys [\s-1PARAMS\s0]\fR" 4
.IX Item "auto_init_foreign_keys [PARAMS]"
Auto-generate Rose::DB::Object::Metadata::ForeignKey objects for this table, then populate the list of foreign_keys.  \s-1PARAMS\s0 are optional name/value pairs.  If a \f(CW\*(C`replace_existing\*(C'\fR parameter is passed with a true value, then the auto-generated foreign keys replace any existing foreign keys.  Otherwise, any existing foreign keys are left as-is.
.Sp
\&\fBNote:\fR This method works with MySQL only when using the InnoDB storage type.
.IP "\fBauto_init_primary_key_columns\fR" 4
.IX Item "auto_init_primary_key_columns"
Auto-retrieve the names of the columns that make up the primary key for this table, then populate the list of primary_key_column_names.  A fatal error will occur unless at least one primary key column name could be retrieved.
.IP "\fBauto_init_relationships [\s-1PARAMS\s0]\fR" 4
.IX Item "auto_init_relationships [PARAMS]"
Auto-populate the list of relationships for this class.  \s-1PARAMS\s0 are optional name/value pairs.
.RS 4
.IP "\fBinclude_map_class_relationships \s-1BOOL\s0\fR" 4
.IX Item "include_map_class_relationships BOOL"
By default, if a class is a map class (according to the is_map_class method of the convention manager), then relationships directly between that class and the current class will not be created.  Set this parameter to true to allow such relationships to be created.
.Sp
\&\fBNote:\fR If some classes that are not actually map classes are being skipped, you should not use this parameter to force them to be included.  It's more appropriate to make your own custom convention manager subclass and then override the is_map_class method to make the correct determination.
.IP "\fBreplace_existing \s-1BOOL\s0\fR" 4
.IX Item "replace_existing BOOL"
If true, then the auto-generated relationships replace any existing relationships.  Otherwise, any existing relationships are left as-is.
.IP "\fBrelationship_types \s-1ARRAYREF\s0\fR" 4
.IX Item "relationship_types ARRAYREF"
A reference to an array of relationship type names.  Only relationships of these types will be created.  If omitted, relationships of all types will be created.  If passed a reference to an emoty array, no relationships will be created.
.IP "\fBtypes \s-1ARRAYREF\s0\fR" 4
.IX Item "types ARRAYREF"
This is an alias for the \f(CW\*(C`relationship_types\*(C'\fR parameter.
.IP "\fBwith_relationships [ \s-1BOOL\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "with_relationships [ BOOL | ARRAYREF ]"
This is the same as the \f(CW\*(C`relationship_types\*(C'\fR parameter except that it also accepts a boolean value.  If true, then relationships of all types will be created.  If false, then none will be created.
.RE
.RS 4
.Sp
Assume that this class is called \f(CW\*(C`Local\*(C'\fR and any hypothetical foreign class is called \f(CW\*(C`Remote\*(C'\fR.  Relationships are auto-generated according to the following rules.
.IP "\(bu" 4
A one-to-many relationship is created between \f(CW\*(C`Local\*(C'\fR and \f(CW\*(C`Remote\*(C'\fR if \f(CW\*(C`Remote\*(C'\fR has a foreign key that points to \f(CW\*(C`Local\*(C'\fR.  This is not done, however, if \f(CW\*(C`Local\*(C'\fR has a one-to-one relationship pointing to \f(CW\*(C`Remote\*(C'\fR that references the same columns as the foreign key in \f(CW\*(C`Remote\*(C'\fR that points to \f(CW\*(C`Local\*(C'\fR, or if \f(CW\*(C`Local\*(C'\fR is a map class (according to the convention manager's is_map_class method).  The relationship name is generated by the convention manager's auto_relationship_name_one_to_many method.
.IP "\(bu" 4
A many-to-many relationship is created between \f(CW\*(C`Local\*(C'\fR and \f(CW\*(C`Remote\*(C'\fR if there exists a map class (according to the convention manager's is_map_class method) with exactly two foreign keys, one pointing to Local and on pointing to \f(CW\*(C`Remote\*(C'\fR.  The relationship name is generated by creating a plural version of the name of the foreign key in the map class that points to \f(CW\*(C`Remote\*(C'\fR.
.RE
.RS 4
.Sp
In all cases, if there is an existing, semantically identical relationship, then a new relationship is not auto-generated.  Similarly, any existing methods with the same names are not overridden by methods associated with auto-generated relationships.
.RE
.IP "\fBauto_init_unique_keys [\s-1PARAMS\s0]\fR" 4
.IX Item "auto_init_unique_keys [PARAMS]"
Auto-generate Rose::DB::Object::Metadata::UniqueKey objects for this table, then populate the list of unique_keys.  \s-1PARAMS\s0 are name/value pairs.  If a \f(CW\*(C`replace_existing\*(C'\fR parameter is passed with a true value, then the auto-generated unique keys replace any existing unique keys.  Otherwise, any existing unique keys are left as-is.
.IP "\fBcolumn_alias_generator [\s-1CODEREF\s0]\fR" 4
.IX Item "column_alias_generator [CODEREF]"
Get or set the code reference to the subroutine used to alias columns have, or would generate, one or more method names that clash with reserved method names.
.Sp
The subroutine should take two arguments: the metadata object and the column name.  The \f(CW$_\fR variable will also be set to the column name at the time of the call.  The subroutine should return an alias for the column.
.Sp
The default column alias generator simply appends the string \*(L"_col\*(R" to the end of the column name and returns that as the alias.
.IP "\fBforeign_key_name_generator [\s-1CODEREF\s0]\fR" 4
.IX Item "foreign_key_name_generator [CODEREF]"
Get or set the code reference to the subroutine used to generate foreign key names.  \fBNote:\fR This code will only be called if the convention_manager's auto_foreign_key_name method fails to (or declines to) produce a defined foreign key name.
.Sp
The subroutine should take two arguments: a metadata object and a Rose::DB::Object::Metadata::ForeignKey object.  It should return a name for the foreign key.
.Sp
Each foreign key must have a name that is unique within the class.  By default, this name will also be the name of the method generated to access the object referred to by the foreign key, so it must be unique among method names in the class as well.
.Sp
The default foreign key name generator uses the following algorithm:
.Sp
If the foreign key has only one column, and if the name of that column ends with an underscore and the name of the referenced column, then that part of the column name is removed and the remaining string is used as the foreign key name.  For example, given the following tables:
.Sp
.Vb 5
\&    CREATE TABLE categories
\&    (
\&      id  SERIAL PRIMARY KEY,
\&      ...
\&    );
\&
\&    CREATE TABLE products
\&    (
\&      category_id  INT REFERENCES categories (id),
\&      ...
\&    );
.Ve
.Sp
The foreign key name would be \*(L"category\*(R", which is the name of the referring column (\*(L"category_id\*(R") with an underscore and the name of the referenced column (\*(L"_id\*(R") removed from the end of it.
.Sp
If the foreign key has only one column, but it does not meet the criteria described above, then \*(L"_object\*(R" is appended to the name of the referring column and the resulting string is used as the foreign key name.
.Sp
If the foreign key has more than one column, then the foreign key name is generated by replacing double colons and case-transitions in the referenced class name with underscores, and then converting to lowercase.  For example, if the referenced table is fronted by the class My::TableOfStuff, then the generated foreign key name would be \*(L"my_table_of_stuff\*(R".
.Sp
In all of the scenarios above, if the generated foreign key name is still not unique within the class, then a number is appended to the end of the name.  That number is incremented until the name is unique.
.Sp
In practice, rather than setting a custom foreign key name generator, it's usually easier to simply set the foreign key name(s) manually after auto-initializing the foreign keys (but \fIbefore\fR calling initialize or auto_initialize, of course).
.IP "\fBperl_class_definition [\s-1PARAMS\s0]\fR" 4
.IX Item "perl_class_definition [PARAMS]"
Auto-initialize the columns, primary key, foreign keys, and unique keys, then return the Perl source code for a complete Rose::DB::Object\-derived class definition.  \s-1PARAMS\s0 are optional name/value pairs that may include the following:
.RS 4
.IP "\fBbraces \s-1STYLE\s0\fR" 4
.IX Item "braces STYLE"
The brace style to use in the generated Perl code.  \s-1STYLE\s0 must be either \*(L"k&r\*(R" or \*(L"bsd\*(R".  The default value is determined by the return value of the default_perl_braces class method.
.IP "\fBindent \s-1INT\s0\fR" 4
.IX Item "indent INT"
The integer number of spaces to use for each level of indenting in the generated Perl code.  The default value is determined by the return value of the default_perl_indent class method.
.IP "\fBisa \s-1CLASSES\s0\fR" 4
.IX Item "isa CLASSES"
The list of base classes to use in the generated class definition.  \s-1CLASSES\s0 should be a single class name, or a reference to an array of class names.  The default base class is Rose::DB::Object.
.IP "\fBuse_setup \s-1BOOL\s0\fR" 4
.IX Item "use_setup BOOL"
If true, then the generated class definition will include a call to the setup method.  Otherwise, the generated code will contain individual methods calls.  The default value for this parameter is \fBtrue\fR; the setup method is the recommended way to initialize a class.
.RE
.RS 4
.Sp
This method is simply a wrapper (with some glue) for the following methods: perl_columns_definition, perl_primary_key_columns_definition, perl_unique_keys_definition,  perl_foreign_keys_definition, and perl_relationships_definition.  The \*(L"braces\*(R" and \*(L"indent\*(R" parameters are passed on to these other methods.
.Sp
Here's a complete example, which also serves as an example of the individual \*(L"perl_*\*(R" methods that this method wraps.  First, the table definitions.
.Sp
.Vb 5
\&    CREATE TABLE topics
\&    (
\&      id    SERIAL PRIMARY KEY,
\&      name  VARCHAR(32)
\&    );
\&
\&    CREATE TABLE codes
\&    (
\&      k1    INT NOT NULL,
\&      k2    INT NOT NULL,
\&      k3    INT NOT NULL,
\&      name  VARCHAR(32),
\&
\&      PRIMARY KEY(k1, k2, k3)
\&    );
\&
\&    CREATE TABLE products
\&    (
\&      id             SERIAL PRIMARY KEY,
\&      name           VARCHAR(32) NOT NULL,
\&      flag           BOOLEAN NOT NULL DEFAULT \*(Aqt\*(Aq,
\&      status         VARCHAR(32) DEFAULT \*(Aqactive\*(Aq,
\&      topic_id       INT REFERENCES topics (id),
\&      fk1            INT,
\&      fk2            INT,
\&      fk3            INT,
\&      last_modified  TIMESTAMP,
\&      date_created   TIMESTAMP,
\&
\&      FOREIGN KEY (fk1, fk2, fk3) REFERENCES codes (k1, k2, k3)
\&    );
\&
\&    CREATE TABLE prices
\&    (
\&      id          SERIAL PRIMARY KEY,
\&      product_id  INT REFERENCES products (id),
\&      price       DECIMAL(10,2) NOT NULL DEFAULT 0.00,
\&      region      CHAR(2) NOT NULL DEFAULT \*(AqUS\*(Aq 
\&    );
.Ve
.Sp
First we'll auto-initialize the classes.
.Sp
.Vb 3
\&    package Code;
\&    use base qw(Rose::DB::Object);
\&    _\|_PACKAGE_\|_\->meta\->auto_initialize;
\&
\&    package Category;
\&    use base qw(Rose::DB::Object);
\&    # Explicit table name required because the class name 
\&    # does not match up with the table name in this case.
\&    _\|_PACKAGE_\|_\->meta\->table(\*(Aqtopics\*(Aq);
\&    _\|_PACKAGE_\|_\->meta\->auto_initialize;
\&
\&    package Product;
\&    use base qw(Rose::DB::Object);
\&    _\|_PACKAGE_\|_\->meta\->auto_initialize;
\&
\&    package Price;
\&    use base qw(Rose::DB::Object);
\&    _\|_PACKAGE_\|_\->meta\->auto_initialize;
.Ve
.Sp
Now we'll print the \f(CW\*(C`Product\*(C'\fR class definition;
.Sp
.Vb 2
\&    print Product\->meta\->perl_class_definition(braces => \*(Aqbsd\*(Aq, 
\&                                               indent => 2);
.Ve
.Sp
The output looks like this:
.Sp
.Vb 1
\&  package Product;
\&
\&  use strict;
\&
\&  use base qw(Rose::DB::Object);
\&
\&  _\|_PACKAGE_\|_\->meta\->setup
\&  (
\&    table => \*(Aqproducts\*(Aq,
\&
\&    columns =>
\&    [
\&      id            => { type => \*(Aqinteger\*(Aq, not_null => 1 },
\&      name          => { type => \*(Aqvarchar\*(Aq, length => 32, not_null => 1 },
\&      flag          => { type => \*(Aqboolean\*(Aq, default => \*(Aqtrue\*(Aq, not_null => 1 },
\&      status        => { type => \*(Aqvarchar\*(Aq, default => \*(Aqactive\*(Aq, length => 32 },
\&      topic_id      => { type => \*(Aqinteger\*(Aq },
\&      fk1           => { type => \*(Aqinteger\*(Aq },
\&      fk2           => { type => \*(Aqinteger\*(Aq },
\&      fk3           => { type => \*(Aqinteger\*(Aq },
\&      last_modified => { type => \*(Aqtimestamp\*(Aq },
\&      date_created  => { type => \*(Aqtimestamp\*(Aq },
\&    ],
\&
\&    primary_key_columns => [ \*(Aqid\*(Aq ],
\&
\&    foreign_keys =>
\&    [
\&      code => 
\&      {
\&        class => \*(AqCode\*(Aq,
\&        key_columns => 
\&        {
\&          fk1 => \*(Aqk1\*(Aq,
\&          fk2 => \*(Aqk2\*(Aq,
\&          fk3 => \*(Aqk3\*(Aq,
\&        },
\&      },
\&
\&      topic => 
\&      {
\&        class => \*(AqCategory\*(Aq,
\&        key_columns => 
\&        {
\&          topic_id => \*(Aqid\*(Aq,
\&        },
\&      },
\&    ],
\&
\&    relationships =>
\&    [
\&      prices => 
\&      {
\&        class       => \*(AqPrice\*(Aq,
\&        key_columns => { id => \*(Aqproduct_id\*(Aq },
\&        type        => \*(Aqone to many\*(Aq,
\&      },
\&    ],
\&  );
\&
\&  1;
.Ve
.Sp
Here's the output when the \f(CW\*(C`use_setup\*(C'\fR parameter is explicitly set to false.
.Sp
.Vb 3
\&    print Product\->meta\->perl_class_definition(braces    => \*(Aqbsd\*(Aq, 
\&                                               indent    => 2,
\&                                               use_setup => 0);
.Ve
.Sp
Note that this approach is not recommended, but exists for historical reasons.
.Sp
.Vb 1
\&  package Product;
\&
\&  use strict;
\&
\&  use base qw(Rose::DB::Object);
\&
\&  _\|_PACKAGE_\|_\->meta\->table(\*(Aqproducts\*(Aq);
\&
\&  _\|_PACKAGE_\|_\->meta\->columns
\&  (
\&    id            => { type => \*(Aqinteger\*(Aq, not_null => 1 },
\&    name          => { type => \*(Aqvarchar\*(Aq, length => 32, not_null => 1 },
\&    flag          => { type => \*(Aqboolean\*(Aq, default => \*(Aqtrue\*(Aq, not_null => 1 },
\&    status        => { type => \*(Aqvarchar\*(Aq, default => \*(Aqactive\*(Aq, length => 32 },
\&    topic_id      => { type => \*(Aqinteger\*(Aq },
\&    fk1           => { type => \*(Aqinteger\*(Aq },
\&    fk2           => { type => \*(Aqinteger\*(Aq },
\&    fk3           => { type => \*(Aqinteger\*(Aq },
\&    last_modified => { type => \*(Aqtimestamp\*(Aq },
\&    date_created  => { type => \*(Aqtimestamp\*(Aq },
\&  );
\&
\&  _\|_PACKAGE_\|_\->meta\->primary_key_columns([ \*(Aqid\*(Aq ]);
\&
\&  _\|_PACKAGE_\|_\->meta\->foreign_keys
\&  (
\&    code => 
\&    {
\&      class => \*(AqCode\*(Aq,
\&      key_columns => 
\&      {
\&        fk1 => \*(Aqk1\*(Aq,
\&        fk2 => \*(Aqk2\*(Aq,
\&        fk3 => \*(Aqk3\*(Aq,
\&      },
\&    },
\&
\&    topic => 
\&    {
\&      class => \*(AqCategory\*(Aq,
\&      key_columns => 
\&      {
\&        topic_id => \*(Aqid\*(Aq,
\&      },
\&    },
\&  );
\&
\&  _\|_PACKAGE_\|_\->meta\->relationships
\&  (
\&    prices => 
\&    {
\&      class       => \*(AqPrice\*(Aq,
\&      key_columns => { id => \*(Aqproduct_id\*(Aq },
\&      type        => \*(Aqone to many\*(Aq,
\&    },
\&  );
\&
\&  _\|_PACKAGE_\|_\->meta\->initialize;
\&
\&  1;
.Ve
.Sp
See the auto-initialization section for more discussion of Perl code generation.
.RE
.IP "\fBperl_columns_definition [\s-1PARAMS\s0]\fR" 4
.IX Item "perl_columns_definition [PARAMS]"
Auto-initialize the columns (if necessary), then return the Perl source code that is equivalent to the auto-initialization.  \s-1PARAMS\s0 are optional name/value pairs that may include the following:
.RS 4
.IP "\fBbraces \s-1STYLE\s0\fR" 4
.IX Item "braces STYLE"
The brace style to use in the generated Perl code.  \s-1STYLE\s0 must be either \*(L"k&r\*(R" or \*(L"bsd\*(R".  The default value is determined by the return value of the default_perl_braces class method.
.IP "\fBfor_setup \s-1BOOL\s0\fR" 4
.IX Item "for_setup BOOL"
If true, then the generated Perl code will be a method/arguments pair suitable for use as a parameter to setup method.  The default is false.
.IP "\fBindent \s-1INT\s0\fR" 4
.IX Item "indent INT"
The integer number of spaces to use for each level of indenting in the generated Perl code.  The default value is determined by the return value of the default_perl_indent class method.
.RE
.RS 4
.Sp
To see examples of the generated code, look in the documentation for the perl_class_definition method.
.RE
.IP "\fBperl_foreign_keys_definition [\s-1PARAMS\s0]\fR" 4
.IX Item "perl_foreign_keys_definition [PARAMS]"
Auto-initialize the foreign keys (if necessary), then return the Perl source code that is equivalent to the auto-initialization.  \s-1PARAMS\s0 are optional name/value pairs that may include the following:
.RS 4
.IP "\fBbraces \s-1STYLE\s0\fR" 4
.IX Item "braces STYLE"
The brace style to use in the generated Perl code.  \s-1STYLE\s0 must be either \*(L"k&r\*(R" or \*(L"bsd\*(R".  The default value is determined by the return value of the default_perl_braces class method.
.IP "\fBfor_setup \s-1BOOL\s0\fR" 4
.IX Item "for_setup BOOL"
If true, then the generated Perl code will be a method/arguments pair suitable for use as a parameter to setup method.  The default is false.
.IP "\fBindent \s-1INT\s0\fR" 4
.IX Item "indent INT"
The integer number of spaces to use for each level of indenting in the generated Perl code.  The default value is determined by the return value of the default_perl_indent class method.
.RE
.RS 4
.Sp
To see examples of the generated code, look in the documentation for the perl_class_definition method.
.RE
.IP "\fBperl_manager_class [ \s-1PARAMS\s0 | \s-1BASE_NAME\s0 ]\fR" 4
.IX Item "perl_manager_class [ PARAMS | BASE_NAME ]"
Returns a Perl class definition for a Rose::DB::Object::Manager\-derived class to manage objects of this class.  If a single string is passed, it is taken as the value of the \f(CW\*(C`base_name\*(C'\fR parameter.  \s-1PARAMS\s0 are optional name/value pairs that may include the following:
.RS 4
.IP "\fBbase_name \s-1NAME\s0\fR" 4
.IX Item "base_name NAME"
The value of the base_name parameter that will be passed to the call to Rose::DB::Object::Manager's make_manager_methods method.  Defaults to the return value of the convention manager's auto_manager_base_name method.
.IP "\fBclass \s-1CLASS\s0\fR" 4
.IX Item "class CLASS"
The name of the manager class.  Defaults to the return value of the convention manager's auto_manager_class_name method.
.IP "\fBisa [ \s-1LIST\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "isa [ LIST | ARRAYREF ]"
The name of a single class or a reference to an array of class names to be included in the \f(CW@ISA\fR array for the manager class.  One of these classes must inherit from Rose::DB::Object::Manager.  Defaults to the return value of the \f(CW\*(C`default_manager_base_class()\*(C'\fR object method.
.RE
.RS 4
.Sp
For example, given this class:
.Sp
.Vb 1
\&    package Product;
\&
\&    use Rose::DB::Object;
\&    our @ISA = qw(Rose::DB::Object);
\&    ...
\&
\&    print Product\->meta\->perl_manager_class(
\&                           class     => \*(AqProd::Mgr\*(Aq,
\&                           base_name => \*(Aqprod\*(Aq);
.Ve
.Sp
The following would be printed:
.Sp
.Vb 1
\&    package Prod::Mgr;
\&
\&    use Rose::DB::Object::Manager;
\&    our @ISA = qw(Rose::DB::Object::Manager);
\&
\&    sub object_class { \*(AqProduct\*(Aq }
\&
\&    _\|_PACKAGE_\|_\->make_manager_methods(\*(Aqprod\*(Aq);
\&
\&    1;
.Ve
.RE
.IP "\fBperl_primary_key_columns_definition\fR" 4
.IX Item "perl_primary_key_columns_definition"
Auto-initialize the primary key column names (if necessary), then return the Perl source code that is equivalent to the auto-initialization.
.Sp
See the larger example in the documentation for the perl_class_definition method to see what the generated Perl code looks like.
.IP "\fBperl_relationships_definition [\s-1PARAMS\s0]\fR" 4
.IX Item "perl_relationships_definition [PARAMS]"
Auto-initialize the relationships (if necessary), then return the Perl source code that is equivalent to the auto-initialization.  \s-1PARAMS\s0 are optional name/value pairs that may include the following:
.RS 4
.IP "\fBbraces \s-1STYLE\s0\fR" 4
.IX Item "braces STYLE"
The brace style to use in the generated Perl code.  \s-1STYLE\s0 must be either \*(L"k&r\*(R" or \*(L"bsd\*(R".  The default value is determined by the return value of the default_perl_braces class method.
.IP "\fBfor_setup \s-1BOOL\s0\fR" 4
.IX Item "for_setup BOOL"
If true, then the generated Perl code will be a method/arguments pair suitable for use as a parameter to setup method.  The default is false.
.IP "\fBindent \s-1INT\s0\fR" 4
.IX Item "indent INT"
The integer number of spaces to use for each level of indenting in the generated Perl code.  The default value is determined by the return value of the default_perl_indent class method.
.RE
.RS 4
.Sp
To see examples of the generated code, look in the documentation for the perl_class_definition method.
.RE
.IP "\fBperl_table_definition [\s-1PARAMS\s0]\fR" 4
.IX Item "perl_table_definition [PARAMS]"
Auto-initialize the table name (if necessary), then return the Perl source code that is equivalent to the auto-initialization.  \s-1PARAMS\s0 are optional name/value pairs that may include the following:
.RS 4
.IP "\fBbraces \s-1STYLE\s0\fR" 4
.IX Item "braces STYLE"
The brace style to use in the generated Perl code.  \s-1STYLE\s0 must be either \*(L"k&r\*(R" or \*(L"bsd\*(R".  The default value is determined by the return value of the default_perl_braces class method.
.IP "\fBfor_setup \s-1BOOL\s0\fR" 4
.IX Item "for_setup BOOL"
If true, then the generated Perl code will be a method/arguments pair suitable for use as a parameter to setup method.  The default is false.
.IP "\fBindent \s-1INT\s0\fR" 4
.IX Item "indent INT"
The integer number of spaces to use for each level of indenting in the generated Perl code.  The default value is determined by the return value of the default_perl_indent class method.
.RE
.RS 4
.Sp
To see examples of the generated code, look in the documentation for the perl_class_definition method.
.RE
.IP "\fBperl_unique_keys_definition [\s-1PARAMS\s0]\fR" 4
.IX Item "perl_unique_keys_definition [PARAMS]"
Auto-initialize the unique keys, then return the Perl source code that is equivalent to the auto-initialization.  \s-1PARAMS\s0 are optional name/value pairs that may include the following:
.RS 4
.IP "\fBbraces \s-1STYLE\s0\fR" 4
.IX Item "braces STYLE"
The brace style to use in the generated Perl code.  \s-1STYLE\s0 must be either \*(L"k&r\*(R" or \*(L"bsd\*(R".  The default value is determined by the return value of the default_perl_braces class method.
.IP "\fBfor_setup \s-1BOOL\s0\fR" 4
.IX Item "for_setup BOOL"
If true, then the generated Perl code will be a method/arguments pair suitable for use as a parameter to setup method.  The default is false.
.IP "\fBindent \s-1INT\s0\fR" 4
.IX Item "indent INT"
The integer number of spaces to use for each level of indenting in the generated Perl code.  The default value is determined by the return value of the default_perl_indent class method.
.IP "\fBstyle \s-1STYLE\s0\fR" 4
.IX Item "style STYLE"
Determines the style the initialization used in the generated Perl code.  \s-1STYLE\s0 must be \*(L"array\*(R" or \*(L"object\*(R".  The default is determined by the return value of the class method default_perl_unique_key_style.
.Sp
The \*(L"array\*(R" style passes references to arrays of column names:
.Sp
.Vb 5
\&  _\|_PACKAGE_\|_\->meta\->unique_keys
\&  (
\&    [ \*(Aqid\*(Aq, \*(Aqname\*(Aq ],
\&    [ \*(Aqflag\*(Aq, \*(Aqstatus\*(Aq ],
\&  );
.Ve
.Sp
The \*(L"object\*(R" style sets unique keys using calls to the Rose::DB::Object::Metadata::UniqueKey constructor:
.Sp
.Vb 5
\&  _\|_PACKAGE_\|_\->meta\->unique_keys
\&  (
\&    Rose::DB::Object::Metadata::UniqueKey\->new(
\&      name    => \*(Aqproducts_id_key\*(Aq, 
\&      columns => [ \*(Aqid\*(Aq, \*(Aqname\*(Aq ]),
\&
\&    Rose::DB::Object::Metadata::UniqueKey\->new(
\&      name    => \*(Aqproducts_flag_key\*(Aq, 
\&      columns => [ \*(Aqflag\*(Aq, \*(Aqstatus\*(Aq ]),
\&  );
.Ve
.RE
.RS 4
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
John C. Siracusa (siracusa@gmail.com)
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2010 by John C. Siracusa.  All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same terms
as Perl itself.
