.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Rose::DB::Object::Loader 3"
.TH Rose::DB::Object::Loader 3 "2011-01-19" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Rose::DB::Object::Loader \- Automatically create Rose::DB::Object subclasses based on database table definitions.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Sample database schema:
.PP
.Vb 4
\&  CREATE TABLE vendors
\&  (
\&    id    SERIAL NOT NULL PRIMARY KEY,
\&    name  VARCHAR(255) NOT NULL,
\&
\&    UNIQUE(name)
\&  );
\&
\&  CREATE TABLE products
\&  (
\&    id      SERIAL NOT NULL PRIMARY KEY,
\&    name    VARCHAR(255) NOT NULL,
\&    price   DECIMAL(10,2) NOT NULL DEFAULT 0.00,
\&
\&    vendor_id  INT REFERENCES vendors (id),
\&
\&    status  VARCHAR(128) NOT NULL DEFAULT \*(Aqinactive\*(Aq 
\&              CHECK(status IN (\*(Aqinactive\*(Aq, \*(Aqactive\*(Aq, \*(Aqdefunct\*(Aq)),
\&
\&    date_created  TIMESTAMP NOT NULL DEFAULT NOW(),
\&    release_date  TIMESTAMP,
\&
\&    UNIQUE(name)
\&  );
\&
\&  CREATE TABLE prices
\&  (
\&    id          SERIAL NOT NULL PRIMARY KEY,
\&    product_id  INT NOT NULL REFERENCES products (id),
\&    region      CHAR(2) NOT NULL DEFAULT \*(AqUS\*(Aq,
\&    price       DECIMAL(10,2) NOT NULL DEFAULT 0.00,
\&
\&    UNIQUE(product_id, region)
\&  );
\&
\&  CREATE TABLE colors
\&  (
\&    id    SERIAL NOT NULL PRIMARY KEY,
\&    name  VARCHAR(255) NOT NULL,
\&
\&    UNIQUE(name)
\&  );
\&
\&  CREATE TABLE product_color_map
\&  (
\&    product_id  INT NOT NULL REFERENCES products (id),
\&    color_id    INT NOT NULL REFERENCES colors (id),
\&
\&    PRIMARY KEY(product_id, color_id)
\&  );
.Ve
.PP
To start, make a Rose::DB::Object::Loader object, specifying the database connection information and an optional class name prefix.
.PP
.Vb 7
\&  $loader = 
\&    Rose::DB::Object::Loader\->new(
\&      db_dsn       => \*(Aqdbi:Pg:dbname=mydb;host=localhost\*(Aq,
\&      db_username  => \*(Aqsomeuser\*(Aq,
\&      db_password  => \*(Aqmysecret\*(Aq,
\&      db_options   => { AutoCommit => 1, ChopBlanks => 1 },
\&      class_prefix => \*(AqMy::Corp\*(Aq);
.Ve
.PP
It's even easier to specify the database information if you've set up Rose::DB (say, by following the instructions in Rose::DB::Tutorial).  Just pass a Rose::DB\-derived object pointing to the database you're interested in.
.PP
.Vb 4
\&  $loader = 
\&    Rose::DB::Object::Loader\->new(
\&      db           => My::Corp::DB\->new(\*(Aqmain\*(Aq),
\&      class_prefix => \*(AqMy::Corp\*(Aq);
.Ve
.PP
Finally, automatically create Rose::DB::Object subclasses for all the tables in the database.  All it takes is one method call.
.PP
.Vb 1
\&  $loader\->make_classes;
.Ve
.PP
Here's what you get for your effort.
.PP
.Vb 1
\&  My::Corp::Product\->new(name => \*(AqSled\*(Aq);
\&
\&  $p\->vendor(name => \*(AqAcme\*(Aq);
\&
\&  $p\->prices({ price => 1.23, region => \*(AqUS\*(Aq },
\&             { price => 4.56, region => \*(AqUK\*(Aq });
\&
\&  $p\->colors({ name => \*(Aqred\*(Aq   }, 
\&             { name => \*(Aqgreen\*(Aq });
\&
\&  $p\->save;
\&
\&  $products = 
\&    My::Corp::Product::Manager\->get_products_iterator(
\&      query           => [ name => { like => \*(Aq%le%\*(Aq } ],
\&      with_objects    => [ \*(Aqprices\*(Aq ],
\&      require_objects => [ \*(Aqvendor\*(Aq ],
\&      sort_by         => \*(Aqvendor.name\*(Aq);
\&
\&  $p = $products\->next;
\&
\&  print $p\->vendor\->name; # Acme
\&
\&  # US: 1.23, UK: 4.56
\&  print join(\*(Aq, \*(Aq, map { $_\->region . \*(Aq: \*(Aq . $_\->price } $p\->prices);
.Ve
.PP
See the Rose::DB::Object and Rose::DB::Object::Manager documentation for learn more about the features these classes provide.
.PP
The contents of the database now look like this.
.PP
.Vb 4
\&  mydb=# select * from products;
\&   id |  name  | price | vendor_id |  status  |       date_created
\&  \-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    1 | Sled 3 |  0.00 |         1 | inactive | 2005\-11\-19 22:09:20.7988 
\&
\&
\&  mydb=# select * from vendors;
\&   id |  name  
\&  \-\-\-\-+\-\-\-\-\-\-\-\-
\&    1 | Acme 3
\&
\&
\&  mydb=# select * from prices;
\&   id | product_id | region | price 
\&  \-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-
\&    1 |          1 | US     |  1.23
\&    2 |          1 | UK     |  4.56
\&
\&
\&  mydb=# select * from colors;
\&   id | name  
\&  \-\-\-\-+\-\-\-\-\-\-\-
\&    1 | red
\&    2 | green
\&
\&
\&  mydb=# select * from product_color_map;
\&   product_id | color_id 
\&  \-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-
\&            1 |        1
\&            1 |        2
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Rose::DB::Object::Loader will automatically create Rose::DB::Object subclasses for all the tables in a database.  It will configure column data types, default values, primary keys, unique keys, and foreign keys.  It can also discover and set up inter-table relationships.  It uses Rose::DB::Object's auto-initialization capabilities to do all of this.
.PP
To do its work, the loader needs to know how to connect to the database.  This information can be provided in several ways.  The recommended practice is to set up Rose::DB according to the instructions in the Rose::DB::Tutorial, and then pass a Rose::DB\-derived object or class name to the loader.  The loader will also accept traditional \s-1DBI\s0\-style connection information: \s-1DSN\s0, username, password, etc.
.PP
Once the loader object is configured, the make_classes method does all the work.  It takes a few options specifying which tables to make classes for, whether or not to make manager classes for each table, and a few other options.  The convention manager is used to convert table names to class names, generate foreign key and relationship method names, and so on.  The result of this process is a suite of Rose::DB::Object (and Rose::DB::Object::Manager) subclasses ready for use.
.PP
Rose::DB::Object::Loader inherits from, and follows the conventions of, Rose::Object.  See the Rose::Object documentation for more information.
.SH "GOTCHAS"
.IX Header "GOTCHAS"
Database schema information is extracted using \s-1DBI\s0's schema interrogation methods, which dutifully report exactly how the database describes itself.  In some cases, what the database reports about a particular table may not exactly match what you specified in your table definition.
.PP
The most egregious offender is (surprise!) MySQL, which, to give just one example, tends to offer up empty string default values for non-null character columns.  That is, if you write a table definition like this:
.PP
.Vb 5
\&    CREATE TABLE widgets
\&    (
\&      id   INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
\&      name VARCHAR(64) NOT NULL
\&    );
.Ve
.PP
and then interrogate it using \s-1DBI\s0, you will find that the \*(L"name\*(R" column has a default value (as reflected in the \f(CW\*(C`COLUMN_DEF\*(C'\fR column returned by \s-1DBI\s0's \fIcolumn_info()\fR method) of '' (i.e., an empty string).  In other words, it's as if your table definition was this instead:
.PP
.Vb 5
\&    CREATE TABLE widgets
\&    (
\&      id   INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
\&      name VARCHAR(64) NOT NULL DEFAULT \*(Aq\*(Aq
\&    );
.Ve
.PP
MySQL is full of such surprises, and it's not the only database to do such things.  Consult the documentation for your database (or do a Google search for \*(L"<mydbname> gotchas\*(R") for the gory details.
.PP
To work around these kinds of problems, try the pre_init_hook feature.  For example, in your  pre_init_hook subroutine you could walk over the list of columns for each class, eliminating all the empty string default values (i.e., changing them to undef instead).
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "\fBnew \s-1PARAMS\s0\fR" 4
.IX Item "new PARAMS"
Returns a new Rose::DB::Object::Loader constructed according to \s-1PARAMS\s0, where \s-1PARAMS\s0 are name/value pairs.  Any object method is a valid parameter name.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.IP "\fBbase_class \s-1CLASS\s0\fR" 4
.IX Item "base_class CLASS"
This is an alias for the base_classes method.
.IP "\fBbase_classes [ \s-1CLASS\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "base_classes [ CLASS | ARRAYREF ]"
Get or set the list of base classes to use for the Rose::DB::Object subclasses created by the make_classes method.  The argument may be a class name or a reference to an array of class names.  At least one of the classes should inherit from Rose::DB::Object.
.Sp
Returns a list (in list context) or reference to an array (in scalar context) of base class names.  Defaults to a dynamically-generated Rose::DB::Object subclass name.
.IP "\fBclass_prefix [\s-1PREFIX\s0]\fR" 4
.IX Item "class_prefix [PREFIX]"
Get or set the prefix affixed to all class names created by the make_classes method.  If \s-1PREFIX\s0 doesn't end in \*(L"::\*(R", it will be added automatically.
.IP "\fBconvention_manager [ \s-1CLASS\s0 | \s-1MANAGER\s0 ]\fR" 4
.IX Item "convention_manager [ CLASS | MANAGER ]"
Get or set the Rose::DB::Object::ConventionManager\-derived class name or object to be used during the auto-initialization process for each class created by the make_classes method.  Returns a Rose::DB::Object::ConventionManager\-derived object, which defaults to a new Rose::DB::Object::ConventionManager object.
.Sp
Unless this attribute is explicitly set or fetched before the call to the make_classes method, the convention manager object used by make_classes will be produced by calling the convention_manager method of the metadata object of the first (left-most) base class.
.IP "\fBdb [\s-1DB\s0]\fR" 4
.IX Item "db [DB]"
Get or set the Rose::DB\-derived object used to connect to the database.  This object will be used by the make_classes method when extracting information from the database.  It will also be used as the prototype for the db object used by each Rose::DB::Object subclass to connect to the database.
.Sp
Setting this attribute also sets the db_class attributes, overwriting any previously existing value, and sets the  db_dsn value to undef.
.IP "\fBdb_catalog [\s-1CATALOG\s0]\fR" 4
.IX Item "db_catalog [CATALOG]"
Get or set the catalog for the database connection.
.IP "\fBdb_class [\s-1CLASS\s0]\fR" 4
.IX Item "db_class [CLASS]"
Get or set the name of the Rose::DB\-derived class used by the make_classes method to construct a db object if one has not been set via the method of the same name.
.Sp
Setting this attribute sets the db attribute to undef unless its class is the same as \s-1CLASS\s0.
.IP "\fBdb_dsn [\s-1DSN\s0]\fR" 4
.IX Item "db_dsn [DSN]"
Get or set the \s-1DBI\s0\-style Data Source Name (\s-1DSN\s0) used to connect to the database.  This will be used by the make_classes method when extracting information from the database.  The Rose::DB\-derived objects used by each Rose::DB::Object subclass to connect to the database will be initialized with this \s-1DSN\s0.
.Sp
Setting this attribute immediately sets the dsn of the db attribute, if it is defined.
.IP "\fBdb_options [\s-1HASHREF\s0]\fR" 4
.IX Item "db_options [HASHREF]"
Get or set the options used to connect to the database.
.IP "\fBdb_password [\s-1PASSWORD\s0]\fR" 4
.IX Item "db_password [PASSWORD]"
Get or set the password used to connect to the database.
.IP "\fBdb_schema [\s-1SCHEMA\s0]\fR" 4
.IX Item "db_schema [SCHEMA]"
Get or set the schema for the database connection.
.IP "\fBdb_username [\s-1USERNAME\s0]\fR" 4
.IX Item "db_username [USERNAME]"
Get or set the username used to connect to the database.
.IP "\fBexclude_tables [ \s-1REGEX\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "exclude_tables [ REGEX | ARRAYREF ]"
Get or set a regular expression or reference to an array of table names to exclude.  Table names that match \s-1REGEX\s0 or are contained in \s-1ARRAYREF\s0 will be skipped by default during calls to the make_classes method.  Tables without primary keys are automatically (and always) skipped.
.Sp
Table names are compared to \s-1REGEX\s0 and the names in \s-1ARRAYREF\s0 in a case-insensitive manner.  To override this in the case of the \s-1REGEX\s0, add \f(CW\*(C`(?\-i)\*(C'\fR to the front of the \s-1REGEX\s0.  Otherwise, use the filter_tables method instead.
.IP "\fBfilter_tables \s-1CODEREF\s0\fR" 4
.IX Item "filter_tables CODEREF"
Get or set a reference to a subroutine that takes a single table name argument and returns true if the table should be processed by default during calls to the make_classes method, false if the table should be skipped.  The \f(CW$_\fR variable will also be set to the table name before the call to \s-1CODEREF\s0.
.Sp
This attribute should not be combined with the exclude_tables or include_tables attributes.
.IP "\fBforce_lowercase [\s-1BOOL\s0]\fR" 4
.IX Item "force_lowercase [BOOL]"
Get or set a boolean value that indicates whether or not metadata entity names should be forced to lowercase even when the related entity (e.g., table or column name) is uppercase or mixed case.  (\*(L"Metadata entities\*(R" are thing like columns, relationships, and foreign keys.)  The default value undef.
.IP "\fBgenerate_manager_class_name \s-1CLASS\s0 [, \s-1CM\s0]\fR" 4
.IX Item "generate_manager_class_name CLASS [, CM]"
Given the name of a Rose::DB::Object\-derived class, returns a class name for a Rose::DB::Object::Manager\-derived class to manage such objects.  The default implementation calls the auto_manager_class_name method on the convention manager object passed as the optional \s-1CM\s0 argument, or returned from the convention_manager method if a \s-1CM\s0 argument is not passed.
.IP "\fBinclude_tables [ \s-1REGEX\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "include_tables [ REGEX | ARRAYREF ]"
Get or set a regular expression or reference to an array of table names to include.  Table names that do not match \s-1REGEX\s0 or are not contained in \s-1ARRAYREF\s0 will be skipped by default during calls to the make_classes method.  Tables without primary keys are automatically (and always) skipped.
.Sp
Table names are compared to \s-1REGEX\s0 and the names in \s-1ARRAYREF\s0 in a case-insensitive manner.  To override this in the case of the \s-1REGEX\s0, add \f(CW\*(C`(?\-i)\*(C'\fR to the front of the \s-1REGEX\s0.  Otherwise, use the filter_tables method instead.
.IP "\fBinclude_predicated_unique_indexes \s-1BOOL\s0\fR" 4
.IX Item "include_predicated_unique_indexes BOOL"
Get or set a boolean value that will be assigned to the include_predicated_unique_indexes attribute of the Rose::DB::Object::Metadata object for each class created by the make_classes method.  The default value is false.
.IP "\fBinclude_views \s-1BOOL\s0\fR" 4
.IX Item "include_views BOOL"
If true, database views will also be processed by default during calls to the make_classes method.  Defaults to false.
.IP "\fBmake_classes [\s-1PARAMS\s0]\fR" 4
.IX Item "make_classes [PARAMS]"
Automatically create Rose::DB::Object and (optionally) Rose::DB::Object::Manager subclasses for some or all of the tables in a database.  The class creation process is controlled by the loader object's attributes.  Optional name/value pairs passed to this method may override some of those values.  Valid \s-1PARAMS\s0 are:
.RS 4
.IP "\fBdb [\s-1DB\s0]\fR" 4
.IX Item "db [DB]"
The Rose::DB\-derived object used to connect to the database.  This object will also be used as the prototype for the db object used by each Rose::DB::Object subclass created by this call to make_classes.  Defaults to the value of the loader object's db attribute.
.IP "\fBdb_class [\s-1CLASS\s0]\fR" 4
.IX Item "db_class [CLASS]"
The name of the Rose::DB\-derived class used to construct a db object if one has not been set via the parameter or object attribute of the same name.  Defaults to the value of the loader object's db_class attribute.
.IP "\fBinclude_tables [ \s-1REGEX\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "include_tables [ REGEX | ARRAYREF ]"
Table names that do not match \s-1REGEX\s0 or are not contained in \s-1ARRAYREF\s0 will be skipped.  Defaults to the value of the loader object's include_tables attribute.  Tables without primary keys are automatically (and always) skipped.
.Sp
Table names are compared to \s-1REGEX\s0 and the names in \s-1ARRAYREF\s0 in a case-insensitive manner.  To override this in the case of the \s-1REGEX\s0, add \f(CW\*(C`(?\-i)\*(C'\fR to the front of the \s-1REGEX\s0.  Otherwise, use the \f(CW\*(C`filter_tables\*(C'\fR parameter instead.
.IP "\fBexclude_tables [ \s-1REGEX\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "exclude_tables [ REGEX | ARRAYREF ]"
Table names that match \s-1REGEX\s0 or are contained in \s-1ARRAYREF\s0 will be skipped.  Defaults to the value of the loader object's exclude_tables attribute.  Tables without primary keys are automatically (and always) skipped.
.Sp
Table names are compared to \s-1REGEX\s0 and the names in \s-1ARRAYREF\s0 in a case-insensitive manner.  To override this in the case of the \s-1REGEX\s0, add \f(CW\*(C`(?\-i)\*(C'\fR to the front of the \s-1REGEX\s0.  Otherwise, use the \f(CW\*(C`filter_tables\*(C'\fR parameter instead.
.IP "\fBfilter_tables \s-1CODEREF\s0\fR" 4
.IX Item "filter_tables CODEREF"
A reference to a subroutine that takes a single table name argument and returns true if the table should be processed, false if it should be skipped.  The \f(CW$_\fR variable will also be set to the table name before the call.  This parameter cannot be combined with the \f(CW\*(C`exclude_tables\*(C'\fR or \f(CW\*(C`include_tables\*(C'\fR options.
.Sp
Defaults to the value of the loader object's filter_tables attribute, provided that both the \f(CW\*(C`exclude_tables\*(C'\fR and \f(CW\*(C`include_tables\*(C'\fR values are undefined.  Tables without primary keys are automatically skipped.
.IP "\fBforce_lowercase \s-1BOOL\s0\fR" 4
.IX Item "force_lowercase BOOL"
A boolean value that indicates whether or not metadata entity names should be forced to lowercase even when the related entity is uppercase or mixed case.  (\*(L"Metadata entities\*(R" are thing like columns, relationships, and foreign keys.)
.Sp
If this parameter is omitted and if the loader object's force_lowercase attribute is not defined, then the value is chosen based on the database currently being examined.  If the database is Oracle, then it defaults to true.  Otherwise, it defaults to false.
.Sp
The final value is propagated to the convention manager attribute of the same name.
.IP "\fBinclude_predicated_unique_indexes \s-1BOOL\s0\fR" 4
.IX Item "include_predicated_unique_indexes BOOL"
This value will be assigned to the include_predicated_unique_indexes attribute of the Rose::DB::Object::Metadata object for each class created by this method.  Defaults to the value of the loader object's include_predicated_unique_indexes attribute.
.IP "\fBinclude_views \s-1BOOL\s0\fR" 4
.IX Item "include_views BOOL"
If true, database views will also be processed.  Defaults to the value of the loader object's include_views attribute.
.IP "\fBpost_init_hook [ \s-1CODEREF\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "post_init_hook [ CODEREF | ARRAYREF ]"
A reference to a subroutine or a reference to an array of code references that will be called just after each Rose::DB::Object\-derived class is initialized.  Each referenced subroutine will be passed the class's metadata object plus any arguments to the initialize method.  Defaults to the value of the loader object's post_init_hook attribute.
.IP "\fBpre_init_hook [ \s-1CODEREF\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "pre_init_hook [ CODEREF | ARRAYREF ]"
A reference to a subroutine or a reference to an array of code references that will be called just before each Rose::DB::Object\-derived class is initialized.  Each referenced subroutine will be passed the class's metadata object plus any arguments to the initialize method.  Defaults to the value of the loader object's pre_init_hook attribute.
.IP "\fBrequire_primary_key \s-1BOOL\s0\fR" 4
.IX Item "require_primary_key BOOL"
If true, then any table that does not have a primary key will be skipped.  Defaults to the value of the loader object's require_primary_key attribute.  Note that a Rose::DB::Object\-derived class based on a table with no primary key will not function correctly in all circumstances.  Use this feature at your own risk.
.IP "\fBwarn_on_missing_pk \s-1BOOL\s0\fR" 4
.IX Item "warn_on_missing_pk BOOL"
This is an alias for the \f(CW\*(C`warn_on_missing_primary_key\*(C'\fR parameter.
.IP "\fBwarn_on_missing_primary_key \s-1BOOL\s0\fR" 4
.IX Item "warn_on_missing_primary_key BOOL"
If true, then any table that does not have a primary key will trigger a warning.
.Sp
If \f(CW\*(C`require_primary_key\*(C'\fR is false and the loader object's warn_on_missing_primary_key attribute is undefined, or if the \f(CW\*(C`warn_on_missing_primary_key\*(C'\fR parameter is set to an undefined valur or is not passed to the make_classes call at all, then \f(CW\*(C`warn_on_missing_primary_key\*(C'\fR is set to false.  Otherwise, it defaults to the value of the loader object's warn_on_missing_primary_key attribute.  Note that a Rose::DB::Object\-derived class based on a table with no primary key will not function correctly in all circumstances.
.Sp
These complicated defaults are intended to honor the intentions of the \f(CW\*(C`require_primary_key\*(C'\fR attribute/parameter.  If not requiring primary keys and no explicit decision has been made about whether to warn about missing primary keys, either in the parameters to the  make_classes call or in the loader object itself, then we don't warn about missing primary keys.  The idea is that not requiring primary keys is a strong indication that their absence is not worth a warning.
.IP "\fBwith_foreign_keys \s-1BOOL\s0\fR" 4
.IX Item "with_foreign_keys BOOL"
If true, set up foreign key metadata for each Rose::DB::Object\-derived.  Defaults to the value of the loader object's with_foreign_keys attribute.
.IP "\fBwith_managers \s-1BOOL\s0\fR" 4
.IX Item "with_managers BOOL"
If true, create Rose::DB::Object::Manager\-derived manager classes for each Rose::DB::Object subclass.  Defaults to the value of the loader object's with_managers attribute.
.Sp
The manager class name is determined by passing the Rose::DB::Object\-derived class name to the generate_manager_class_name method.
.Sp
The Rose::DB::Object subclass's metadata object's make_manager_class method will be used to create the manager class.  It will be passed the return value of the convention manager's auto_manager_base_name method as an argument.
.IP "\fBwith_relationships [ \s-1BOOL\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "with_relationships [ BOOL | ARRAYREF ]"
A boolean value or a reference to an array of relationship type names.  If set to a simple boolean value, then all types of relationships will be considered when making classes.  If set to a list of relationship type names, then only relationships of those types will be considered.  Defaults to the value of the loader object's with_relationships attribute.
.IP "\fBwith_unique_keys \s-1BOOL\s0\fR" 4
.IX Item "with_unique_keys BOOL"
If true, set up unique key metadata for each Rose::DB::Object\-derived.  Defaults to the value of the loader object's with_unique_keys attribute.
.RE
.RS 4
.Sp
Any remaining name/value parameters will be passed on to the call to auto_initialize used to set up each class.  For example, to ask the loader not to create any relationships, pass the \f(CW\*(C`with_relationships\*(C'\fR parameter with a false value.
.Sp
.Vb 1
\&    $loader\->make_classes(with_relationships => 0);
.Ve
.Sp
This parameter will be passed on to the auto_initialize method, which, in turn, will pass the parameter on to its own call to the auto_init_relationships method.  See the Rose::DB::Object::Metadata documentation for more information on these methods.
.Sp
Each Rose::DB::Object subclass will be created according to the \*(L"best practices\*(R" described in the Rose::DB::Object::Tutorial.  If a base class is not provided, one (with a dynamically generated name) will be created automatically.  The same goes for the db object.  If one is not set, then a new (again, dynamically named) subclass of Rose::DB, with its own private data source registry, will be created automatically.
.Sp
This method returns a list (in list context) or a reference to an array (in scalar context) of the names of all the classes that were created.  (This list will include manager class names as well, if any were created.)
.RE
.IP "\fBmake_modules [\s-1PARAMS\s0]\fR" 4
.IX Item "make_modules [PARAMS]"
Automatically create Rose::DB::Object and (optionally) Rose::DB::Object::Manager subclasses for some or all of the tables in a database, then create Perl module (*.pm) files for each class.
.Sp
This method calls make_classes to make the actual classes.
.Sp
\&\fBNote:\fR If you are trying to regenerate a set of module files that already exist in the target \f(CW\*(C`module_dir\*(C'\fR, please make sure that this \f(CW\*(C`module_dir\*(C'\fR is \fInot\fR in your \f(CW@INC\fR path.  (That is, make sure it is not in the set of paths that perl will search when looking for module files in response to a \f(CW\*(C`use\*(C'\fR or \f(CW\*(C`require\*(C'\fR statement.)  More generally, you must make sure that existing versions of the modules you are attempting to generate are not in your \f(CW@INC\fR path.
.Sp
(If you do not do this, when make_classes makes a class and looks for a related class, it will find and load the previously generated \f(CW\*(C`.pm\*(C'\fR file, which will then cause make_classes to skip that class later when it sees that it already exists in memory.  And if make_classes skips it, make_modules will never see it and therefore will never regenerate the \f(CW\*(C`.pm\*(C'\fR file.)
.Sp
This method takes all of the same parameters as make_classes, with several additions:
.RS 4
.IP "\fBmodule_dir \s-1DIR\s0\fR" 4
.IX Item "module_dir DIR"
The path to the directory where the Perl module files will be created.  For example, given a \s-1DIR\s0 of \*(L"/home/john/lib\*(R", the Perl module file for the class \f(CW\*(C`My::DB::Object\*(C'\fR would be located at \*(L"/home/john/lib/My/DB/Object.pm\*(R".
.Sp
Defaults to the value of the loader object's module_dir attribute.  If the module_dir attribute is also undefined, then the current working directory (as determined by a call to \fIcwd()\fR) is used instead.
.IP "\fBmodule_preamble [ \s-1SCALAR\s0 | \s-1CODE\s0 ]\fR" 4
.IX Item "module_preamble [ SCALAR | CODE ]"
If defined as a scalar, inserts the contents of the variable into the auto-generated file before any of the auto-generated class information.  If provided as a code ref, calls the indicated function, passing the metadata object as a parameter.  (The metadata object that belongs to the \f(CW\*(C`object_class\*(C'\fR and the Rose::DB::Object::Manager\-derived class name are passed if the module is a Rose::DB::Object::Manager\-derived class.)  The returned value of the function is inserted as the preamble text.
.Sp
Defaults to to the value of the loader object's module_preamble attribute.
.IP "\fBmodule_postamble [ \s-1SCALAR\s0 | \s-1CODE\s0 ]\fR" 4
.IX Item "module_postamble [ SCALAR | CODE ]"
If defined as a scalar, inserts the contents of the variable into the auto-generated file after any of the auto-generated class information.  If provided as a code ref, calls the indicated function, passing the metadata object as a parameter.  (The metadata object that belongs to the \f(CW\*(C`object_class\*(C'\fR and the Rose::DB::Object::Manager\-derived class name are passed if the module is a Rose::DB::Object::Manager\-derived class.)  The returned value of the function is inserted as the postamble text.
.Sp
Defaults to to the value of the loader object's module_postamble attribute.
.RE
.RS 4
.RE
.IP "\fBmodule_dir [\s-1DIR\s0]\fR" 4
.IX Item "module_dir [DIR]"
Get or set the path to the directory where make_modules will create its Perl modules files.  For example, given a \s-1DIR\s0 of \*(L"/home/john/lib\*(R", make_modules would create the file  \*(L"/home/john/lib/My/DB/Object.pm\*(R" for the class \f(CW\*(C`My::DB::Object\*(C'\fR.
.IP "\fBmodule_preamble [ \s-1SCALAR\s0 | \s-1CODE\s0 ]\fR" 4
.IX Item "module_preamble [ SCALAR | CODE ]"
If defined as a scalar, inserts the contents of the variable into the auto-generated file before any of the auto-generated class information.  If provided as a code ref, calls the indicated function, passing the metadata object as a parameter.  (The metadata object that belongs to the \f(CW\*(C`object_class\*(C'\fR and the Rose::DB::Object::Manager\-derived class name are passed if the module is a Rose::DB::Object::Manager\-derived class.)  The returned value of the function is inserted as the preamble text.
.IP "\fBmodule_postamble [ \s-1SCALAR\s0 | \s-1CODE\s0 ]\fR" 4
.IX Item "module_postamble [ SCALAR | CODE ]"
If defined as a scalar, inserts the contents of the variable into the auto-generated file after any of the auto-generated class information.  If provided as a code ref, calls the indicated function, passing the metadata object as a parameter.  (The metadata object that belongs to the \f(CW\*(C`object_class\*(C'\fR and the Rose::DB::Object::Manager\-derived class name are passed if the module is a Rose::DB::Object::Manager\-derived class.)  The returned value of the function is inserted as the postamble text.
.IP "\fBpre_init_hook [\s-1CODE\s0]\fR" 4
.IX Item "pre_init_hook [CODE]"
Get or set a reference to a subroutine to be called just before each Rose::DB::Object\-derived class is initializeed within the make_classes method.  The subroutine will be passed the class's metdata object as an argument.
.IP "\fBrequire_primary_key \s-1BOOL\s0\fR" 4
.IX Item "require_primary_key BOOL"
Get or set a boolean value that determines whether or not the make_classes method will skip any table that does not have a primary key will be skipped.  Defaults to true.
.Sp
Note that a Rose::DB::Object\-derived class based on a table with no primary key will not function correctly in all circumstances.  Use this feature at your own risk.
.IP "\fBwarn_on_missing_pk \s-1BOOL\s0\fR" 4
.IX Item "warn_on_missing_pk BOOL"
This is an alias for the warn_on_missing_primary_key method.
.IP "\fBwarn_on_missing_primary_key \s-1BOOL\s0\fR" 4
.IX Item "warn_on_missing_primary_key BOOL"
Get or set a boolean value that determines whether or not the make_classes method will emit a warning when it encounters a table that does not have a primary key.  Defaults to undefined.
.IP "\fBwith_foreign_keys \s-1BOOL\s0\fR" 4
.IX Item "with_foreign_keys BOOL"
If true, the make_classes method will set up foreign key metadata for each Rose::DB::Object\-derived class it creates.  Defaults to true.
.IP "\fBwith_managers [\s-1BOOL\s0]\fR" 4
.IX Item "with_managers [BOOL]"
If true, the make_classes method will create Rose::DB::Object::Manager\-derived manager classes for each Rose::DB::Object subclass by default.  Defaults to true.
.Sp
The manager class name is determined by passing the Rose::DB::Object\-derived class name to the generate_manager_class_name method.
.Sp
The Rose::DB::Object subclass's metadata object's make_manager_class method will be used to create the manager class.  It will be passed the return value of the convention manager's auto_manager_base_name method as an argument.
.IP "\fBwith_relationships [ \s-1BOOL\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "with_relationships [ BOOL | ARRAYREF ]"
A boolean value or a reference to an array of relationship type names.  If set to a simple boolean value, then the make_classes method will consider all types of relationships when making classes.  If set to a list of relationship type names, then only relationships of those types will be considered by  make_classes.  Defaults to true.
.IP "\fBwith_unique_keys \s-1BOOL\s0\fR" 4
.IX Item "with_unique_keys BOOL"
If true, the make_classes method will set up unique key metadata for each Rose::DB::Object\-derived class it creates.  Defaults to true.
.IP "\fBmanager_base_class \s-1CLASS\s0\fR" 4
.IX Item "manager_base_class CLASS"
This is an alias for the manager_base_classes method.
.IP "\fBmanager_base_classes [ \s-1CLASS\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "manager_base_classes [ CLASS | ARRAYREF ]"
Get or set the list of base classes to use for the Rose::DB::Object::Manager subclasses created by the make_classes method.  The argument may be a class name or a reference to an array of class names.  At least one of the classes should inherit from Rose::DB::Object::Manager.
.Sp
Returns a list (in list context) or reference to an array (in scalar context) of base class names.  Defaults to Rose::DB::Object::Manager.
.SH "AUTHOR"
.IX Header "AUTHOR"
John C. Siracusa (siracusa@gmail.com)
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2010 by John C. Siracusa.  All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same terms
as Perl itself.
