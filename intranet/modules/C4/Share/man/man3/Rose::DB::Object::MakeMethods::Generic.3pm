.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Rose::DB::Object::MakeMethods::Generic 3"
.TH Rose::DB::Object::MakeMethods::Generic 3 "2010-08-11" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Rose::DB::Object::MakeMethods::Generic \- Create generic object methods for Rose::DB::Object\-derived objects.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MyDBObject;
\&
\&  our @ISA = qw(Rose::DB::Object);
\&
\&  use Rose::DB::Object::MakeMethods::Generic
\&  (
\&    scalar => 
\&    [
\&      \*(Aqtype\*(Aq => 
\&      {
\&        with_init => 1,
\&        check_in  => [ qw(AA AAA C D) ],
\&      },
\&
\&      \*(Aqset_type\*(Aq => { hash_key => \*(Aqtype\*(Aq },
\&    ],
\&
\&    character =>
\&    [
\&      code => { length => 6 }
\&    ],
\&
\&    varchar =>
\&    [
\&      name => { length => 10 }
\&    ],
\&
\&    boolean => 
\&    [
\&      \*(Aqis_red\*(Aq,
\&      \*(Aqis_happy\*(Aq => { default => 1 },
\&    ],
\&  );
\&
\&  sub init_type { \*(AqC\*(Aq }
\&  ...
\&
\&  $obj = MyDBObject\->new(...);
\&
\&  print $obj\->type; # C
\&
\&  $obj\->name(\*(AqBob\*(Aq);   # set
\&  $obj\->set_type(\*(AqC\*(Aq); # set
\&  $obj\->type(\*(AqAA\*(Aq);    # set
\&
\&  $obj\->set_type; # Fatal error: no argument passed to "set" method
\&
\&  $obj\->name(\*(AqC\*(Aq x 40); # truncate on set
\&  print $obj\->name;     # \*(AqCCCCCCCCCC\*(Aq
\&
\&  $obj\->code(\*(AqABC\*(Aq); # pad on set
\&  print $obj\->code;  # \*(AqABC   \*(Aq
\&
\&  eval { $obj\->type(\*(Aqfoo\*(Aq) }; # fatal error: invalid value
\&
\&  print $obj\->name, \*(Aq is \*(Aq, $obj\->type; # get
\&
\&  $obj\->is_red;         # returns undef
\&  $obj\->is_red(\*(Aqtrue\*(Aq); # returns 1 (assuming "true" a
\&                        # valid boolean literal according to
\&                        # $obj\->db\->parse_boolean(\*(Aqtrue\*(Aq))
\&  $obj\->is_red(\*(Aq\*(Aq);     # returns 0
\&  $obj\->is_red;         # returns 0
\&
\&  $obj\->is_happy;       # returns 1
\&
\&  ...
\&
\&  package Person;
\&
\&  our @ISA = qw(Rose::DB::Object);
\&  ...
\&  use Rose::DB::Object::MakeMethods::Generic
\&  (
\&    scalar => \*(Aqname\*(Aq,
\&
\&    set => 
\&    [
\&      \*(Aqnicknames\*(Aq,
\&      \*(Aqparts\*(Aq => { default => [ qw(arms legs) ] },
\&    ],
\&
\&    # See the Rose::DB::Object::Metadata::Relationship::ManyToMany
\&    # documentation for a more complete example
\&    objects_by_map =>
\&    [
\&      friends =>
\&      {
\&        map_class    => \*(AqFriendMap\*(Aq,
\&        manager_args => { sort_by => Friend\->meta\->table . \*(Aq.name\*(Aq },
\&      },
\&    ],
\&  );
\&  ...
\&
\&  @parts = $person\->parts; # (\*(Aqarms\*(Aq, \*(Aqlegs\*(Aq)
\&  $parts = $person\->parts; # [ \*(Aqarms\*(Aq, \*(Aqlegs\*(Aq ]
\&
\&  $person\->nicknames(\*(AqJack\*(Aq, \*(AqGimpy\*(Aq);   # set with list
\&  $person\->nicknames([ \*(AqSlim\*(Aq, \*(AqGip\*(Aq ]); # set with array ref
\&
\&  print join(\*(Aq, \*(Aq, map { $_\->name } $person\->friends);
\&  ...
\&
\&  package Program;
\&
\&  our @ISA = qw(Rose::DB::Object);
\&  ...
\&  use Rose::DB::Object::MakeMethods::Generic
\&  (
\&    objects_by_key =>
\&    [
\&      bugs => 
\&      {
\&        class => \*(AqBug\*(Aq,
\&        key_columns =>
\&        {
\&          # Map Program column names to Bug column names
\&          id      => \*(Aqprogram_id\*(Aq,
\&          version => \*(Aqversion\*(Aq,
\&        },
\&        manager_args => 
\&        {
\&          sort_by => Bug\->meta\->table . \*(Aq.date_submitted DESC\*(Aq,
\&        },
\&        query_args   => [ state => { ne => \*(Aqclosed\*(Aq } ],
\&      },
\&    ]
\&  );
\&  ...
\&
\&  $prog = Program\->new(id => 5, version => \*(Aq3.0\*(Aq, ...);
\&
\&  $bugs = $prog\->bugs;
\&
\&  # Calls (essentially):
\&  #
\&  # Rose::DB::Object::Manager\->get_objects(
\&  #   db           => $prog\->db, # share_db defaults to true
\&  #   object_class => \*(AqBug\*(Aq,
\&  #   query =>
\&  #   {
\&  #     program_id => 5,     # value of $prog\->id
\&  #     version    => \*(Aq3.0\*(Aq, # value of $prog\->version
\&  #     state      => { ne => \*(Aqclosed\*(Aq },
\&  #   },
\&  #   sort_by => \*(Aqdate_submitted DESC\*(Aq);
\&
\&  ...
\&
\&  package Product;
\&
\&  our @ISA = qw(Rose::DB::Object);
\&  ...
\&  use Rose::DB::Object::MakeMethods::Generic
\&  (
\&    object_by_key =>
\&    [
\&      category => 
\&      {
\&        class => \*(AqCategory\*(Aq,
\&        key_columns =>
\&        {
\&          # Map Product column names to Category column names
\&          category_id => \*(Aqid\*(Aq,
\&        },
\&      },
\&    ]
\&  );
\&  ...
\&
\&  $product = Product\->new(id => 5, category_id => 99);
\&
\&  $category = $product\->category;
\&
\&  # $product\->category call is roughly equivalent to:
\&  #
\&  # $cat = Category\->new(id => $product\->category_id,
\&  #                      db => $prog\->db);
\&  #
\&  # $ret = $cat\->load;
\&  # return $ret  unless($ret);
\&  # return $cat;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Rose::DB::Object::MakeMethods::Generic is a method maker that inherits from Rose::Object::MakeMethods.  See the Rose::Object::MakeMethods documentation to learn about the interface.  The method types provided by this module are described below.
.PP
All method types defined by this module are designed to work with objects that are subclasses of (or otherwise conform to the interface of) Rose::DB::Object.  In particular, the object is expected to have a db method that returns a Rose::DB\-derived object.  See the Rose::DB::Object documentation for more details.
.SH "METHODS TYPES"
.IX Header "METHODS TYPES"
.IP "\fBarray\fR" 4
.IX Item "array"
Create get/set methods for \*(L"array\*(R" attributes.   A \*(L"array\*(R" column in a database table contains an ordered list of values.  Not all databases support an \*(L"array\*(R" column type.  Check the Rose::DB documentation for your database type.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.IP "\fBdefault \s-1VALUE\s0\fR" 4
.IX Item "default VALUE"
.PD
Determines the default value of the attribute.  The value should be a reference to an array.
.IP "\fBhash_key \s-1NAME\s0\fR" 4
.IX Item "hash_key NAME"
The key inside the hash-based object to use for the storage of this
attribute.  Defaults to the name of the method.
.IP "\fBinterface \s-1NAME\s0\fR" 4
.IX Item "interface NAME"
Choose the interface.  The default is \f(CW\*(C`get_set\*(C'\fR.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.IP "\fBget_set\fR" 4
.IX Item "get_set"
.PD
Creates a get/set method for a \*(L"array\*(R" object attribute.  A \*(L"array\*(R" column in a database table contains an ordered list of values.
.Sp
When setting the attribute, the value is passed through the parse_array method of the object's db attribute.
.Sp
When saving to the database, if the attribute value is defined, the method will pass the attribute value through the format_array method of the object's db attribute before returning it.
.Sp
When not saving to the database, the method returns the array as a list in list context, or as a reference to the array in scalar context.
.IP "\fBget\fR" 4
.IX Item "get"
Creates an accessor method for a \*(L"array\*(R" object attribute.  A \*(L"array\*(R" column in a database table contains an ordered list of values.
.Sp
When saving to the database, if the attribute value is defined, the method will pass the attribute value through the format_array method of the object's db attribute before returning it.
.Sp
When not saving to the database, the method returns the array as a list in list context, or as a reference to the array in scalar context.
.IP "\fBset\fR" 4
.IX Item "set"
Creates a mutator method for a \*(L"array\*(R" object attribute.  A \*(L"array\*(R" column in a database table contains an ordered list of values.
.Sp
When setting the attribute, the value is passed through the parse_array method of the object's db attribute.
.Sp
When saving to the database, if the attribute value is defined, the method will pass the attribute value through the format_array method of the object's db attribute before returning it.
.Sp
When not saving to the database, the method returns the array as a list in list context, or as a reference to the array in scalar context.
.Sp
If called with no arguments, a fatal error will occur.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&    package Person;
\&
\&    our @ISA = qw(Rose::DB::Object);
\&    ...
\&    use Rose::DB::Object::MakeMethods::Generic
\&    (
\&      array => 
\&      [
\&        \*(Aqnicknames\*(Aq,
\&        set_nicks => { interface => \*(Aqset\*(Aq, hash_key => \*(Aqnicknames\*(Aq },
\&        parts     => { default => [ qw(arms legs) ] },
\&      ],
\&    );
\&    ...
\&
\&    @parts = $person\->parts; # (\*(Aqarms\*(Aq, \*(Aqlegs\*(Aq)
\&    $parts = $person\->parts; # [ \*(Aqarms\*(Aq, \*(Aqlegs\*(Aq ]
\&
\&    $person\->nicknames(\*(AqJack\*(Aq, \*(AqGimpy\*(Aq);   # set with list
\&    $person\->nicknames([ \*(AqSlim\*(Aq, \*(AqGip\*(Aq ]); # set with array ref
\&
\&    $person\->set_nicks(\*(AqJack\*(Aq, \*(AqGimpy\*(Aq);   # set with list
\&    $person\->set_nicks([ \*(AqSlim\*(Aq, \*(AqGip\*(Aq ]); # set with array ref
.Ve
.RE
.IP "\fBbitfield\fR" 4
.IX Item "bitfield"
Create get/set methods for bitfield attributes.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.IP "\fBdefault \s-1VALUE\s0\fR" 4
.IX Item "default VALUE"
.PD
Determines the default value of the attribute.
.IP "\fBhash_key \s-1NAME\s0\fR" 4
.IX Item "hash_key NAME"
The key inside the hash-based object to use for the storage of this
attribute.  Defaults to the name of the method.
.IP "\fBinterface \s-1NAME\s0\fR" 4
.IX Item "interface NAME"
Choose the interface.  The default is \f(CW\*(C`get_set\*(C'\fR.
.IP "\fBintersects \s-1NAME\s0\fR" 4
.IX Item "intersects NAME"
Set the name of the \*(L"intersects\*(R" method.  (See \f(CW\*(C`with_intersects\*(C'\fR below.)  Defaults to the bitfield attribute method name with \*(L"_intersects\*(R" appended.
.IP "\fBbits \s-1INT\s0\fR" 4
.IX Item "bits INT"
The number of bits in the bitfield.  Defaults to 32.
.IP "\fBwith_intersects \s-1BOOL\s0\fR" 4
.IX Item "with_intersects BOOL"
This option is only applicable with the \f(CW\*(C`get_set\*(C'\fR interface.
.Sp
If true, create an \*(L"intersects\*(R" helper method in addition to the \f(CW\*(C`get_set\*(C'\fR method.  The intersection method name will be the attribute method name with \*(L"_intersects\*(R" appended, or the value of the \f(CW\*(C`intersects\*(C'\fR option, if it is passed.
.Sp
The \*(L"intersects\*(R" method will return true if there is any intersection between its arguments and the value of the bitfield attribute (i.e., if Bit::Vector's Intersection method returns a value greater than zero), false (but defined) otherwise.  Its argument is passed through the parse_bitfield method of the object's db attribute before being tested for intersection.  Returns undef if the bitfield is not defined.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.IP "\fBget_set\fR" 4
.IX Item "get_set"
.PD
Creates a get/set method for a bitfield attribute.  When setting the attribute, the value is passed through the parse_bitfield method of the object's db attribute before being assigned.
.Sp
When saving to the database, the method will pass the attribute value through the format_bitfield method of the object's db attribute before returning it.  Otherwise, the value is returned as-is.
.IP "\fBget\fR" 4
.IX Item "get"
Creates an accessor method for a bitfield attribute.  When saving to the database, the method will pass the attribute value through the format_bitfield method of the object's db attribute before returning it.  Otherwise, the value is returned as-is.
.IP "\fBset\fR" 4
.IX Item "set"
Creates a mutator method for a bitfield attribute.  When setting the attribute, the value is passed through the parse_bitfield method of the object's db attribute before being assigned.
.Sp
When saving to the database, the method will pass the attribute value through the format_bitfield method of the object's db attribute before returning it.  Otherwise, the value is returned as-is.
.Sp
If called with no arguments, a fatal error will occur.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&    package MyDBObject;
\&
\&    our @ISA = qw(Rose::DB::Object);
\&
\&    use Rose::DB::Object::MakeMethods::Generic
\&    (
\&      bitfield => 
\&      [
\&        \*(Aqflags\*(Aq => { size => 32, default => 2 },
\&        \*(Aqbits\*(Aq  => { size => 16, with_intersects => 1 },
\&      ],
\&    );
\&
\&    ...
\&
\&    print $o\->flags\->to_Bin; # 00000000000000000000000000000010
\&
\&    $o\->bits(\*(Aq101\*(Aq);
\&
\&    $o\->bits_intersects(\*(Aq100\*(Aq); # true
\&    $o\->bits_intersects(\*(Aq010\*(Aq); # false
.Ve
.RE
.IP "\fBboolean\fR" 4
.IX Item "boolean"
Create get/set methods for boolean attributes.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.IP "\fBdefault \s-1VALUE\s0\fR" 4
.IX Item "default VALUE"
.PD
Determines the default value of the attribute.
.IP "\fBhash_key \s-1NAME\s0\fR" 4
.IX Item "hash_key NAME"
The key inside the hash-based object to use for the storage of this
attribute.  Defaults to the name of the method.
.IP "\fBinterface \s-1NAME\s0\fR" 4
.IX Item "interface NAME"
Choose the interface.  The default is \f(CW\*(C`get_set\*(C'\fR.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.IP "\fBget_set\fR" 4
.IX Item "get_set"
.PD
Creates a get/set method for a boolean attribute.  When setting the attribute, if the value is \*(L"true\*(R" according to Perl's rules, it is compared to a list of \*(L"common\*(R" true and false values: 1, 0, 1.0 (with any number of zeros), 0.0 (with any number of zeros), t, true, f, false, yes, no.  (All are case-insensitive.)  If the value matches, then it is set to true (1) or false (0) accordingly.
.Sp
If the value does not match any of those, then it is passed through the parse_boolean method of the object's db attribute.  If parse_boolean returns true (1) or false (0), then the attribute is set accordingly.  If parse_boolean returns undef, a fatal error will occur.  If the value is \*(L"false\*(R" according to Perl's rules, the attribute is set to zero (0).
.Sp
When saving to the database, the method will pass the attribute value through the format_boolean method of the object's db attribute before returning it.  Otherwise, the value is returned as-is.
.IP "\fBget\fR" 4
.IX Item "get"
Creates an accessor method for a boolean attribute.  When saving to the database, the method will pass the attribute value through the format_boolean method of the object's db attribute before returning it.  Otherwise, the value is returned as-is.
.IP "\fBset\fR" 4
.IX Item "set"
Creates a mutator method for a boolean attribute.  When setting the attribute, if the value is \*(L"true\*(R" according to Perl's rules, it is compared to a list of \*(L"common\*(R" true and false values: 1, 0, 1.0 (with any number of zeros), 0.0 (with any number of zeros), t, true, f, false, yes, no.  (All are case-insensitive.)  If the value matches, then it is set to true (1) or false (0) accordingly.
.Sp
If the value does not match any of those, then it is passed through the parse_boolean method of the object's db attribute.  If parse_boolean returns true (1) or false (0), then the attribute is set accordingly.  If parse_boolean returns undef, a fatal error will occur.  If the value is \*(L"false\*(R" according to Perl's rules, the attribute is set to zero (0).
.Sp
If called with no arguments, a fatal error will occur.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&    package MyDBObject;
\&
\&    our @ISA = qw(Rose::DB::Object);
\&
\&    use Rose::DB::Object::MakeMethods::Generic
\&    (
\&      boolean => 
\&      [
\&        \*(Aqis_red\*(Aq,
\&        \*(Aqis_happy\*(Aq  => { default => 1 },
\&        \*(Aqset_happy\*(Aq => { interface => \*(Aqset\*(Aq, hash_key => \*(Aqis_happy\*(Aq },
\&      ],
\&    );
\&
\&    $obj\->is_red;         # returns undef
\&    $obj\->is_red(\*(Aqtrue\*(Aq); # returns 1 (assuming "true" a
\&                          # valid boolean literal according to
\&                          # $obj\->db\->parse_boolean(\*(Aqtrue\*(Aq))
\&    $obj\->is_red(\*(Aq\*(Aq);     # returns 0
\&    $obj\->is_red;         # returns 0
\&
\&    $obj\->is_happy;       # returns 1
\&    $obj\->set_happy(0);   # returns 0
\&    $obj\->is_happy;       # returns 0
.Ve
.RE
.IP "\fBcharacter\fR" 4
.IX Item "character"
Create get/set methods for fixed-length character string attributes.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.IP "\fBcheck_in \s-1ARRAYREF\s0\fR" 4
.IX Item "check_in ARRAYREF"
.PD
A reference to an array of valid values.  When setting the attribute, if the new value is not equal (string comparison) to one of the valid values, a fatal error will occur.
.IP "\fBdefault \s-1VALUE\s0\fR" 4
.IX Item "default VALUE"
Determines the default value of the attribute.
.IP "\fBhash_key \s-1NAME\s0\fR" 4
.IX Item "hash_key NAME"
The key inside the hash-based object to use for the storage of this attribute.  Defaults to the name of the method.
.IP "\fBinit_method \s-1NAME\s0\fR" 4
.IX Item "init_method NAME"
The name of the method to call when initializing the value of an undefined attribute.  Defaults to the method name with the prefix \f(CW\*(C`init_\*(C'\fR added.  This option implies \f(CW\*(C`with_init\*(C'\fR.
.IP "\fBinterface \s-1NAME\s0\fR" 4
.IX Item "interface NAME"
Choose the interface.  The default is \f(CW\*(C`get_set\*(C'\fR.
.IP "\fBlength \s-1INT\s0\fR" 4
.IX Item "length INT"
The number of characters in the string.  Any strings shorter than this will be padded with spaces to meet the length requirement.  If length is omitted, the string will be left unmodified.
.IP "\fBoverflow \s-1BEHAVIOR\s0\fR" 4
.IX Item "overflow BEHAVIOR"
Determines the behavior when the value is greater than the number of characters specified by the \f(CW\*(C`length\*(C'\fR option.  Valid values for \s-1BEHAVIOR\s0 are:
.RS 4
.IP "\fBfatal\fR" 4
.IX Item "fatal"
Throw an exception.
.IP "\fBtruncate\fR" 4
.IX Item "truncate"
Truncate the value to the correct length.
.IP "\fBwarn\fR" 4
.IX Item "warn"
Print a warning message.
.RE
.RS 4
.RE
.IP "\fBwith_init \s-1BOOL\s0\fR" 4
.IX Item "with_init BOOL"
Modifies the behavior of the \f(CW\*(C`get_set\*(C'\fR and \f(CW\*(C`get\*(C'\fR interfaces.  If the attribute is undefined, the method specified by the \f(CW\*(C`init_method\*(C'\fR option is called and the attribute is set to the return value of that
method.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.IP "\fBget_set\fR" 4
.IX Item "get_set"
.PD
Creates a get/set method for a fixed-length character string attribute.  When setting, any strings longer than \f(CW\*(C`length\*(C'\fR will be truncated, and any strings shorter will be padded with spaces to meet the length requirement.  If \f(CW\*(C`length\*(C'\fR is omitted, the string will be left unmodified.
.IP "\fBget\fR" 4
.IX Item "get"
Creates an accessor method for a fixed-length character string attribute.
.IP "\fBset\fR" 4
.IX Item "set"
Creates a mutator method for a fixed-length character string attribute.  Any strings longer than \f(CW\*(C`length\*(C'\fR will be truncated, and any strings shorter will be padded with spaces to meet the length requirement.  If \f(CW\*(C`length\*(C'\fR is omitted, the string will be left unmodified.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&    package MyDBObject;
\&
\&    our @ISA = qw(Rose::DB::Object);
\&
\&    use Rose::DB::Object::MakeMethods::Generic
\&    (
\&      character => 
\&      [
\&        \*(Aqname\*(Aq => { length => 3 },
\&      ],
\&    );
\&
\&    ...
\&
\&    $o\->name(\*(AqJohn\*(Aq); # truncates on set
\&    print $o\->name;   # \*(AqJoh\*(Aq
\&
\&    $o\->name(\*(AqA\*(Aq); # pads on set
\&    print $o\->name;   # \*(AqA  \*(Aq
.Ve
.RE
.IP "\fBenum\fR" 4
.IX Item "enum"
Create get/set methods for enum attributes.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.IP "\fBdefault \s-1VALUE\s0\fR" 4
.IX Item "default VALUE"
.PD
Determines the default value of the attribute.
.IP "\fBvalues \s-1ARRAYREF\s0\fR" 4
.IX Item "values ARRAYREF"
A reference to an array of the enum values.  This attribute is required.  When setting the attribute, if the new value is not equal (string comparison) to one of the enum values, a fatal error will occur.
.IP "\fBhash_key \s-1NAME\s0\fR" 4
.IX Item "hash_key NAME"
The key inside the hash-based object to use for the storage of this attribute.  Defaults to the name of the method.
.IP "\fBinit_method \s-1NAME\s0\fR" 4
.IX Item "init_method NAME"
The name of the method to call when initializing the value of an undefined attribute.  Defaults to the method name with the prefix \f(CW\*(C`init_\*(C'\fR added.  This option implies \f(CW\*(C`with_init\*(C'\fR.
.IP "\fBinterface \s-1NAME\s0\fR" 4
.IX Item "interface NAME"
Choose the interface.  The \f(CW\*(C`get_set\*(C'\fR interface is the default.
.IP "\fBwith_init \s-1BOOL\s0\fR" 4
.IX Item "with_init BOOL"
Modifies the behavior of the \f(CW\*(C`get_set\*(C'\fR and \f(CW\*(C`get\*(C'\fR interfaces.  If the attribute is undefined, the method specified by the \f(CW\*(C`init_method\*(C'\fR option is called and the attribute is set to the return value of that
method.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.IP "\fBget_set\fR" 4
.IX Item "get_set"
.PD
Creates a get/set method for an enum attribute.  When called with an argument, the value of the attribute is set.  If the value is invalid, a fatal error will occur.  The current value of the attribute is returned.
.IP "\fBget\fR" 4
.IX Item "get"
Creates an accessor method for an object attribute that returns the current value of the attribute.
.IP "\fBset\fR" 4
.IX Item "set"
Creates a mutator method for an object attribute.  When called with an argument, the value of the attribute is set.  If the value is invalid, a fatal error will occur.  If called with no arguments, a fatal error will occur.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&    package MyDBObject;
\&
\&    our @ISA = qw(Rose::DB::Object);
\&
\&    use Rose::DB::Object::MakeMethods::Generic
\&    (
\&      enum => 
\&      [
\&        type  => { values => [ qw(main aux extra) ], default => \*(Aqaux\*(Aq },
\&        stage => { values => [ qw(new std old) ], with_init => 1 },
\&      ],
\&    );
\&
\&    sub init_stage { \*(Aqnew\*(Aq }
\&    ...
\&
\&    $o = MyDBObject\->new(...);
\&
\&    print $o\->type;   # aux
\&    print $o\->stage;  # new
\&
\&    $o\->type(\*(Aqaux\*(Aq);  # set
\&    $o\->stage(\*(Aqold\*(Aq); # set
\&
\&    eval { $o\->type(\*(Aqfoo\*(Aq) }; # fatal error: invalid value
\&
\&    print $o\->type, \*(Aq is at stage \*(Aq, $o\->stage; # get
.Ve
.RE
.IP "\fBinteger\fR" 4
.IX Item "integer"
Create get/set methods for integer attributes.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.IP "\fBdefault \s-1VALUE\s0\fR" 4
.IX Item "default VALUE"
.PD
Determines the default value of the attribute.
.IP "\fBhash_key \s-1NAME\s0\fR" 4
.IX Item "hash_key NAME"
The key inside the hash-based object to use for the storage of this attribute.  Defaults to the name of the method.
.IP "\fBinit_method \s-1NAME\s0\fR" 4
.IX Item "init_method NAME"
The name of the method to call when initializing the value of an undefined attribute.  Defaults to the method name with the prefix \f(CW\*(C`init_\*(C'\fR added.  This option implies \f(CW\*(C`with_init\*(C'\fR.
.IP "\fBinterface \s-1NAME\s0\fR" 4
.IX Item "interface NAME"
Choose the interface.  The \f(CW\*(C`get_set\*(C'\fR interface is the default.
.IP "\fBwith_init \s-1BOOL\s0\fR" 4
.IX Item "with_init BOOL"
Modifies the behavior of the \f(CW\*(C`get_set\*(C'\fR and \f(CW\*(C`get\*(C'\fR interfaces.  If the attribute is undefined, the method specified by the \f(CW\*(C`init_method\*(C'\fR option is called and the attribute is set to the return value of that method.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.IP "\fBget_set\fR" 4
.IX Item "get_set"
.PD
Creates a get/set method for an integer object attribute.  When called with an argument, the value of the attribute is set.  The current value of the attribute is returned.
.IP "\fBget\fR" 4
.IX Item "get"
Creates an accessor method for an integer object attribute that returns the current value of the attribute.
.IP "\fBset\fR" 4
.IX Item "set"
Creates a mutator method for an integer object attribute.  When called with an argument, the value of the attribute is set.  If called with no arguments, a fatal error will occur.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&    package MyDBObject;
\&
\&    our @ISA = qw(Rose::DB::Object);
\&
\&    use Rose::DB::Object::MakeMethods::Generic
\&    (
\&      integer => 
\&      [
\&        code => { default => 99  },
\&        type => { with_init => 1 }
\&      ],
\&    );
\&
\&    sub init_type { 123 }
\&    ...
\&
\&    $o = MyDBObject\->new(...);
\&
\&    print $o\->code; # 99
\&    print $o\->type; # 123
\&
\&    $o\->code(8675309); # set
\&    $o\->type(42);      # set
.Ve
.RE
.IP "\fBobjects_by_key\fR" 4
.IX Item "objects_by_key"
Create get/set methods for an array of Rose::DB::Object\-derived objects fetched based on a key formed from attributes of the current object.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.IP "\fBclass \s-1CLASS\s0\fR" 4
.IX Item "class CLASS"
.PD
The name of the Rose::DB::Object\-derived class of the objects to be fetched.  This option is required.
.IP "\fBhash_key \s-1NAME\s0\fR" 4
.IX Item "hash_key NAME"
The key inside the hash-based object to use for the storage of the fetched objects.  Defaults to the name of the method.
.IP "\fBkey_columns \s-1HASHREF\s0\fR" 4
.IX Item "key_columns HASHREF"
A reference to a hash that maps column names in the current object to those in the objects to be fetched.  This option is required.
.IP "\fBmanager_args \s-1HASHREF\s0\fR" 4
.IX Item "manager_args HASHREF"
A reference to a hash of arguments passed to the \f(CW\*(C`manager_class\*(C'\fR when fetching objects.  If \f(CW\*(C`manager_class\*(C'\fR defaults to Rose::DB::Object::Manager, the following argument is added to the \f(CW\*(C`manager_args\*(C'\fR hash: \f(CW\*(C`object_class => CLASS\*(C'\fR, where \s-1CLASS\s0 is the value of the \f(CW\*(C`class\*(C'\fR option (see above).  If \f(CW\*(C`manager_args\*(C'\fR includes a \*(L"sort_by\*(R" argument, be sure to prefix each column name with the appropriate table name.  (See the synopsis for examples.)
.IP "\fBmanager_class \s-1CLASS\s0\fR" 4
.IX Item "manager_class CLASS"
The name of the Rose::DB::Object::Manager\-derived class used to fetch the objects.  The \f(CW\*(C`manager_method\*(C'\fR class method is called on this class.  Defaults to Rose::DB::Object::Manager.
.IP "\fBmanager_method \s-1NAME\s0\fR" 4
.IX Item "manager_method NAME"
The name of the class method to call on \f(CW\*(C`manager_class\*(C'\fR in order to fetch the objects.  Defaults to \f(CW\*(C`get_objects\*(C'\fR.
.IP "\fBmanager_count_method \s-1NAME\s0\fR" 4
.IX Item "manager_count_method NAME"
The name of the class method to call on \f(CW\*(C`manager_class\*(C'\fR in order to count the objects.  Defaults to \f(CW\*(C`get_objects_count\*(C'\fR.
.IP "\fBinterface \s-1NAME\s0\fR" 4
.IX Item "interface NAME"
Choose the interface.  The \f(CW\*(C`get_set\*(C'\fR interface is the default.
.IP "\fBrelationship \s-1OBJECT\s0\fR" 4
.IX Item "relationship OBJECT"
The Rose::DB::Object::Metadata::Relationship object that describes the \*(L"key\*(R" through which the \*(L"objects_by_key\*(R" are fetched.  This is required when using the \*(L"add_now\*(R", \*(L"add_on_save\*(R", and \*(L"get_set_on_save\*(R" interfaces.
.IP "\fBshare_db \s-1BOOL\s0\fR" 4
.IX Item "share_db BOOL"
If true, the db attribute of the current object is shared with all of the objects fetched.  Defaults to true.
.IP "\fBquery_args \s-1ARRAYREF\s0\fR" 4
.IX Item "query_args ARRAYREF"
A reference to an array of arguments added to the value of the \f(CW\*(C`query\*(C'\fR parameter passed to the call to \f(CW\*(C`manager_class\*(C'\fR's \f(CW\*(C`manager_method\*(C'\fR class method.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.IP "\fBcount\fR" 4
.IX Item "count"
.PD
Creates a method that will attempt to count Rose::DB::Object\-derived objects based on a key formed from attributes of the current object, plus any additional parameters passed to the method call.  Note that this method counts the objects \fIin the database at the time of the call\fR.  This may be different than the number of objects attached to the current object or otherwise in memory.
.Sp
Since the objects counted are partially determined by the arguments passed to the method, the count is not retained.  It is simply returned.  Each call counts the specified objects again, even if the arguments are the same as the previous call.
.Sp
If the first argument is a reference to a hash or array, it is converted to a reference to an array (if necessary) and taken as the value of the \f(CW\*(C`query\*(C'\fR parameter.  All arguments are passed on to the \f(CW\*(C`manager_class\*(C'\fR's \f(CW\*(C`manager_count_method\*(C'\fR method, augmented by the key formed from attributes of the current object.  Query parameters are added to the existing contents of the \f(CW\*(C`query\*(C'\fR parameter.  Other parameters replace existing parameters if the existing values are simple scalars, or augment existing parameters if the existing values are references to hashes or arrays.
.Sp
The count may fail for several reasons.  The count will not even be attempted if any of the key attributes in the current object are undefined.  Instead, undef (in scalar context) or an empty list (in list context) will be returned.  If the call to \f(CW\*(C`manager_class\*(C'\fR's \f(CW\*(C`manager_count_method\*(C'\fR method returns undef, the behavior is determined by the metadata object's error_mode.  If the mode is \f(CW\*(C`return\*(C'\fR, that false value (in scalar context) or an empty list (in list context) is returned.
.Sp
If the count succeeds, the number is returned.  (If the count finds zero objects, the count will be 0.  This is still considered success.)
.IP "\fBfind\fR" 4
.IX Item "find"
Creates a method that will attempt to fetch Rose::DB::Object\-derived objects based on a key formed from attributes of the current object, plus any additional parameters passed to the method call.  Since the objects fetched are partially determined by the arguments passed to the method, the list of objects is not retained.  It is simply returned.  Each call fetches the requested objects again, even if the arguments are the same as the previous call.
.Sp
If the first argument is a reference to a hash or array, it is converted to a reference to an array (if necessary) and taken as the value of the \f(CW\*(C`query\*(C'\fR parameter.  All arguments are passed on to the \f(CW\*(C`manager_class\*(C'\fR's \f(CW\*(C`manager_method\*(C'\fR method, augmented by the key formed from attributes of the current object.  Query parameters are added to the existing contents of the \f(CW\*(C`query\*(C'\fR parameter.  Other parameters replace existing parameters if the existing values are simple scalars, or augment existing parameters if the existing values are references to hashes or arrays.
.Sp
The fetch may fail for several reasons.  The fetch will not even be attempted if any of the key attributes in the current object are undefined.  Instead, undef (in scalar context) or an empty list (in list context) will be returned.  If the call to \f(CW\*(C`manager_class\*(C'\fR's \f(CW\*(C`manager_method\*(C'\fR method returns false, the behavior is determined by the metadata object's error_mode.  If the mode is \f(CW\*(C`return\*(C'\fR, that false value (in scalar context) or an empty list (in list context) is returned.
.Sp
If the fetch succeeds, a list (in list context) or a reference to the array of objects (in scalar context) is returned.  (If the fetch finds zero objects, the list or array reference will simply be empty.  This is still considered success.)
.IP "\fBiterator\fR" 4
.IX Item "iterator"
Behaves just like \fBfind\fR but returns an iterator rather than an array or arrayref.
.IP "\fBget_set\fR" 4
.IX Item "get_set"
Creates a method that will attempt to fetch Rose::DB::Object\-derived objects based on a key formed from attributes of the current object.
.Sp
If passed a single argument of undef, the \f(CW\*(C`hash_key\*(C'\fR used to store the objects is set to undef.  Otherwise, the argument(s) must be a list or reference to an array containing items in one or more of the following formats:
.RS 4
.IP "\(bu" 4
An object of type \f(CW\*(C`class\*(C'\fR.
.IP "\(bu" 4
A reference to a hash containing method name/value pairs.
.IP "\(bu" 4
A single scalar primary key value.
.RE
.RS 4
.Sp
The latter two formats will be used to construct an object of type \f(CW\*(C`class\*(C'\fR.  A single primary key value is only a valid argument format if the \f(CW\*(C`class\*(C'\fR in question has a single-column primary key.  A hash reference argument must contain sufficient information for the object to be uniquely identified.
.Sp
The list of object is assigned to \f(CW\*(C`hash_key\*(C'\fR.  Note that these objects are \fBnot\fR added to the database.  Use the \f(CW\*(C`get_set_now\*(C'\fR or \f(CW\*(C`get_set_on_save\*(C'\fR interface to do that.
.Sp
If called with no arguments and the hash key used to store the list of objects is defined, the list (in list context) or a reference to that array (in scalar context) of objects is returned.  Otherwise, the objects are fetched.
.Sp
The fetch may fail for several reasons.  The fetch will not even be attempted if any of the key attributes in the current object are undefined.  Instead, undef (in scalar context) or an empty list (in list context) will be returned.  If the call to \f(CW\*(C`manager_class\*(C'\fR's \f(CW\*(C`manager_method\*(C'\fR method returns false, the behavior is determined by the metadata object's error_mode.  If the mode is \f(CW\*(C`return\*(C'\fR, that false value (in scalar context) or an empty list (in list context) is returned.
.Sp
If the fetch succeeds, a list (in list context) or a reference to the array of objects (in scalar context) is returned.  (If the fetch finds zero objects, the list or array reference will simply be empty.  This is still considered success.)
.RE
.IP "\fBget_set_now\fR" 4
.IX Item "get_set_now"
Creates a method that will attempt to fetch Rose::DB::Object\-derived objects based on a key formed from attributes of the current object, and will also save the objects to the database when called with arguments.  The objects do not have to already exist in the database; they will be inserted if needed.
.Sp
If passed a single argument of undef, the list of objects is set to undef, causing it to be reloaded the next time the method is called with no arguments.  (Pass a reference to an empty array to cause all of the existing objects to be deleted from the database.)  Any pending \f(CW\*(C`set_on_save\*(C'\fR or \f(CW\*(C`add_on_save\*(C'\fR actions are discarded.
.Sp
Otherwise, the argument(s) must be a list or reference to an array containing items in one or more of the following formats:
.RS 4
.IP "\(bu" 4
An object of type \f(CW\*(C`class\*(C'\fR.
.IP "\(bu" 4
A reference to a hash containing method name/value pairs.
.IP "\(bu" 4
A single scalar primary key value.
.RE
.RS 4
.Sp
The latter two formats will be used to construct an object of type \f(CW\*(C`class\*(C'\fR.  A single primary key value is only a valid argument format if the \f(CW\*(C`class\*(C'\fR in question has a single-column primary key.  A hash reference argument must contain sufficient information for the object to be uniquely identified.
.Sp
The list of object is assigned to \f(CW\*(C`hash_key\*(C'\fR, the old objects are deleted from the database, and the new ones are added to the database.  Any pending \f(CW\*(C`set_on_save\*(C'\fR or \f(CW\*(C`add_on_save\*(C'\fR actions are discarded.
.Sp
When adding each object, if the object does not already exists in the database, it will be inserted.  If the object was previously loaded from or saved to the database, it will be updated.  Otherwise, it will be loaded.
.Sp
The parent object must have been loaded or saved prior to setting the list of objects.  If this method is called with arguments before the object has been  loaded or saved, a fatal error will occur.
.Sp
If called with no arguments and the hash key used to store the list of objects is defined, the list (in list context) or a reference to that array (in scalar context) of objects is returned.  Otherwise, the objects are fetched.
.Sp
The fetch may fail for several reasons.  The fetch will not even be attempted if any of the key attributes in the current object are undefined.  Instead, undef (in scalar context) or an empty list (in list context) will be returned.  If the call to \f(CW\*(C`manager_class\*(C'\fR's \f(CW\*(C`manager_method\*(C'\fR method returns false, the behavior is determined by the metadata object's error_mode.  If the mode is \f(CW\*(C`return\*(C'\fR, that false value (in scalar context) or an empty list (in list context) is returned.
.Sp
If the fetch succeeds, a list (in list context) or a reference to the array of objects (in scalar context) is returned.  (If the fetch finds zero objects, the list or array reference will simply be empty.  This is still considered success.)
.RE
.IP "\fBget_set_on_save\fR" 4
.IX Item "get_set_on_save"
Creates a method that will attempt to fetch Rose::DB::Object\-derived objects based on a key formed from attributes of the current object, and will also save the objects to the database when the \*(L"parent\*(R" object is saved.  The objects do not have to already exist in the database; they will be inserted if needed.
.Sp
If passed a single argument of undef, the list of objects is set to undef, causing it to be reloaded the next time the method is called with no arguments.  (Pass a reference to an empty array to cause all of the existing objects to be deleted from the database when the parent is saved.)
.Sp
Otherwise, the argument(s) must be a list or reference to an array containing items in one or more of the following formats:
.RS 4
.IP "\(bu" 4
An object of type \f(CW\*(C`class\*(C'\fR.
.IP "\(bu" 4
A reference to a hash containing method name/value pairs.
.IP "\(bu" 4
A single scalar primary key value.
.RE
.RS 4
.Sp
The latter two formats will be used to construct an object of type \f(CW\*(C`class\*(C'\fR.  A single primary key value is only a valid argument format if the \f(CW\*(C`class\*(C'\fR in question has a single-column primary key.  A hash reference argument must contain sufficient information for the object to be uniquely identified.
.Sp
The list of object is assigned to \f(CW\*(C`hash_key\*(C'\fR.  The old objects are scheduled to be deleted from the database and the new ones are scheduled to be added to the database when the parent is saved.  Any pending \f(CW\*(C`set_on_save\*(C'\fR or \f(CW\*(C`add_on_save\*(C'\fR actions are discarded.
.Sp
When adding each object when the parent is saved, if the object does not already exists in the database, it will be inserted.  If the object was previously loaded from or saved to the database, it will be updated.  Otherwise, it will be loaded.
.Sp
If called with no arguments and the hash key used to store the list of objects is defined, the list (in list context) or a reference to that array (in scalar context) of objects is returned.  Otherwise, the objects are fetched.
.Sp
The fetch may fail for several reasons.  The fetch will not even be attempted if any of the key attributes in the current object are undefined.  Instead, undef (in scalar context) or an empty list (in list context) will be returned.  If the call to \f(CW\*(C`manager_class\*(C'\fR's \f(CW\*(C`manager_method\*(C'\fR method returns false, the behavior is determined by the metadata object's error_mode.  If the mode is \f(CW\*(C`return\*(C'\fR, that false value (in scalar context) or an empty list (in list context) is returned.
.Sp
If the fetch succeeds, a list (in list context) or a reference to the array of objects (in scalar context) is returned.  (If the fetch finds zero objects, the list or array reference will simply be empty.  This is still considered success.)
.RE
.IP "\fBadd_now\fR" 4
.IX Item "add_now"
Creates a method that will add to a list of Rose::DB::Object\-derived objects that are related to the current object by a key formed from attributes of the current object.  The objects do not have to already exist in the database; they will be inserted if needed.
.Sp
This method returns the list of objects added when called in list context, and the number of objects added when called in scalar context.  If one or more objects could not be added, undef (in scalar context) or an empty list (in list context) is returned and the parent object's error attribute is set.
.Sp
If passed an empty list, the method does nothing and the parent object's error attribute is set.
.Sp
If passed any arguments, the parent object must have been loaded or saved prior to adding to the list of objects.  If this method is called with a non-empty list as an argument before the parent object has been  loaded or saved, a fatal error will occur.
.Sp
The argument(s) must be a list or reference to an array containing items in one or more of the following formats:
.RS 4
.IP "\(bu" 4
An object of type \f(CW\*(C`class\*(C'\fR.
.IP "\(bu" 4
A reference to a hash containing method name/value pairs.
.IP "\(bu" 4
A single scalar primary key value.
.RE
.RS 4
.Sp
The latter two formats will be used to construct an object of type \f(CW\*(C`class\*(C'\fR.  A single primary key value is only a valid argument format if the \f(CW\*(C`class\*(C'\fR in question has a single-column primary key.  A hash reference argument must contain sufficient information for the object to be uniquely identified.
.Sp
These objects are linked to the parent object (by setting the appropriate key attributes) and then added to the database.
.Sp
When adding each object, if the object does not already exists in the database, it will be inserted.  If the object was previously loaded from or saved to the database, it will be updated.  Otherwise, it will be loaded.
.Sp
The parent object's list of related objects is then set to undef, causing the related objects to be reloaded from the database the next time they're needed.
.RE
.IP "\fBadd_on_save\fR" 4
.IX Item "add_on_save"
Creates a method that will add to a list of Rose::DB::Object\-derived objects that are related to the current object by a key formed from attributes of the current object.  The objects will be added to the database when the parent object is saved.  The objects do not have to already exist in the database; they will be inserted if needed.
.Sp
This method returns the list of objects to be added when called in list context, and the number of items to be added when called in scalar context.
.Sp
If passed an empty list, the method does nothing and the parent object's error attribute is set.
.Sp
Otherwise, the argument(s) must be a list or reference to an array containing items in one or more of the following formats:
.RS 4
.IP "\(bu" 4
An object of type \f(CW\*(C`class\*(C'\fR.
.IP "\(bu" 4
A reference to a hash containing method name/value pairs.
.IP "\(bu" 4
A single scalar primary key value.
.RE
.RS 4
.Sp
The latter two formats will be used to construct an object of type \f(CW\*(C`class\*(C'\fR.  A single primary key value is only a valid argument format if the \f(CW\*(C`class\*(C'\fR in question has a single-column primary key.  A hash reference argument must contain sufficient information for the object to be uniquely identified.
.Sp
These objects are linked to the parent object (by setting the appropriate key attributes, whether or not they're defined in the parent object) and are scheduled to be added to the database when the parent object is saved.  They are also added to the parent object's current list of related objects, if the list is defined at the time of the call.
.Sp
When adding each object when the parent is saved, if the object does not already exists in the database, it will be inserted.  If the object was previously loaded from or saved to the database, it will be updated.  Otherwise, it will be loaded.
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example setup:
.Sp
.Vb 4
\&    # CLASS     DB TABLE
\&    # \-\-\-\-\-\-\-   \-\-\-\-\-\-\-\-
\&    # Program   programs
\&    # Bug       bugs
\&
\&    package Program;
\&
\&    our @ISA = qw(Rose::DB::Object);
\&    ...
\&    # You will almost never call the method\-maker directly
\&    # like this.  See the Rose::DB::Object::Metadata docs
\&    # for examples of more common usage.
\&    use Rose::DB::Object::MakeMethods::Generic
\&    (
\&      objects_by_key =>
\&      [
\&        find_bugs => 
\&        {
\&          interface => \*(Aqfind\*(Aq,
\&          class     => \*(AqBug\*(Aq,
\&          key_columns =>
\&          {
\&            # Map Program column names to Bug column names
\&            id      => \*(Aqprogram_id\*(Aq,
\&            version => \*(Aqversion\*(Aq,
\&          },
\&          manager_args => { sort_by => \*(Aqdate_submitted DESC\*(Aq },
\&        },
\&
\&        bugs => 
\&        {
\&          interface => \*(Aq...\*(Aq, # get_set, get_set_now, get_set_on_save
\&          class     => \*(AqBug\*(Aq,
\&          key_columns =>
\&          {
\&            # Map Program column names to Bug column names
\&            id      => \*(Aqprogram_id\*(Aq,
\&            version => \*(Aqversion\*(Aq,
\&          },
\&          manager_args => { sort_by => \*(Aqdate_submitted DESC\*(Aq },
\&          query_args   => { state => { ne => \*(Aqclosed\*(Aq } },
\&        },
\&
\&        add_bugs => 
\&        {
\&          interface => \*(Aq...\*(Aq, # add_now or add_on_save
\&          class     => \*(AqBug\*(Aq,
\&          key_columns =>
\&          {
\&            # Map Program column names to Bug column names
\&            id      => \*(Aqprogram_id\*(Aq,
\&            version => \*(Aqversion\*(Aq,
\&          },
\&          manager_args => { sort_by => \*(Aqdate_submitted DESC\*(Aq },
\&          query_args   => { state => { ne => \*(Aqclosed\*(Aq } },
\&        },
\&      ]
\&    );
\&    ...
.Ve
.Sp
Example \- find interface:
.Sp
.Vb 2
\&    # Read from the programs table
\&    $prog = Program\->new(id => 5)\->load;
\&
\&    # Read from the bugs table
\&    $bugs = $prog\->find_bugs;
\&
\&    # Calls (essentially):
\&    #
\&    # Rose::DB::Object::Manager\->get_objects(
\&    #   db           => $prog\->db, # share_db defaults to true
\&    #   object_class => \*(AqBug\*(Aq,
\&    #   query =>
\&    #   [
\&    #     program_id => 5,     # value of $prog\->id
\&    #     version    => \*(Aq3.0\*(Aq, # value of $prog\->version
\&    #   ],
\&    #   sort_by => \*(Aqdate_submitted DESC\*(Aq);
\&
\&    # Augment query
\&    $bugs = $prog\->find_bugs({ state => \*(Aqopen\*(Aq });
\&
\&    # Calls (essentially):
\&    #
\&    # Rose::DB::Object::Manager\->get_objects(
\&    #   db           => $prog\->db, # share_db defaults to true
\&    #   object_class => \*(AqBug\*(Aq,
\&    #   query =>
\&    #   [
\&    #     program_id => 5,     # value of $prog\->id
\&    #     version    => \*(Aq3.0\*(Aq, # value of $prog\->version
\&    #     state      => \*(Aqopen\*(Aq,
\&    #   ],
\&    #   sort_by => \*(Aqdate_submitted DESC\*(Aq);
\&    ...
\&
\&    # Augment query and replace sort_by value
\&    $bugs = $prog\->find_bugs(query   => [ state => \*(Aqdefunct\*(Aq ], 
\&                             sort_by => \*(Aqname\*(Aq);
\&
\&    # Calls (essentially):
\&    #
\&    # Rose::DB::Object::Manager\->get_objects(
\&    #   db           => $prog\->db, # share_db defaults to true
\&    #   object_class => \*(AqBug\*(Aq,
\&    #   query =>
\&    #   [
\&    #     program_id => 5,     # value of $prog\->id
\&    #     version    => \*(Aq3.0\*(Aq, # value of $prog\->version
\&    #     state      => \*(Aqdefunct\*(Aq,
\&    #   ],
\&    #   sort_by => \*(Aqname\*(Aq);
\&    ...
.Ve
.Sp
Example \- get_set interface:
.Sp
.Vb 2
\&    # Read from the programs table
\&    $prog = Program\->new(id => 5)\->load;
\&
\&    # Read from the bugs table
\&    $bugs = $prog\->bugs;
\&
\&    # Calls (essentially):
\&    #
\&    # Rose::DB::Object::Manager\->get_objects(
\&    #   db           => $prog\->db, # share_db defaults to true
\&    #   object_class => \*(AqBug\*(Aq,
\&    #   query =>
\&    #   [
\&    #     program_id => 5,     # value of $prog\->id
\&    #     version    => \*(Aq3.0\*(Aq, # value of $prog\->version
\&    #     state      => { ne => \*(Aqclosed\*(Aq },
\&    #   ],
\&    #   sort_by => \*(Aqdate_submitted DESC\*(Aq);
\&    ...
\&    $prog\->version($new_version); # Does not hit the db
\&    $prog\->bugs(@new_bugs);       # Does not hit the db
\&
\&    # @new_bugs can contain any mix of these types:
\&    #
\&    # @new_bugs =
\&    # (
\&    #   123,                 # primary key value
\&    #   { id => 456 },       # method name/value pairs
\&    #   Bug\->new(id => 789), # object
\&    # );
\&
\&    # Write to the programs table only.  The bugs table is not
\&    # updated. See the get_set_now and get_set_on_save method
\&    # types for ways to write to the bugs table.
\&    $prog\->save;
.Ve
.Sp
Example \- get_set_now interface:
.Sp
.Vb 2
\&    # Read from the programs table
\&    $prog = Program\->new(id => 5)\->load;
\&
\&    # Read from the bugs table
\&    $bugs = $prog\->bugs;
\&
\&    $prog\->name($new_name); # Does not hit the db
\&
\&    # Writes to the bugs table, deleting existing bugs and
\&    # replacing them with @new_bugs (which must be an array
\&    # of Bug objects, either existing or new)
\&    $prog\->bugs(@new_bugs); 
\&
\&    # @new_bugs can contain any mix of these types:
\&    #
\&    # @new_bugs =
\&    # (
\&    #   123,                 # primary key value
\&    #   { id => 456 },       # method name/value pairs
\&    #   Bug\->new(id => 789), # object
\&    # );
\&
\&    # Write to the programs table
\&    $prog\->save;
.Ve
.Sp
Example \- get_set_on_save interface:
.Sp
.Vb 2
\&    # Read from the programs table
\&    $prog = Program\->new(id => 5)\->load;
\&
\&    # Read from the bugs table
\&    $bugs = $prog\->bugs;
\&
\&    $prog\->name($new_name); # Does not hit the db
\&    $prog\->bugs(@new_bugs); # Does not hit the db
\&
\&    # @new_bugs can contain any mix of these types:
\&    #
\&    # @new_bugs =
\&    # (
\&    #   123,                 # primary key value
\&    #   { id => 456 },       # method name/value pairs
\&    #   Bug\->new(id => 789), # object
\&    # );
\&
\&    # Write to the programs table and the bugs table, deleting any
\&    # existing bugs and replacing them with @new_bugs (which must be
\&    # an array of Bug objects, either existing or new)
\&    $prog\->save;
.Ve
.Sp
Example \- add_now interface:
.Sp
.Vb 2
\&    # Read from the programs table
\&    $prog = Program\->new(id => 5)\->load;
\&
\&    # Read from the bugs table
\&    $bugs = $prog\->bugs;
\&
\&    $prog\->name($new_name); # Does not hit the db
\&
\&    # Writes to the bugs table, adding @new_bugs to the current
\&    # list of bugs for this program
\&    $prog\->add_bugs(@new_bugs);
\&
\&    # @new_bugs can contain any mix of these types:
\&    #
\&    # @new_bugs =
\&    # (
\&    #   123,                 # primary key value
\&    #   { id => 456 },       # method name/value pairs
\&    #   Bug\->new(id => 789), # object
\&    # );
\&
\&    # Read from the bugs table, getting the full list of bugs, 
\&    # including the ones that were added above.
\&    $bugs = $prog\->bugs;
\&
\&    # Write to the programs table only
\&    $prog\->save;
.Ve
.Sp
Example \- add_on_save interface:
.Sp
.Vb 2
\&    # Read from the programs table
\&    $prog = Program\->new(id => 5)\->load;
\&
\&    # Read from the bugs table
\&    $bugs = $prog\->bugs;
\&
\&    $prog\->name($new_name);      # Does not hit the db
\&    $prog\->add_bugs(@new_bugs);  # Does not hit the db
\&    $prog\->add_bugs(@more_bugs); # Does not hit the db
\&
\&    # @new_bugs and @more_bugs can contain any mix of these types:
\&    #
\&    # @new_bugs =
\&    # (
\&    #   123,                 # primary key value
\&    #   { id => 456 },       # method name/value pairs
\&    #   Bug\->new(id => 789), # object
\&    # );
\&
\&    # Write to the programs table and the bugs table, adding
\&    # @new_bugs to the current list of bugs for this program
\&    $prog\->save;
.Ve
.RE
.IP "\fBobjects_by_map\fR" 4
.IX Item "objects_by_map"
Create methods that fetch Rose::DB::Object\-derived objects via an intermediate Rose::DB::Object\-derived class that maps between two other Rose::DB::Object\-derived classes.  See the Rose::DB::Object::Metadata::Relationship::ManyToMany documentation for a more complete example of this type of method in action.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.IP "\fBhash_key \s-1NAME\s0\fR" 4
.IX Item "hash_key NAME"
.PD
The key inside the hash-based object to use for the storage of the fetched objects.  Defaults to the name of the method.
.IP "\fBinterface \s-1NAME\s0\fR" 4
.IX Item "interface NAME"
Choose the interface.  The \f(CW\*(C`get_set\*(C'\fR interface is the default.
.IP "\fBmanager_args \s-1HASHREF\s0\fR" 4
.IX Item "manager_args HASHREF"
A reference to a hash of arguments passed to the \f(CW\*(C`manager_class\*(C'\fR when fetching objects.  If \f(CW\*(C`manager_args\*(C'\fR includes a \*(L"sort_by\*(R" argument, be sure to prefix each column name with the appropriate table name.  (See the synopsis for examples.)
.IP "\fBmanager_class \s-1CLASS\s0\fR" 4
.IX Item "manager_class CLASS"
The name of the Rose::DB::Object::Manager\-derived class that the \f(CW\*(C`map_class\*(C'\fR will use to fetch records.  Defaults to Rose::DB::Object::Manager.
.IP "\fBmanager_method \s-1NAME\s0\fR" 4
.IX Item "manager_method NAME"
The name of the class method to call on \f(CW\*(C`manager_class\*(C'\fR in order to fetch the objects.  Defaults to \f(CW\*(C`get_objects\*(C'\fR.
.IP "\fBmanager_count_method \s-1NAME\s0\fR" 4
.IX Item "manager_count_method NAME"
The name of the class method to call on \f(CW\*(C`manager_class\*(C'\fR in order to count the objects.  Defaults to \f(CW\*(C`get_objects_count\*(C'\fR.
.IP "\fBmap_class \s-1CLASS\s0\fR" 4
.IX Item "map_class CLASS"
The name of the Rose::DB::Object\-derived class that maps between the other two Rose::DB::Object\-derived classes.  This class must have a foreign key and/or \*(L"many to one\*(R" relationship for each of the two tables that it maps between.
.IP "\fBmap_from \s-1NAME\s0\fR" 4
.IX Item "map_from NAME"
The name of the \*(L"many to one\*(R" relationship or foreign key in \f(CW\*(C`map_class\*(C'\fR that points to the object of the class that this relationship exists in.  Setting this value is only necessary if the \f(CW\*(C`map_class\*(C'\fR has more than one foreign key or \*(L"many to one\*(R" relationship that points to one of the classes that it maps between.
.IP "\fBmap_to \s-1NAME\s0\fR" 4
.IX Item "map_to NAME"
The name of the \*(L"many to one\*(R" relationship or foreign key in \f(CW\*(C`map_class\*(C'\fR that points to the \*(L"foreign\*(R" object to be fetched.  Setting this value is only necessary if the \f(CW\*(C`map_class\*(C'\fR has more than one foreign key or \*(L"many to one\*(R" relationship that points to one of the classes that it maps between.
.IP "\fBrelationship \s-1OBJECT\s0\fR" 4
.IX Item "relationship OBJECT"
The Rose::DB::Object::Metadata::Relationship object that describes the \*(L"key\*(R" through which the \*(L"objects_by_key\*(R" are fetched.  This option is required.
.IP "\fBshare_db \s-1BOOL\s0\fR" 4
.IX Item "share_db BOOL"
If true, the db attribute of the current object is shared with all of the objects fetched.  Defaults to true.
.IP "\fBquery_args \s-1ARRAYREF\s0\fR" 4
.IX Item "query_args ARRAYREF"
A reference to an array of arguments added to the value of the \f(CW\*(C`query\*(C'\fR parameter passed to the call to \f(CW\*(C`manager_class\*(C'\fR's \f(CW\*(C`manager_method\*(C'\fR class method.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.IP "\fBcount\fR" 4
.IX Item "count"
.PD
Creates a method that will attempt to count Rose::DB::Object\-derived objects that are related to the current object through the \f(CW\*(C`map_class\*(C'\fR, plus any additional parameters passed to the method call.  Note that this method counts the objects \fIin the database at the time of the call\fR.  This may be different than the number of objects attached to the current object or otherwise in memory.
.Sp
Since the objects counted are partially determined by the arguments passed to the method, the count is not retained.  It is simply returned.  Each call counts the specified objects again, even if the arguments are the same as the previous call.
.Sp
If the first argument is a reference to a hash or array, it is converted to a reference to an array (if necessary) and taken as the value of the \f(CW\*(C`query\*(C'\fR parameter.  All arguments are passed on to the \f(CW\*(C`manager_class\*(C'\fR's \f(CW\*(C`manager_count_method\*(C'\fR method, augmented by the mapping to the current object.  Query parameters are added to the existing contents of the \f(CW\*(C`query\*(C'\fR parameter.  Other parameters replace existing parameters if the existing values are simple scalars, or augment existing parameters if the existing values are references to hashes or arrays.
.Sp
The count may fail for several reasons.  The count will not even be attempted if any of the key attributes in the current object are undefined.  Instead, undef (in scalar context) or an empty list (in list context) will be returned.  If the call to \f(CW\*(C`manager_class\*(C'\fR's \f(CW\*(C`manager_count_method\*(C'\fR method returns undef, the behavior is determined by the metadata object's error_mode.  If the mode is \f(CW\*(C`return\*(C'\fR, that false value (in scalar context) or an empty list (in list context) is returned.
.Sp
If the count succeeds, the number is returned.  (If the count finds zero objects, the count will be 0.  This is still considered success.)
.IP "\fBfind\fR" 4
.IX Item "find"
Creates a method that will attempt to fetch Rose::DB::Object\-derived that are related to the current object through the \f(CW\*(C`map_class\*(C'\fR, plus any additional parameters passed to the method call.  Since the objects fetched are partially determined by the arguments passed to the method, the list of objects is not retained.  It is simply returned.  Each call fetches the requested objects again, even if the arguments are the same as the previous call.
.Sp
If the first argument is a reference to a hash or array, it is converted to a reference to an array (if necessary) and taken as the value of the \f(CW\*(C`query\*(C'\fR parameter.  All arguments are passed on to the \f(CW\*(C`manager_class\*(C'\fR's \f(CW\*(C`manager_method\*(C'\fR method, augmented by the mapping to the current object.  Query parameters are added to the existing contents of the \f(CW\*(C`query\*(C'\fR parameter.  Other parameters replace existing parameters if the existing values are simple scalars, or augment existing parameters if the existing values are references to hashes or arrays.
.Sp
The fetch may fail for several reasons.  The fetch will not even be attempted if any of the key attributes in the current object are undefined.  Instead, undef (in scalar context) or an empty list (in list context) will be returned.  If the call to \f(CW\*(C`manager_class\*(C'\fR's \f(CW\*(C`manager_method\*(C'\fR method returns false, the behavior is determined by the metadata object's error_mode.  If the mode is \f(CW\*(C`return\*(C'\fR, that false value (in scalar context) or an empty list (in list context) is returned.
.Sp
If the fetch succeeds, a list (in list context) or a reference to the array of objects (in scalar context) is returned.  (If the fetch finds zero objects, the list or array reference will simply be empty.  This is still considered success.)
.IP "\fBiterator\fR" 4
.IX Item "iterator"
Behaves just like \fBfind\fR but returns an iterator rather than an array or arrayref.
.IP "\fBget_set\fR" 4
.IX Item "get_set"
Creates a method that will attempt to fetch Rose::DB::Object\-derived objects that are related to the current object through the \f(CW\*(C`map_class\*(C'\fR.
.Sp
If passed a single argument of undef, the \f(CW\*(C`hash_key\*(C'\fR used to store the objects is set to undef.  Otherwise, the argument(s) must be a list or reference to an array containing items in one or more of the following formats:
.RS 4
.IP "\(bu" 4
An object of type \f(CW\*(C`class\*(C'\fR.
.IP "\(bu" 4
A reference to a hash containing method name/value pairs.
.IP "\(bu" 4
A single scalar primary key value.
.RE
.RS 4
.Sp
The latter two formats will be used to construct an object of type \f(CW\*(C`class\*(C'\fR.  A single primary key value is only a valid argument format if the \f(CW\*(C`class\*(C'\fR in question has a single-column primary key.  A hash reference argument must contain sufficient information for the object to be uniquely identified.
.Sp
The list of object is assigned to \f(CW\*(C`hash_key\*(C'\fR.  Note that these objects are \fBnot\fR added to the database.  Use the \f(CW\*(C`get_set_now\*(C'\fR or \f(CW\*(C`get_set_on_save\*(C'\fR interface to do that.
.Sp
If called with no arguments and the hash key used to store the list of objects is defined, the list (in list context) or a reference to that array (in scalar context) of objects is returned.  Otherwise, the objects are fetched.
.Sp
When fetching objects from the database, if the call to \f(CW\*(C`manager_class\*(C'\fR's \f(CW\*(C`manager_method\*(C'\fR method returns false, that false value (in scalar context) or an empty list (in list context) is returned.
.Sp
If the fetch succeeds, a list (in list context) or a reference to the array of objects (in scalar context) is returned.  (If the fetch finds zero objects, the list or array reference will simply be empty.  This is still considered success.)
.RE
.IP "\fBget_set_now\fR" 4
.IX Item "get_set_now"
Creates a method that will attempt to fetch Rose::DB::Object\-derived objects that are related to the current object through the \f(CW\*(C`map_class\*(C'\fR, and will also save objects to the database and map them to the parent object when called with arguments.  The objects do not have to already exist in the database; they will be inserted if needed.
.Sp
If passed a single argument of undef, the list of objects is set to undef, causing it to be reloaded the next time the method is called with no arguments.  (Pass a reference to an empty array to cause all of the existing objects to be \*(L"unmapped\*(R"\-\-that is, to have their entries in the mapping table deleted from the database.)  Any pending \f(CW\*(C`set_on_save\*(C'\fR or \f(CW\*(C`add_on_save\*(C'\fR actions are discarded.
.Sp
Otherwise, the argument(s) must be a list or reference to an array containing items in one or more of the following formats:
.RS 4
.IP "\(bu" 4
An object of type \f(CW\*(C`class\*(C'\fR.
.IP "\(bu" 4
A reference to a hash containing method name/value pairs.
.IP "\(bu" 4
A single scalar primary key value.
.RE
.RS 4
.Sp
The latter two formats will be used to construct an object of type \f(CW\*(C`class\*(C'\fR.  A single primary key value is only a valid argument format if the \f(CW\*(C`class\*(C'\fR in question has a single-column primary key.  A hash reference argument must contain sufficient information for the object to be uniquely identified.
.Sp
The list of object is assigned to \f(CW\*(C`hash_key\*(C'\fR, the old entries are deleted from the mapping table in the database, and the new objects are added to the database, along with their corresponding mapping entries.  Any pending \f(CW\*(C`set_on_save\*(C'\fR or \f(CW\*(C`add_on_save\*(C'\fR actions are discarded.
.Sp
When adding each object, if the object does not already exists in the database, it will be inserted.  If the object was previously loaded from or saved to the database, it will be updated.  Otherwise, it will be loaded.
.Sp
The parent object must have been loaded or saved prior to setting the list of objects.  If this method is called with arguments before the object has been  loaded or saved, a fatal error will occur.
.Sp
If called with no arguments and the hash key used to store the list of objects is defined, the list (in list context) or a reference to that array (in scalar context) of objects is returned.  Otherwise, the objects are fetched.
.Sp
When fetching, if the call to \f(CW\*(C`manager_class\*(C'\fR's \f(CW\*(C`manager_method\*(C'\fR method returns false, that false value (in scalar context) or an empty list (in list context) is returned.
.Sp
If the fetch succeeds, a list (in list context) or a reference to the array of objects (in scalar context) is returned.  (If the fetch finds zero objects, the list or array reference will simply be empty.  This is still considered success.)
.RE
.IP "\fBget_set_on_save\fR" 4
.IX Item "get_set_on_save"
Creates a method that will attempt to fetch Rose::DB::Object\-derived objects that are related to the current object through the \f(CW\*(C`map_class\*(C'\fR, and will also save objects to the database and map them to the parent object when the \*(L"parent\*(R" object is saved.  The objects do not have to already exist in the database; they will be inserted if needed.
.Sp
If passed a single argument of undef, the list of objects is set to undef, causing it to be reloaded the next time the method is called with no arguments.  (Pass a reference to an empty array to cause all of the existing objects to be \*(L"unmapped\*(R"\-\-that is, to have their entries in the mapping table deleted from the database.)  Any pending \f(CW\*(C`set_on_save\*(C'\fR or \f(CW\*(C`add_on_save\*(C'\fR actions are discarded.
.Sp
Otherwise, the argument(s) must be a list or reference to an array containing items in one or more of the following formats:
.RS 4
.IP "\(bu" 4
An object of type \f(CW\*(C`class\*(C'\fR.
.IP "\(bu" 4
A reference to a hash containing method name/value pairs.
.IP "\(bu" 4
A single scalar primary key value.
.RE
.RS 4
.Sp
The latter two formats will be used to construct an object of type \f(CW\*(C`class\*(C'\fR.  A single primary key value is only a valid argument format if the \f(CW\*(C`class\*(C'\fR in question has a single-column primary key.  A hash reference argument must contain sufficient information for the object to be uniquely identified.
.Sp
The list of object is assigned to \f(CW\*(C`hash_key\*(C'\fR. The mapping table records that mapped the old objects to the parent object are scheduled to be deleted from the database and new ones are scheduled to be added to the database when the parent is saved.  Any previously pending \f(CW\*(C`set_on_save\*(C'\fR or \f(CW\*(C`add_on_save\*(C'\fR actions are discarded.
.Sp
When adding each object when the parent is saved, if the object does not already exists in the database, it will be inserted.  If the object was previously loaded from or  saved to the database, it will be updated.  Otherwise, it will be loaded.
.Sp
If called with no arguments and the hash key used to store the list of objects is defined, the list (in list context) or a reference to that array (in scalar context) of objects is returned.  Otherwise, the objects are fetched.
.Sp
When fetching, if the call to \f(CW\*(C`manager_class\*(C'\fR's \f(CW\*(C`manager_method\*(C'\fR method returns false, that false value (in scalar context) or an empty list (in list context) is returned.
.Sp
If the fetch succeeds, a list (in list context) or a reference to the array of objects (in scalar context) is returned.  (If the fetch finds zero objects, the list or array reference will simply be empty.  This is still considered success.)
.RE
.IP "\fBadd_now\fR" 4
.IX Item "add_now"
Creates a method that will add to a list of Rose::DB::Object\-derived objects that are related to the current object through the \f(CW\*(C`map_class\*(C'\fR, and will also save objects to the database and map them to the parent object.  The objects do not have to already exist in the database; they will be inserted if needed.
.Sp
This method returns the list of objects added when called in list context, and the number of objects added when called in scalar context.  If one or more objects could not be added, undef (in scalar context) or an empty list (in list context) is returned and the parent object's error attribute is set.
.Sp
If passed an empty list, the method does nothing and the parent object's error attribute is set.
.Sp
If passed any arguments, the parent object must have been loaded or saved prior to adding to the list of objects.  If this method is called with a non-empty list as an argument before the parent object has been  loaded or saved, a fatal error will occur.
.Sp
The argument(s) must be a list or reference to an array containing items in one or more of the following formats:
.RS 4
.IP "\(bu" 4
An object of type \f(CW\*(C`class\*(C'\fR.
.IP "\(bu" 4
A reference to a hash containing method name/value pairs.
.IP "\(bu" 4
A single scalar primary key value.
.RE
.RS 4
.Sp
The latter two formats will be used to construct an object of type \f(CW\*(C`class\*(C'\fR.  A single primary key value is only a valid argument format if the \f(CW\*(C`class\*(C'\fR in question has a single-column primary key.  A hash reference argument must contain sufficient information for the object to be uniquely identified.
.Sp
The parent object's list of related objects is then set to undef, causing the related objects to be reloaded from the database the next time they're needed.
.RE
.IP "\fBadd_on_save\fR" 4
.IX Item "add_on_save"
Creates a method that will add to a list of Rose::DB::Object\-derived objects that are related to the current object through the \f(CW\*(C`map_class\*(C'\fR, and will also save objects to the database and map them to the parent object when the \*(L"parent\*(R" object is saved.  The objects and map records will be added to the database when the parent object is saved.  The objects do not have to already exist in the database; they will be inserted if needed.
.Sp
This method returns the list of objects to be added when called in list context, and the number of items to be added when called in scalar context.
.Sp
If passed an empty list, the method does nothing and the parent object's error attribute is set.
.Sp
Otherwise, the argument(s) must be a list or reference to an array containing items in one or more of the following formats:
.RS 4
.IP "\(bu" 4
An object of type \f(CW\*(C`class\*(C'\fR.
.IP "\(bu" 4
A reference to a hash containing method name/value pairs.
.IP "\(bu" 4
A single scalar primary key value.
.RE
.RS 4
.Sp
The latter two formats will be used to construct an object of type \f(CW\*(C`class\*(C'\fR.  A single primary key value is only a valid argument format if the \f(CW\*(C`class\*(C'\fR in question has a single-column primary key.  A hash reference argument must contain sufficient information for the object to be uniquely identified.
.Sp
These objects are scheduled to be added to the database and mapped to the parent object when the parent object is saved.  They are also added to the parent object's current list of related objects, if the list is defined at the time of the call.
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
For a complete example of this method type in action, see the Rose::DB::Object::Metadata::Relationship::ManyToMany documentation.
.RE
.IP "\fBobject_by_key\fR" 4
.IX Item "object_by_key"
Create a get/set methods for a single Rose::DB::Object\-derived object loaded based on a primary key formed from attributes of the current object.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.IP "\fBclass \s-1CLASS\s0\fR" 4
.IX Item "class CLASS"
.PD
The name of the Rose::DB::Object\-derived class of the object to be loaded.  This option is required.
.IP "\fBforeign_key \s-1OBJECT\s0\fR" 4
.IX Item "foreign_key OBJECT"
The Rose::DB::Object::Metadata::ForeignKey object that describes the \*(L"key\*(R" through which the \*(L"object_by_key\*(R" is fetched.  This (or the \f(CW\*(C`relationship\*(C'\fR parameter) is required when using the \*(L"delete_now\*(R", \*(L"delete_on_save\*(R", and \*(L"get_set_on_save\*(R" interfaces.
.IP "\fBhash_key \s-1NAME\s0\fR" 4
.IX Item "hash_key NAME"
The key inside the hash-based object to use for the storage of the object.  Defaults to the name of the method.
.IP "\fBif_not_found \s-1CONSEQUENCE\s0\fR" 4
.IX Item "if_not_found CONSEQUENCE"
This setting determines what happens when the key_columns have defined values, but the foreign object they point to is not found.  Valid values for \s-1CONSEQUENCE\s0 are \f(CW\*(C`fatal\*(C'\fR, which will throw an exception if the foreign object is not found, and \f(CW\*(C`ok\*(C'\fR which will merely cause the relevant method(s) to return undef.  The default is \f(CW\*(C`fatal\*(C'\fR.
.IP "\fBkey_columns \s-1HASHREF\s0\fR" 4
.IX Item "key_columns HASHREF"
A reference to a hash that maps column names in the current object to those of the primary key in the object to be loaded.  This option is required.
.IP "\fBinterface \s-1NAME\s0\fR" 4
.IX Item "interface NAME"
Choose the interface.  The default is \f(CW\*(C`get_set\*(C'\fR.
.IP "\fBrelationship \s-1OBJECT\s0\fR" 4
.IX Item "relationship OBJECT"
The Rose::DB::Object::Metadata::Relationship\-derived object that describes the relationship through which the object is fetched.  This (or the \f(CW\*(C`foreign_key\*(C'\fR parameter) is required when using the \*(L"delete_now\*(R", \*(L"delete_on_save\*(R", and \*(L"get_set_on_save\*(R" interfaces.
.IP "\fBreferential_integrity \s-1BOOL\s0\fR" 4
.IX Item "referential_integrity BOOL"
If true, then a fatal error will occur when a method in one of the \*(L"get*\*(R" interfaces is called and no related object is found.  The default is determined by the referential_integrity attribute of the \f(CW\*(C`foreign_key\*(C'\fR object, or true if no \f(CW\*(C`foreign_key\*(C'\fR parameter is passed.
.Sp
This parameter conflicts with the \f(CW\*(C`required\*(C'\fR parameter.  Only one of the two should be passed.
.IP "\fBrequired \s-1BOOL\s0\fR" 4
.IX Item "required BOOL"
If true, then a fatal error will occur when a method in one of the \*(L"get*\*(R" interfaces is called and no related object is found.  The default is determined by the required attribute of the \f(CW\*(C`relationship\*(C'\fR object, or true if no \f(CW\*(C`relationship\*(C'\fR parameter is passed.
.Sp
This parameter conflicts with the \f(CW\*(C`referential_integrity\*(C'\fR parameter.  Only one of the two should be passed.
.IP "\fBshare_db \s-1BOOL\s0\fR" 4
.IX Item "share_db BOOL"
If true, the db attribute of the current object is shared with the object loaded.  Defaults to true.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.IP "\fBdelete_now\fR" 4
.IX Item "delete_now"
.PD
Deletes a Rose::DB::Object\-derived object from the database based on a primary key formed from attributes of the current object.  If \f(CW\*(C`referential_integrity\*(C'\fR or \f(CW\*(C`required\*(C'\fR is true, then the \*(L"parent\*(R" object will have all of its attributes that refer to the \*(L"foreign\*(R" object (except any columns that are also part of the primary key) set to null , and it will be saved into the database.  This needs to be done first because a database that enforces referential integrity will not allow a row to be deleted if it is still referenced by a foreign key in another table.
.Sp
Any previously pending \f(CW\*(C`get_set_on_save\*(C'\fR action is discarded.
.Sp
The entire process takes place within a transaction if the database supports it.  If not currently in a transaction, a new one is started and then committed on success and rolled back on failure.
.Sp
Returns true if the foreign object was deleted successfully or did not exist in the database, false if any of the keys that refer to the foreign object were undef, and triggers the normal Rose::DB::Object error handling in the case of any other kind of failure.
.IP "\fBdelete_on_save\fR" 4
.IX Item "delete_on_save"
Deletes a Rose::DB::Object\-derived object from the database when the \*(L"parent\*(R" object is saved, based on a primary key formed from attributes of the current object.  If \f(CW\*(C`referential_integrity\*(C'\fR or \f(CW\*(C`required\*(C'\fR is true, then the \*(L"parent\*(R" object will have all of its attributes that refer to the \*(L"foreign\*(R" object (except any columns that are also part of the primary key) set to null immediately, but the actual delete will not be done until the parent is saved.
.Sp
Any previously pending \f(CW\*(C`get_set_on_save\*(C'\fR action is discarded.
.Sp
The entire process takes place within a transaction if the database supports it.  If not currently in a transaction, a new one is started and then committed on success and rolled back on failure.
.Sp
Returns true if the foreign object was deleted successfully or did not exist in the database, false if any of the keys that refer to the foreign object were undef, and triggers the normal Rose::DB::Object error handling in the case of any other kind of failure.
.IP "\fBget_set\fR" 4
.IX Item "get_set"
Creates a method that will attempt to create and load a Rose::DB::Object\-derived object based on a primary key formed from attributes of the current object.
.Sp
If passed a single argument of undef, the \f(CW\*(C`hash_key\*(C'\fR used to store the object is set to undef.  If \f(CW\*(C`referential_integrity\*(C'\fR or \f(CW\*(C`required\*(C'\fR is true, then the columns that participate in the key are set to undef.  (If any key column is part of the primary key, however, it is not set to undef.)  Otherwise, the argument must be one of the following:
.RS 4
.IP "\(bu" 4
An object of type \f(CW\*(C`class\*(C'\fR
.IP "\(bu" 4
A list of method name/value pairs.
.IP "\(bu" 4
A reference to a hash containing method name/value pairs.
.IP "\(bu" 4
A single scalar primary key value.
.RE
.RS 4
.Sp
The latter three argument types will be used to construct an object of type \f(CW\*(C`class\*(C'\fR.  A single primary key value is only valid if the \f(CW\*(C`class\*(C'\fR in question has a single-column primary key.  A hash reference argument must contain sufficient information for the object to be uniquely identified.
.Sp
The object is assigned to \f(CW\*(C`hash_key\*(C'\fR after having its \f(CW\*(C`key_columns\*(C'\fR set to their corresponding values in the current object.
.Sp
If called with no arguments and the \f(CW\*(C`hash_key\*(C'\fR used to store the object is defined, the object is returned.  Otherwise, the object is created and loaded.
.Sp
The load may fail for several reasons.  The load will not even be attempted if any of the key attributes in the current object are undefined.  Instead, undef will be returned.
.Sp
If the call to the newly created object's load method returns false, then the normal Rose::DB::Object error handling is triggered.  The false value returned by the call to the load method is returned (assuming no exception was raised).
.Sp
If the load succeeds, the object is returned.
.RE
.IP "\fBget_set_now\fR" 4
.IX Item "get_set_now"
Creates a method that will attempt to create and load a Rose::DB::Object\-derived object based on a primary key formed from attributes of the current object, and will also save the object to the database when called with an appropriate object as an argument.
.Sp
If passed a single argument of undef, the \f(CW\*(C`hash_key\*(C'\fR used to store the object is set to undef.  If \f(CW\*(C`referential_integrity\*(C'\fR or \f(CW\*(C`required\*(C'\fR is true, then the columns that participate in the key are set to undef.  (If any key column is part of the primary key, however, it is not set to undef.) Otherwise, the argument must be one of the following:
.RS 4
.IP "\(bu" 4
An object of type \f(CW\*(C`class\*(C'\fR
.IP "\(bu" 4
A list of method name/value pairs.
.IP "\(bu" 4
A reference to a hash containing method name/value pairs.
.IP "\(bu" 4
A single scalar primary key value.
.RE
.RS 4
.Sp
The latter three argument types will be used to construct an object of type \f(CW\*(C`class\*(C'\fR.  A single primary key value is only a valid argument format if the \f(CW\*(C`class\*(C'\fR in question has a single-column primary key.  A hash reference argument must contain sufficient information for the object to be uniquely identified.
.Sp
The object is assigned to \f(CW\*(C`hash_key\*(C'\fR after having its \f(CW\*(C`key_columns\*(C'\fR set to their corresponding values in the current object.  The object is then immediately saved to the database.
.Sp
If the object does not already exists in the database, it will be inserted.  If the object was previously loaded from or saved to the database, it will be updated.  Otherwise, it will be loaded.
.Sp
The parent object must have been loaded or saved prior to setting the list of objects.  If this method is called with arguments before the object has been  loaded or saved, a fatal error will occur.
.Sp
If called with no arguments and the \f(CW\*(C`hash_key\*(C'\fR used to store the object is defined, the object is returned.  Otherwise, the object is created and loaded.
.Sp
The load may fail for several reasons.  The load will not even be attempted if any of the key attributes in the current object are undefined.  Instead, undef will be returned.
.Sp
If the call to the newly created object's load method returns false, then the normal Rose::DB::Object error handling is triggered.  The false value returned by the call to the load method is returned (assuming no exception was raised).
.Sp
If the load succeeds, the object is returned.
.RE
.IP "\fBget_set_on_save\fR" 4
.IX Item "get_set_on_save"
Creates a method that will attempt to create and load a Rose::DB::Object\-derived object based on a primary key formed from attributes of the current object, and save the object when the \*(L"parent\*(R" object is saved.
.Sp
If passed a single argument of undef, the \f(CW\*(C`hash_key\*(C'\fR used to store the object is set to undef.  If \f(CW\*(C`referential_integrity\*(C'\fR or \f(CW\*(C`required\*(C'\fR is true, then the columns that participate in the key are set to undef.  (If any key column is part of the primary key, however, it is not set to undef.) Otherwise, the argument must be one of the following:
.RS 4
.IP "\(bu" 4
An object of type \f(CW\*(C`class\*(C'\fR
.IP "\(bu" 4
A list of method name/value pairs.
.IP "\(bu" 4
A reference to a hash containing method name/value pairs.
.IP "\(bu" 4
A single scalar primary key value.
.RE
.RS 4
.Sp
The latter three argument types will be used to construct an object of type \f(CW\*(C`class\*(C'\fR.  A single primary key value is only a valid argument format if the \f(CW\*(C`class\*(C'\fR in question has a single-column primary key.  A hash reference argument must contain sufficient information for the object to be uniquely identified.
.Sp
The object is assigned to \f(CW\*(C`hash_key\*(C'\fR after having its \f(CW\*(C`key_columns\*(C'\fR set to their corresponding values in the current object.  The object will be saved into the database when the \*(L"parent\*(R" object is saved.  Any previously pending \f(CW\*(C`get_set_on_save\*(C'\fR action is discarded.
.Sp
If the object does not already exists in the database, it will be inserted.  If the object was previously loaded from or saved to the database, it will be updated.  Otherwise, it will be loaded.
.Sp
If called with no arguments and the \f(CW\*(C`hash_key\*(C'\fR used to store the object is defined, the object is returned.  Otherwise, the object is created and loaded from the database.
.Sp
The load may fail for several reasons.  The load will not even be attempted if any of the key attributes in the current object are undefined.  Instead, undef will be returned.
.Sp
If the call to the newly created object's load method returns false, then the normal Rose::DB::Object error handling is triggered.  The false value returned by the call to the load method is returned (assuming no exception was raised).
.Sp
If the load succeeds, the object is returned.
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example setup:
.Sp
.Vb 4
\&    # CLASS     DB TABLE
\&    # \-\-\-\-\-\-\-   \-\-\-\-\-\-\-\-
\&    # Product   products
\&    # Category  categories
\&
\&    package Product;
\&
\&    our @ISA = qw(Rose::DB::Object);
\&    ...
\&
\&    # You will almost never call the method\-maker directly
\&    # like this.  See the Rose::DB::Object::Metadata docs
\&    # for examples of more common usage.
\&    use Rose::DB::Object::MakeMethods::Generic
\&    (
\&      object_by_key =>
\&      [
\&        category => 
\&        {
\&          interface   => \*(Aqget_set\*(Aq,
\&          class       => \*(AqCategory\*(Aq,
\&          key_columns =>
\&          {
\&            # Map Product column names to Category column names
\&            category_id => \*(Aqid\*(Aq,
\&          },
\&        },
\&      ]
\&    );
\&    ...
.Ve
.Sp
Example \- get_set interface:
.Sp
.Vb 1
\&    $product = Product\->new(id => 5, category_id => 99);
\&
\&    # Read from the categories table
\&    $category = $product\->category; 
\&
\&    # $product\->category call is roughly equivalent to:
\&    #
\&    # $cat = Category\->new(id => $product\->category_id
\&    #                      db => $prog\->db);
\&    #
\&    # $ret = $cat\->load;
\&    # return $ret  unless($ret);
\&    # return $cat;
\&
\&    # Does not write to the db
\&    $product\->category(Category\->new(...));
\&
\&    $product\->save; # writes to products table only
.Ve
.Sp
Example \- get_set_now interface:
.Sp
.Vb 2
\&    # Read from the products table
\&    $product = Product\->new(id => 5)\->load;
\&
\&    # Read from the categories table
\&    $category = $product\->category;
\&
\&    # Write to the categories table:
\&    # (all possible argument formats show)
\&
\&    # Object argument
\&    $product\->category(Category\->new(...));
\&
\&    # Primary key value
\&    $product\->category(123); 
\&
\&    # Method name/value pairs in a hashref
\&    $product\->category(id => 123); 
\&
\&    # Method name/value pairs in a hashref
\&    $product\->category({ id => 123 }); 
\&
\&    # Write to the products table
\&    $product\->save;
.Ve
.Sp
Example \- get_set_on_save interface:
.Sp
.Vb 2
\&    # Read from the products table
\&    $product = Product\->new(id => 5)\->load;
\&
\&    # Read from the categories table
\&    $category = $product\->category;
\&
\&    # These do not write to the db:
\&
\&    # Object argument
\&    $product\->category(Category\->new(...));
\&
\&    # Primary key value
\&    $product\->category(123); 
\&
\&    # Method name/value pairs in a hashref
\&    $product\->category(id => 123); 
\&
\&    # Method name/value pairs in a hashref
\&    $product\->category({ id => 123 });
\&
\&    # Write to both the products and categories tables
\&    $product\->save;
.Ve
.Sp
Example \- delete_now interface:
.Sp
.Vb 2
\&    # Read from the products table
\&    $product = Product\->new(id => 5)\->load;
\&
\&    # Write to both the categories and products tables
\&    $product\->delete_category();
.Ve
.Sp
Example \- delete_on_save interface:
.Sp
.Vb 2
\&    # Read from the products table
\&    $product = Product\->new(id => 5)\->load;
\&
\&    # Does not write to the db
\&    $product\->delete_category(); 
\&
\&    # Write to both the products and categories tables
\&    $product\->save;
.Ve
.RE
.IP "\fBscalar\fR" 4
.IX Item "scalar"
Create get/set methods for scalar attributes.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.IP "\fBdefault \s-1VALUE\s0\fR" 4
.IX Item "default VALUE"
.PD
Determines the default value of the attribute.
.IP "\fBcheck_in \s-1ARRAYREF\s0\fR" 4
.IX Item "check_in ARRAYREF"
A reference to an array of valid values.  When setting the attribute, if the new value is not equal (string comparison) to one of the valid values, a fatal error will occur.
.IP "\fBhash_key \s-1NAME\s0\fR" 4
.IX Item "hash_key NAME"
The key inside the hash-based object to use for the storage of this
attribute.  Defaults to the name of the method.
.IP "\fBinit_method \s-1NAME\s0\fR" 4
.IX Item "init_method NAME"
The name of the method to call when initializing the value of an undefined attribute.  Defaults to the method name with the prefix \f(CW\*(C`init_\*(C'\fR added.  This option implies \f(CW\*(C`with_init\*(C'\fR.
.IP "\fBinterface \s-1NAME\s0\fR" 4
.IX Item "interface NAME"
Choose the interface.  The \f(CW\*(C`get_set\*(C'\fR interface is the default.
.IP "\fBlength \s-1INT\s0\fR" 4
.IX Item "length INT"
The maximum number of characters in the string.
.IP "\fBoverflow \s-1BEHAVIOR\s0\fR" 4
.IX Item "overflow BEHAVIOR"
Determines the behavior when the value is greater than the number of characters specified by the \f(CW\*(C`length\*(C'\fR option.  Valid values for \s-1BEHAVIOR\s0 are:
.RS 4
.IP "\fBfatal\fR" 4
.IX Item "fatal"
Throw an exception.
.IP "\fBtruncate\fR" 4
.IX Item "truncate"
Truncate the value to the correct length.
.IP "\fBwarn\fR" 4
.IX Item "warn"
Print a warning message.
.RE
.RS 4
.RE
.IP "\fBwith_init \s-1BOOL\s0\fR" 4
.IX Item "with_init BOOL"
Modifies the behavior of the \f(CW\*(C`get_set\*(C'\fR and \f(CW\*(C`get\*(C'\fR interfaces.  If the attribute is undefined, the method specified by the \f(CW\*(C`init_method\*(C'\fR option is called and the attribute is set to the return value of that
method.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.IP "\fBget_set\fR" 4
.IX Item "get_set"
.PD
Creates a get/set method for an object attribute.  When called with an argument, the value of the attribute is set.  The current value of the attribute is returned.
.IP "\fBget\fR" 4
.IX Item "get"
Creates an accessor method for an object attribute that returns the current value of the attribute.
.IP "\fBset\fR" 4
.IX Item "set"
Creates a mutator method for an object attribute.  When called with an argument, the value of the attribute is set.  If called with no arguments, a fatal error will occur.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&    package MyDBObject;
\&
\&    our @ISA = qw(Rose::DB::Object);
\&
\&    use Rose::DB::Object::MakeMethods::Generic
\&    (
\&      scalar => 
\&      [
\&        name => { default => \*(AqJoe\*(Aq },
\&        type => 
\&        {
\&          with_init => 1,
\&          check_in  => [ qw(AA AAA C D) ],
\&        }
\&        set_type =>
\&        {
\&          check_in  => [ qw(AA AAA C D) ],        
\&        }
\&      ],
\&    );
\&
\&    sub init_type { \*(AqC\*(Aq }
\&    ...
\&
\&    $o = MyDBObject\->new(...);
\&
\&    print $o\->name; # Joe
\&    print $o\->type; # C
\&
\&    $o\->name(\*(AqBob\*(Aq); # set
\&    $o\->type(\*(AqAA\*(Aq);  # set
\&
\&    eval { $o\->type(\*(Aqfoo\*(Aq) }; # fatal error: invalid value
\&
\&    print $o\->name, \*(Aq is \*(Aq, $o\->type; # get
.Ve
.RE
.IP "\fBset\fR" 4
.IX Item "set"
Create get/set methods for \*(L"set\*(R" attributes.   A \*(L"set\*(R" column in a database table contains an unordered group of values.  Not all databases support a \*(L"set\*(R" column type.  Check the Rose::DB documentation for your database type.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.IP "\fBdefault \s-1ARRAYREF\s0\fR" 4
.IX Item "default ARRAYREF"
.PD
Determines the default value of the attribute.  The value should be a reference to an array.
.IP "\fBhash_key \s-1NAME\s0\fR" 4
.IX Item "hash_key NAME"
The key inside the hash-based object to use for the storage of this
attribute.  Defaults to the name of the method.
.IP "\fBinterface \s-1NAME\s0\fR" 4
.IX Item "interface NAME"
Choose the interface.  The default is \f(CW\*(C`get_set\*(C'\fR.
.IP "\fBvalues \s-1ARRAYREF\s0\fR" 4
.IX Item "values ARRAYREF"
A reference to an array of valid values for the set.  If present, attempting to use an invalid value will cause a fatal error.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.IP "\fBget_set\fR" 4
.IX Item "get_set"
.PD
Creates a get/set method for a \*(L"set\*(R" object attribute.  A \*(L"set\*(R" column in a database table contains an unordered group of values.  On the Perl side of the fence, an ordered list (an array) is used to store the values, but keep in mind that the order is not significant, nor is it guaranteed to be preserved.
.Sp
When setting the attribute, the value is passed through the parse_set method of the object's db attribute.
.Sp
When saving to the database, if the attribute value is defined, the method will pass the attribute value through the format_set method of the object's db attribute before returning it.
.Sp
When not saving to the database, the method returns the set as a list in list context, or as a reference to the array in scalar context.
.IP "\fBget\fR" 4
.IX Item "get"
Creates an accessor method for a \*(L"set\*(R" object attribute.  A \*(L"set\*(R" column in a database table contains an unordered group of values.  On the Perl side of the fence, an ordered list (an array) is used to store the values, but keep in mind that the order is not significant, nor is it guaranteed to be preserved.
.Sp
When saving to the database, if the attribute value is defined, the method will pass the attribute value through the format_set method of the object's db attribute before returning it.
.Sp
When not saving to the database, the method returns the set as a list in list context, or as a reference to the array in scalar context.
.IP "\fBset\fR" 4
.IX Item "set"
Creates a mutator method for a \*(L"set\*(R" object attribute.  A \*(L"set\*(R" column in a database table contains an unordered group of values.  On the Perl side of the fence, an ordered list (an array) is used to store the values, but keep in mind that the order is not significant, nor is it guaranteed to be preserved.
.Sp
When setting the attribute, the value is passed through the parse_set method of the object's db attribute.
.Sp
When saving to the database, if the attribute value is defined, the method will pass the attribute value through the format_set method of the object's db attribute before returning it.
.Sp
When not saving to the database, the method returns the set as a list in list context, or as a reference to the array in scalar context.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&    package Person;
\&
\&    our @ISA = qw(Rose::DB::Object);
\&    ...
\&    use Rose::DB::Object::MakeMethods::Generic
\&    (
\&      set => 
\&      [
\&        \*(Aqnicknames\*(Aq,
\&        \*(Aqset_nicks\*(Aq => { interface => \*(Aqset\*(Aq, hash_key => \*(Aqnicknames\*(Aq },
\&
\&        \*(Aqparts\*(Aq => { default => [ qw(arms legs) ] },
\&      ],
\&    );
\&    ...
\&
\&    @parts = $person\->parts; # (\*(Aqarms\*(Aq, \*(Aqlegs\*(Aq)
\&    $parts = $person\->parts; # [ \*(Aqarms\*(Aq, \*(Aqlegs\*(Aq ]
\&
\&    $person\->nicknames(\*(AqJack\*(Aq, \*(AqGimpy\*(Aq);   # set with list
\&    $person\->nicknames([ \*(AqSlim\*(Aq, \*(AqGip\*(Aq ]); # set with array ref
\&
\&    $person\->set_nicks(\*(AqJack\*(Aq, \*(AqGimpy\*(Aq);   # set with list
\&    $person\->set_nicks([ \*(AqSlim\*(Aq, \*(AqGip\*(Aq ]); # set with array ref
.Ve
.RE
.IP "\fBvarchar\fR" 4
.IX Item "varchar"
Create get/set methods for variable-length character string attributes.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.IP "\fBdefault \s-1VALUE\s0\fR" 4
.IX Item "default VALUE"
.PD
Determines the default value of the attribute.
.IP "\fBhash_key \s-1NAME\s0\fR" 4
.IX Item "hash_key NAME"
The key inside the hash-based object to use for the storage of this attribute.  Defaults to the name of the method.
.IP "\fBinit_method \s-1NAME\s0\fR" 4
.IX Item "init_method NAME"
The name of the method to call when initializing the value of an undefined attribute.  Defaults to the method name with the prefix \f(CW\*(C`init_\*(C'\fR added.  This option implies \f(CW\*(C`with_init\*(C'\fR.
.IP "\fBinterface \s-1NAME\s0\fR" 4
.IX Item "interface NAME"
Choose the interface.  The \f(CW\*(C`get_set\*(C'\fR interface is the default.
.IP "\fBlength \s-1INT\s0\fR" 4
.IX Item "length INT"
The maximum number of characters in the string.
.IP "\fBoverflow \s-1BEHAVIOR\s0\fR" 4
.IX Item "overflow BEHAVIOR"
Determines the behavior when the value is greater than the number of characters specified by the \f(CW\*(C`length\*(C'\fR option.  Valid values for \s-1BEHAVIOR\s0 are:
.RS 4
.IP "\fBfatal\fR" 4
.IX Item "fatal"
Throw an exception.
.IP "\fBtruncate\fR" 4
.IX Item "truncate"
Truncate the value to the correct length.
.IP "\fBwarn\fR" 4
.IX Item "warn"
Print a warning message.
.RE
.RS 4
.RE
.IP "\fBwith_init \s-1BOOL\s0\fR" 4
.IX Item "with_init BOOL"
Modifies the behavior of the \f(CW\*(C`get_set\*(C'\fR and \f(CW\*(C`get\*(C'\fR interfaces.  If the attribute is undefined, the method specified by the \f(CW\*(C`init_method\*(C'\fR option is called and the attribute is set to the return value of that
method.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.IP "\fBget_set\fR" 4
.IX Item "get_set"
.PD
Creates a get/set accessor method for a fixed-length character string attribute.  When setting, any strings longer than \f(CW\*(C`length\*(C'\fR will be truncated.  If \f(CW\*(C`length\*(C'\fR is omitted, the string will be left unmodified.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&    package MyDBObject;
\&
\&    our @ISA = qw(Rose::DB::Object);
\&
\&    use Rose::DB::Object::MakeMethods::Generic
\&    (
\&      varchar => 
\&      [
\&        \*(Aqname\*(Aq => { length => 3 },
\&      ],
\&    );
\&
\&    ...
\&
\&    $o\->name(\*(AqJohn\*(Aq); # truncates on set
\&    print $o\->name;   # \*(AqJoh\*(Aq
.Ve
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
John C. Siracusa (siracusa@gmail.com)
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2010 by John C. Siracusa.  All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same terms
as Perl itself.
