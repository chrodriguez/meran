.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Rose::DB::Object::Metadata::Relationship 3"
.TH Rose::DB::Object::Metadata::Relationship 3 "2010-04-27" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Rose::DB::Object::Metadata::Relationship \- Base class for table relationship metadata objects.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MyRelationshipType;
\&
\&  use Rose::DB::Object::Metadata::Relationship;
\&  our @ISA = qw(Rose::DB::Object::Metadata::Relationship);
\&  ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the base class for objects that store and manipulate database table relationship metadata.  Relationship metadata objects are responsible for creating object methods that fetch and/or manipulate objects from related tables.  See the Rose::DB::Object::Metadata documentation for more information.
.SS "\s-1MAKING\s0 \s-1METHODS\s0"
.IX Subsection "MAKING METHODS"
A Rose::DB::Object::Metadata::Relationship\-derived object is responsible for creating object methods that manipulate objects in related tables.  Each relationship object can make zero or more methods for each available relationship method type.  A relationship method type describes the purpose of a method.  The default list of relationship method types contains only one type:
.ie n .IP """get""" 4
.el .IP "\f(CWget\fR" 4
.IX Item "get"
A method that returns one or more objects from the related table.
.PP
Methods are created by calling make_methods.  A list of method types can be passed to the call to make_methods.  If absent, the list of method types is determined by the auto_method_types method.  A list of all possible method types is available through the available_method_types method.
.PP
These methods make up the \*(L"public\*(R" interface to relationship method creation.  There are, however, several \*(L"protected\*(R" methods which are used internally to implement the methods described above.  (The word \*(L"protected\*(R" is used here in a vaguely \*(C+ sense, meaning \*(L"accessible to subclasses, but not to the public.\*(R")  Subclasses will probably find it easier to override and/or call these protected methods in order to influence the behavior of the \*(L"public\*(R" method maker methods.
.PP
A Rose::DB::Object::Metadata::Relationship object delegates method creation to a  Rose::Object::MakeMethods\-derived class.  Each Rose::Object::MakeMethods\-derived class has its own set of method types, each of which takes it own set of arguments.
.PP
Using this system, four pieces of information are needed to create a method on behalf of a Rose::DB::Object::Metadata::Relationship\-derived object:
.IP "\(bu" 4
The \fBrelationship method type\fR (e.g., \f(CW\*(C`get\*(C'\fR)
.IP "\(bu" 4
The \fBmethod maker class\fR (e.g., Rose::DB::Object::MakeMethods::Generic)
.IP "\(bu" 4
The \fBmethod maker method type\fR (e.g., object_by_key)
.IP "\(bu" 4
The \fBmethod maker arguments\fR (e.g., \f(CW\*(C`interface => \*(Aqget\*(Aq\*(C'\fR)
.PP
This information can be organized conceptually into a \*(L"method map\*(R" that connects a relationship method type to a method maker class and, finally, to one particular method type within that class, and its arguments.
.PP
There is no default method map for the Rose::DB::Object::Metadata::Relationship base class, but here is the method map from Rose::DB::Object::Metadata::Relationship::OneToOne as an example:
.ie n .IP """get_set""" 4
.el .IP "\f(CWget_set\fR" 4
.IX Item "get_set"
Rose::DB::Object::MakeMethods::Generic, scalar, \f(CW\*(C`interface => \*(Aqget_set\*(Aq, ...\*(C'\fR
.ie n .IP """get""" 4
.el .IP "\f(CWget\fR" 4
.IX Item "get"
Rose::DB::Object::MakeMethods::Generic, object_by_key, ...
.PP
Each item in the map is a relationship method type.  For each relationship method type, the method maker class, the method maker method type, and the \*(L"interesting\*(R" method maker arguments are listed, in that order.
.PP
The \*(L"...\*(R" in the method maker arguments is meant to indicate that arguments have been omitted.  Arguments that are common to all relationship method types are routinely omitted from the method map for the sake of brevity.  If there are no \*(L"interesting\*(R" method maker arguments, then \*(L"...\*(R" may appear by itself, as shown above.
.PP
The purpose of documenting the method map is to answer the question, \*(L"What kind of method(s) will be created by this relationship object for a given method type?\*(R"  Given the method map, it's possible to read the documentation for each method maker class to determine how methods of the specified type behave when passed the listed arguments.
.PP
To this end, each Rose::DB::Object::Metadata::Relationship\-derived class in the Rose::DB::Object module distribution will list its method map in its documentation.  This is a concise way to document the behavior that is specific to each relationship class, while omitting the common functionality (which is documented here, in the relationship base class).
.PP
Remember, the existence and behavior of the method map is really implementation detail.  A relationship object is free to implement the public method-making interface however it wants, without regard to any conceptual or actual method map.  It must then, of course, document what kinds of methods it makes for each of its method types, but it does not have to use a method map to do so.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.IP "\fBdefault_auto_method_types [\s-1TYPES\s0]\fR" 4
.IX Item "default_auto_method_types [TYPES]"
Get or set the default list of auto_method_types.  \s-1TYPES\s0 should be a list of relationship method types.  Returns the list of default relationship method types (in list context) or a reference to an array of the default relationship method types (in scalar context).  The default list is empty.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "\fBnew \s-1PARAMS\s0\fR" 4
.IX Item "new PARAMS"
Constructs a new object based on \s-1PARAMS\s0, where \s-1PARAMS\s0 are
name/value pairs.  Any object method is a valid parameter name.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.IP "\fBavailable_method_types\fR" 4
.IX Item "available_method_types"
Returns the full list of relationship method types supported by this class.
.IP "\fBauto_method_types [\s-1TYPES\s0]\fR" 4
.IX Item "auto_method_types [TYPES]"
Get or set the list of relationship method types that are automatically created when make_methods is called without an explicit list of relationship method types.  The default list is determined by the default_auto_method_types class method.
.IP "\fBbuild_method_name_for_type \s-1TYPE\s0\fR" 4
.IX Item "build_method_name_for_type TYPE"
Return a method name for the relationship method type \s-1TYPE\s0.  Subclasses must override this method.  The default implementation causes a fatal error if called.
.IP "\fBclass [\s-1CLASS\s0]\fR" 4
.IX Item "class [CLASS]"
Get or set the name of the Rose::DB::Object\-derived class that fronts the foreign table referenced by this relationship.
.IP "\fBis_singular\fR" 4
.IX Item "is_singular"
Returns true of the relationship may refer to more than one related object, false otherwise.  For example, this method returns true for \*(L"is_singular\*(R" in Rose::DB::Object::Metadata::Relationship::OneToMany objects, but false for \*(L"is_singular\*(R" in Rose::DB::Object::Metadata::Relationship::ManyToOne objects.
.Sp
Relationship subclasses must override this method and return an appropriate value.
.IP "\fBmake_methods \s-1PARAMS\s0\fR" 4
.IX Item "make_methods PARAMS"
Create object method used to manipulate objects in related tables.  Any applicable column triggers are also added.  \s-1PARAMS\s0 are name/value pairs.  Valid \s-1PARAMS\s0 are:
.RS 4
.ie n .IP """preserve_existing BOOL""" 4
.el .IP "\f(CWpreserve_existing BOOL\fR" 4
.IX Item "preserve_existing BOOL"
Boolean flag that indicates whether or not to preserve existing methods in the case of a name conflict.
.ie n .IP """replace_existing BOOL""" 4
.el .IP "\f(CWreplace_existing BOOL\fR" 4
.IX Item "replace_existing BOOL"
Boolean flag that indicates whether or not to replace existing methods in the case of a name conflict.
.ie n .IP """target_class CLASS""" 4
.el .IP "\f(CWtarget_class CLASS\fR" 4
.IX Item "target_class CLASS"
The class in which to make the method(s).  If omitted, it defaults to the calling class.
.ie n .IP """types ARRAYREF""" 4
.el .IP "\f(CWtypes ARRAYREF\fR" 4
.IX Item "types ARRAYREF"
A reference to an array of relationship method types to be created.  If omitted, it defaults to the list of relationship method types returned by auto_method_types.
.RE
.RS 4
.Sp
If any of the methods could not be created for any reason, a fatal error will occur.
.RE
.IP "\fBmethods \s-1MAP\s0\fR" 4
.IX Item "methods MAP"
Set the list of auto_method_types and method names all at once.  \s-1MAP\s0 should be a reference to a hash whose keys are method types and whose values are either undef or method names.  If a value is undef, then the method name for that method type will be generated by calling build_method_name_for_type, as usual.  Otherwise, the specified method name will be used.
.IP "\fBmethod_types [\s-1TYPES\s0]\fR" 4
.IX Item "method_types [TYPES]"
This method is an alias for the auto_method_types method.
.IP "\fBmethod_name \s-1TYPE\s0 [, \s-1NAME\s0]\fR" 4
.IX Item "method_name TYPE [, NAME]"
Get or set the name of the relationship method of type \s-1TYPE\s0.
.IP "\fBname [\s-1NAME\s0]\fR" 4
.IX Item "name [NAME]"
Get or set the name of the relationship.  This name must be unique among all other relationships for a given Rose::DB::Object\-derived class.
.IP "\fBtype\fR" 4
.IX Item "type"
Returns a string describing the type of relationship.  Subclasses must override this method.  The default implementation causes a fatal error if called.
.SH "PROTECTED API"
.IX Header "PROTECTED API"
These methods are not part of the public interface, but are supported for use by subclasses.  Put another way, given an unknown object that \*(L"isa\*(R" Rose::DB::Object::Metadata::Relationship, there should be no expectation that the following methods exist.  But subclasses, which know the exact class from which they inherit, are free to use these methods in order to implement the public \s-1API\s0 described above.
.IP "\fBmethod_maker_arguments \s-1TYPE\s0\fR" 4
.IX Item "method_maker_arguments TYPE"
Returns a hash (in list context) or reference to a hash (in scalar context) of name/value arguments that will be passed to the method_maker_class when making the relationship method type \s-1TYPE\s0.
.IP "\fBmethod_maker_class \s-1TYPE\s0 [, \s-1CLASS\s0]\fR" 4
.IX Item "method_maker_class TYPE [, CLASS]"
If \s-1CLASS\s0 is passed, the name of the Rose::Object::MakeMethods\-derived class used to create the object method of type \s-1TYPE\s0 is set to \s-1CLASS\s0.
.Sp
Returns the name of the Rose::Object::MakeMethods\-derived class used to create the object method of type \s-1TYPE\s0.
.IP "\fBmethod_maker_type \s-1TYPE\s0 [, \s-1NAME\s0]\fR" 4
.IX Item "method_maker_type TYPE [, NAME]"
If \s-1NAME\s0 is passed, the name of the method maker method type for the relationship method type \s-1TYPE\s0 is set to \s-1NAME\s0.
.Sp
Returns the method maker method type for the relationship method type \s-1TYPE\s0.
.SH "AUTHOR"
.IX Header "AUTHOR"
John C. Siracusa (siracusa@gmail.com)
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2010 by John C. Siracusa.  All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same terms
as Perl itself.
