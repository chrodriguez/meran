.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.19)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MARC::Field 3"
.TH MARC::Field 3 "2010-09-09" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MARC::Field \- Perl extension for handling MARC fields
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use MARC::Field;
\&
\&  # If your system uses wacky control field tags, add them
\&  MARC::Field\->allow_controlfield_tags(\*(AqFMT\*(Aq, \*(AqLLE\*(Aq);
\&
\&  my $field = MARC::Field\->new( 245, \*(Aq1\*(Aq, \*(Aq0\*(Aq,
\&       \*(Aqa\*(Aq => \*(AqRaccoons and ripe corn / \*(Aq,
\&       \*(Aqc\*(Aq => \*(AqJim Arnosky.\*(Aq
\&  );
\&  $field\->add_subfields( "a", "1st ed." );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Defines \s-1MARC\s0 fields for use in the MARC::Record module.  I suppose
you could use them on their own, but that wouldn't be very interesting.
.SH "EXPORT"
.IX Header "EXPORT"
None by default.  Any errors are stored in \f(CW$MARC::Field::ERROR\fR, which
\&\f(CW$MARC::Record\fR usually bubbles up to \f(CW$MARC::Record::ERROR\fR.
.SH "CLASS VARIABLES"
.IX Header "CLASS VARIABLES"
\&\fBextra_controlfield_tags\fR: Some systems (notably Ex Libris's Aleph) throw
extra control fields in their \s-1MARC\s0 (e.g., Aleph's MARC-XML tends to have a 
\&\f(CW\*(C`FMT\*(C'\fR control field). We keep a class-level hash to track to track them; it can
be manipulated with \f(CW\*(C`allow_controlfield_tags\*(C'\fR and c<disallow_controlfield_tags>.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fInew()\fP"
.IX Subsection "new()"
The constructor, which will return a MARC::Field object. Typically you will
pass in the tag number, indicator 1, indicator 2, and then a list of any
subfield/data pairs. For example:
.PP
.Vb 5
\&  my $field = MARC::Field\->new(
\&       245, \*(Aq1\*(Aq, \*(Aq0\*(Aq,
\&       \*(Aqa\*(Aq => \*(AqRaccoons and ripe corn / \*(Aq,
\&       \*(Aqc\*(Aq => \*(AqJim Arnosky.\*(Aq
\&  );
.Ve
.PP
Or if you want to add a control field (< 010) that does not have indicators.
.PP
.Vb 1
\&  my $field = MARC::Field\->new( \*(Aq001\*(Aq, \*(Aq 14919759\*(Aq );
.Ve
.SS "\fItag()\fP"
.IX Subsection "tag()"
Returns the three digit tag for the field.
.SS "indicator(indno)"
.IX Subsection "indicator(indno)"
Returns the specified indicator.  Returns \f(CW\*(C`undef\*(C'\fR and sets
\&\f(CW$MARC::Field::ERROR\fR if the \fIindno\fR is not 1 or 2, or if
the tag doesn't have indicators.
.ie n .SS "allow_controlfield_tags($tag, $tag2, ...)"
.el .SS "allow_controlfield_tags($tag, \f(CW$tag2\fP, ...)"
.IX Subsection "allow_controlfield_tags($tag, $tag2, ...)"
Add \f(CW$tags\fR to class-level list of strings to consider valid control fields tags (in addition to 001 through 009).
Tags must have three characters.
.ie n .SS "disallow_controlfield_tags($tag, $tag2, ...) =head2 disallow_controlfield_tags('*')"
.el .SS "disallow_controlfield_tags($tag, \f(CW$tag2\fP, ...) =head2 disallow_controlfield_tags('*')"
.IX Subsection "disallow_controlfield_tags($tag, $tag2, ...) =head2 disallow_controlfield_tags('*')"
Revoke the validity of a control field tag previously added with allow_controlfield_tags. As a special case, 
if you pass the string '*' it will clear out all previously-added tags.
.PP
\&\s-1NOTE\s0 that this will only deal with stuff added with allow_controlfield_tags; you can't disallow '001'.
.SS "is_controlfield_tag($tag) \*(-- does the given tag denote a control field?"
.IX Subsection "is_controlfield_tag($tag)  does the given tag denote a control field?"
Generally called as a class method (e.g., MARC::Field\->is_controlfield_tag('001'))
.SS "\fIis_control_field()\fP"
.IX Subsection "is_control_field()"
Tells whether this field is one of the control tags from 001\-009.
.SS "subfield(code)"
.IX Subsection "subfield(code)"
When called in a scalar context returns the text from the first subfield
matching the subfield code.
.PP
.Vb 1
\&    my $subfield = $field\->subfield( \*(Aqa\*(Aq );
.Ve
.PP
Or if you think there might be more than one you can get all of them by
calling in a list context:
.PP
.Vb 1
\&    my @subfields = $field\->subfield( \*(Aqa\*(Aq );
.Ve
.PP
If no matching subfields are found, \f(CW\*(C`undef\*(C'\fR is returned in a scalar context
and an empty list in a list context.
.PP
If the tag is a control field, \f(CW\*(C`undef\*(C'\fR is returned and
\&\f(CW$MARC::Field::ERROR\fR is set.
.SS "\fIsubfields()\fP"
.IX Subsection "subfields()"
Returns all the subfields in the field.  What's returned is a list of
list refs, where the inner list is a subfield code and the subfield data.
.PP
For example, this might be the subfields from a 245 field:
.PP
.Vb 4
\&        (
\&          [ \*(Aqa\*(Aq, \*(AqPerl in a nutshell :\*(Aq ],
\&          [ \*(Aqb\*(Aq, \*(AqA desktop quick reference.\*(Aq ],
\&        )
.Ve
.SS "\fIdata()\fP"
.IX Subsection "data()"
Returns the data part of the field, if the tag number is less than 10.
.SS "add_subfields(code,text[,code,text ...])"
.IX Subsection "add_subfields(code,text[,code,text ...])"
Adds subfields to the end of the subfield list.
.PP
.Vb 1
\&    $field\->add_subfields( \*(Aqc\*(Aq => \*(Aq1985\*(Aq );
.Ve
.PP
Returns the number of subfields added, or \f(CW\*(C`undef\*(C'\fR if there was an error.
.SS "\fIdelete_subfield()\fP"
.IX Subsection "delete_subfield()"
\&\fIdelete_subfield()\fR allows you to remove subfields from a field:
.PP
.Vb 2
\&    # delete any subfield a in the field
\&    $field\->delete_subfield(code => \*(Aqa\*(Aq);
\&
\&    # delete any subfield a or u in the field
\&    $field\->delete_subfield(code => [\*(Aqa\*(Aq, \*(Aqu\*(Aq]);
.Ve
.PP
If you want to only delete subfields at a particular position you can 
use the pos parameter:
.PP
.Vb 2
\&    # delete subfield u at the first position
\&    $field\->delete_subfield(code => \*(Aqu\*(Aq, pos => 0);
\&
\&    # delete subfield u at first or second position
\&    $field\->delete_subfield(code => \*(Aqu\*(Aq, pos => [0,1]);
.Ve
.PP
You can specify a regex to for only deleting subfields that match:
.PP
.Vb 2
\&   # delete any subfield u that matches zombo.com
\&   $field\->delete_subfield(code => \*(Aqu\*(Aq, match => qr/zombo.com/);
.Ve
.SS "\fIdelete_subfields()\fP"
.IX Subsection "delete_subfields()"
Delete all subfields with a given subfield code. This is here for backwards
compatability, you should use the more flexible \fIdelete_subfield()\fR.
.SS "\fIupdate()\fP"
.IX Subsection "update()"
Allows you to change the values of the field. You can update indicators
and subfields like this:
.PP
.Vb 1
\&  $field\->update( ind2 => \*(Aq4\*(Aq, a => \*(AqThe ballad of Abe Lincoln\*(Aq);
.Ve
.PP
If you attempt to update a subfield which does not currently exist in the field,
then a new subfield will be appended to the field. If you don't like this
auto-vivification you must check for the existence of the subfield prior to
update.
.PP
.Vb 3
\&  if ( $field\->subfield( \*(Aqa\*(Aq ) ) {
\&    $field\->update( \*(Aqa\*(Aq => \*(AqCryptonomicon\*(Aq );
\&  }
.Ve
.PP
If you want to update a field that has no indicators or subfields (000\-009)
just call \fIupdate()\fR with one argument, the string that you would like to
set the field to.
.PP
.Vb 2
\&  $field = $record\->field( \*(Aq003\*(Aq );
\&  $field\->update(\*(AqIMchF\*(Aq);
.Ve
.PP
Note: when doing subfield updates be aware that \f(CW\*(C`update()\*(C'\fR will only
update the first occurrence. If you need to do anything more complicated
you will probably need to create a new field and use \f(CW\*(C`replace_with()\*(C'\fR.
.PP
Returns the number of items modified.
.SS "\fIreplace_with()\fP"
.IX Subsection "replace_with()"
Allows you to replace an existing field with a new one. You need to pass
\&\f(CW\*(C`replace()\*(C'\fR a MARC::Field object to replace the existing field with. For
example:
.PP
.Vb 3
\&  $field = $record\->field(\*(Aq245\*(Aq);
\&  my $new_field = new MARC::Field(\*(Aq245\*(Aq,\*(Aq0\*(Aq,\*(Aq4\*(Aq,\*(AqThe ballad of Abe Lincoln.\*(Aq);
\&  $field\->replace_with($new_field);
.Ve
.PP
Doesn't return a meaningful or reliable value.
.SS "as_string( [$subfields] )"
.IX Subsection "as_string( [$subfields] )"
Returns a string of all subfields run together.  A space is added to
the result between each subfield.  The tag number and subfield
character are not included.
.PP
Subfields appear in the output string in the order in which they
occur in the field.
.PP
If \f(CW$subfields\fR is specified, then only those subfields will be included.
.PP
.Vb 9
\&  my $field = MARC::Field\->new(
\&                245, \*(Aq1\*(Aq, \*(Aq0\*(Aq,
\&                        \*(Aqa\*(Aq => \*(AqAbraham Lincoln\*(Aq,
\&                        \*(Aqh\*(Aq => \*(Aq[videorecording] :\*(Aq,
\&                        \*(Aqb\*(Aq => \*(Aqpreserving the union /\*(Aq,
\&                        \*(Aqc\*(Aq => \*(AqA&E Home Video.\*(Aq
\&                );
\&  print $field\->as_string( \*(Aqabh\*(Aq ); # Only those three subfields
\&  # prints \*(AqAbraham Lincoln [videorecording] : preserving the union /\*(Aq.
.Ve
.PP
Note that subfield h comes before subfield b in the output.
.SS "\fIas_formatted()\fP"
.IX Subsection "as_formatted()"
Returns a pretty string for printing in a \s-1MARC\s0 dump.
.SS "\fIas_usmarc()\fP"
.IX Subsection "as_usmarc()"
Returns a string for putting into a \s-1USMARC\s0 file.  It's really only
useful for \f(CW\*(C`MARC::Record::as_usmarc()\*(C'\fR.
.SS "\fIclone()\fP"
.IX Subsection "clone()"
Makes a copy of the field.  Note that this is not just the same as saying
.PP
.Vb 1
\&    my $newfield = $field;
.Ve
.PP
since that just makes a copy of the reference.  To get a new object, you must
.PP
.Vb 1
\&    my $newfield = $field\->clone;
.Ve
.PP
Returns a MARC::Field record.
.SS "\fIwarnings()\fP"
.IX Subsection "warnings()"
Returns the warnings that were created when the record was read.
These are things like \*(L"Invalid indicators converted to blanks\*(R".
.PP
The warnings are items that you might be interested in, or might
not.  It depends on how stringently you're checking data.  If
you're doing some grunt data analysis, you probably don't care.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See the \*(L"\s-1SEE\s0 \s-1ALSO\s0\*(R" section for MARC::Record.
.SH "TODO"
.IX Header "TODO"
See the \*(L"\s-1TODO\s0\*(R" section for MARC::Record.
.SH "LICENSE"
.IX Header "LICENSE"
This code may be distributed under the same terms as Perl itself.
.PP
Please note that these modules are not products of or supported by the
employers of the various contributors to the code.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Lester, \f(CW\*(C`<andy@petdance.com>\*(C'\fR
