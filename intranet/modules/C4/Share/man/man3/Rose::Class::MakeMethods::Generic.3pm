.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Rose::Class::MakeMethods::Generic 3"
.TH Rose::Class::MakeMethods::Generic 3 "2010-10-17" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Rose::Class::MakeMethods::Generic \- Create simple class methods.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MyClass;
\&
\&  use Rose::Class::MakeMethods::Generic
\&  (
\&    scalar => 
\&    [
\&      \*(Aqerror\*(Aq,
\&      \*(Aqtype\*(Aq => { interface => \*(Aqget_set_init\*(Aq },
\&    ],
\&
\&    inheritable_scalar => \*(Aqname\*(Aq,
\&  );
\&
\&  sub init_type { \*(Aqspecial\*(Aq }
\&  ...
\&
\&  package MySubClass;
\&  our @ISA = qw(MyClass);
\&  ...
\&
\&  MyClass\->error(123);
\&
\&  print MyClass\->type; # \*(Aqspecial\*(Aq
\&
\&  MyClass\->name(\*(AqFred\*(Aq);
\&  print MySubClass\->name; # \*(AqFred\*(Aq
\&
\&  MyClass\->name(\*(AqWilma\*(Aq);
\&  print MySubClass\->name; # \*(AqWilma\*(Aq
\&
\&  MySubClass\->name(\*(AqBam\*(Aq);
\&  print MyClass\->name;    # \*(AqWilma\*(Aq
\&  print MySubClass\->name; # \*(AqBam\*(Aq
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Rose::Class::MakeMethods::Generic is a method maker that inherits from Rose::Object::MakeMethods.  See the Rose::Object::MakeMethods documentation to learn about the interface.  The method types provided by this module are described below.  All methods work only with classes, not objects.
.SH "METHODS TYPES"
.IX Header "METHODS TYPES"
.IP "\fBscalar\fR" 4
.IX Item "scalar"
Create get/set methods for scalar class attributes.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.ie n .IP """init_method""" 4
.el .IP "\f(CWinit_method\fR" 4
.IX Item "init_method"
.PD
The name of the class method to call when initializing the value of an undefined attribute.  This option is only applicable when using the \f(CW\*(C`get_set_init\*(C'\fR interface.  Defaults to the method name with the prefix \f(CW\*(C`init_\*(C'\fR added.
.ie n .IP """interface""" 4
.el .IP "\f(CWinterface\fR" 4
.IX Item "interface"
Choose one of the two possible interfaces.  Defaults to \f(CW\*(C`get_set\*(C'\fR.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.ie n .IP """get_set""" 4
.el .IP "\f(CWget_set\fR" 4
.IX Item "get_set"
.PD
Creates a simple get/set accessor method for a class attribute.  When called with an argument, the value of the attribute is set.  The current value of the attribute is returned.
.ie n .IP """get_set_init""" 4
.el .IP "\f(CWget_set_init\fR" 4
.IX Item "get_set_init"
Behaves like the \f(CW\*(C`get_set\*(C'\fR interface unless the value of the attribute is undefined.  In that case, the class method specified by the \f(CW\*(C`init_method\*(C'\fR option is called and the attribute is set to the return value of that method.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&    package MyClass;
\&
\&    use Rose::Class::MakeMethods::Generic
\&    (
\&      scalar => \*(Aqpower\*(Aq,
\&      \*(Aqscalar \-\-get_set_init\*(Aq => \*(Aqname\*(Aq,
\&    );
\&
\&    sub init_name { \*(AqFred\*(Aq }
\&    ...
\&
\&    MyClass\->power(99);    # returns 99
\&    MyClass\->name;         # returns "Fred"
\&    MyClass\->name(\*(AqBill\*(Aq); # returns "Bill"
.Ve
.RE
.IP "\fBinheritable_boolean\fR" 4
.IX Item "inheritable_boolean"
Create get/set methods for boolean class attributes that are inherited by subclasses until/unless their values are changed.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.ie n .IP """interface""" 4
.el .IP "\f(CWinterface\fR" 4
.IX Item "interface"
.PD
Choose the interface.  This is kind of pointless since there is only one interface right now.  Defaults to \f(CW\*(C`get_set\*(C'\fR, obviously.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.ie n .IP """get_set""" 4
.el .IP "\f(CWget_set\fR" 4
.IX Item "get_set"
.PD
Creates a get/set accessor method for a class attribute.  When called with an argument, the value of the attribute is set to 1 if that argument is true or 0 if it is false.  The value of the attribute is then returned.
.Sp
If called with no arguments, and if the attribute was never set for this class, then a left-most, breadth-first search of the parent classes is initiated.  The value returned is taken from first parent class encountered that has ever had this attribute set.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&    package MyClass;
\&
\&    use Rose::Class::MakeMethods::Generic
\&    (
\&      inheritable_boolean => \*(Aqenabled\*(Aq,
\&    );
\&    ...
\&
\&    package MySubClass;
\&    our @ISA = qw(MyClass);
\&    ...
\&
\&    package MySubSubClass;
\&    our @ISA = qw(MySubClass);
\&    ...
\&
\&    $x = MyClass\->enabled;       # undef
\&    $y = MySubClass\->enabled;    # undef
\&    $z = MySubSubClass\->enabled; # undef
\&
\&    MyClass\->enabled(1);
\&    $x = MyClass\->enabled;       # 1
\&    $y = MySubClass\->enabled;    # 1
\&    $z = MySubSubClass\->enabled; # 1
\&
\&    MyClass\->enabled(0);
\&    $x = MyClass\->enabled;       # 0
\&    $y = MySubClass\->enabled;    # 0
\&    $z = MySubSubClass\->enabled; # 0
\&
\&    MySubClass\->enabled(1);
\&    $x = MyClass\->enabled;       # 0
\&    $y = MySubClass\->enabled;    # 1
\&    $z = MySubSubClass\->enabled; # 1
\&
\&    MyClass\->enabled(1);
\&    MySubClass\->enabled(undef);
\&    $x = MyClass\->enabled;       # 1
\&    $y = MySubClass\->enabled;    # 0
\&    $z = MySubSubClass\->enabled; # 0
\&
\&    MySubSubClass\->enabled(1);
\&    $x = MyClass\->enabled;       # 1
\&    $y = MySubClass\->enabled;    # 0
\&    $z = MySubSubClass\->enabled; # 0
.Ve
.RE
.IP "\fBinheritable_scalar\fR" 4
.IX Item "inheritable_scalar"
Create get/set methods for scalar class attributes that are inherited by subclasses until/unless their values are changed.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.ie n .IP """interface""" 4
.el .IP "\f(CWinterface\fR" 4
.IX Item "interface"
.PD
Choose the interface.  This is kind of pointless since there is only one interface right now.  Defaults to \f(CW\*(C`get_set\*(C'\fR, obviously.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.ie n .IP """get_set""" 4
.el .IP "\f(CWget_set\fR" 4
.IX Item "get_set"
.PD
Creates a get/set accessor method for a class attribute.  When called with an argument, the value of the attribute is set and then returned.
.Sp
If called with no arguments, and if the attribute was never set for this class, then a left-most, breadth-first search of the parent classes is initiated.  The value returned is taken from first parent class encountered that has ever had this attribute set.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&    package MyClass;
\&
\&    use Rose::Class::MakeMethods::Generic
\&    (
\&      inheritable_scalar => \*(Aqname\*(Aq,
\&    );
\&    ...
\&
\&    package MySubClass;
\&    our @ISA = qw(MyClass);
\&    ...
\&
\&    package MySubSubClass;
\&    our @ISA = qw(MySubClass);
\&    ...
\&
\&    $x = MyClass\->name;       # undef
\&    $y = MySubClass\->name;    # undef
\&    $z = MySubSubClass\->name; # undef
\&
\&    MyClass\->name(\*(AqFred\*(Aq);
\&    $x = MyClass\->name;       # \*(AqFred\*(Aq
\&    $y = MySubClass\->name;    # \*(AqFred\*(Aq
\&    $z = MySubSubClass\->name; # \*(AqFred\*(Aq
\&
\&    MyClass\->name(\*(AqWilma\*(Aq);
\&    $x = MyClass\->name;       # \*(AqWilma\*(Aq
\&    $y = MySubClass\->name;    # \*(AqWilma\*(Aq
\&    $z = MySubSubClass\->name; # \*(AqWilma\*(Aq
\&
\&    MySubClass\->name(\*(AqBam\*(Aq);
\&    $x = MyClass\->name;       # \*(AqWilma\*(Aq
\&    $y = MySubClass\->name;    # \*(AqBam\*(Aq
\&    $z = MySubSubClass\->name; # \*(AqBam\*(Aq
\&
\&    MyClass\->name(\*(AqKoop\*(Aq);
\&    MySubClass\->name(undef);
\&    $x = MyClass\->name;       # \*(AqKoop\*(Aq
\&    $y = MySubClass\->name;    # undef
\&    $z = MySubSubClass\->name; # undef
\&
\&    MySubSubClass\->name(\*(AqSam\*(Aq);
\&    $x = MyClass\->name;       # \*(AqKoop\*(Aq
\&    $y = MySubClass\->name;    # undef
\&    $z = MySubSubClass\->name; # \*(AqSam\*(Aq
.Ve
.RE
.IP "\fBhash\fR" 4
.IX Item "hash"
Create methods to manipulate a hash of class attributes.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.ie n .IP """hash_key""" 4
.el .IP "\f(CWhash_key\fR" 4
.IX Item "hash_key"
.PD
The key to use for the storage of this attribute.  Defaults to the name of the method.
.ie n .IP """interface""" 4
.el .IP "\f(CWinterface\fR" 4
.IX Item "interface"
Choose which interface to use.  Defaults to \f(CW\*(C`get_set\*(C'\fR.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.ie n .IP """get_set""" 4
.el .IP "\f(CWget_set\fR" 4
.IX Item "get_set"
.PD
If called with no arguments, returns a list of key/value pairs in list context or a reference to the actual hash used to store values in scalar context.
.Sp
If called with one argument, and that argument is a reference to a hash, that hash reference is used as the new value for the attribute.  Returns a list of key/value pairs in list context or a reference to the actual hash used to store values in scalar context.
.Sp
If called with one argument, and that argument is a reference to an array, then a list of the hash values for each key in the array is returned.
.Sp
If called with one argument, and it is not a reference to a hash or an array, then the hash value for that key is returned.
.Sp
If called with an even number of arguments, they are taken as name/value pairs and are added to the hash.  It then returns a list of key/value pairs in list context or a reference to the actual hash used to store values in scalar context.
.Sp
Passing an odd number of arguments greater than 1 causes a fatal error.
.ie n .IP """get_set_all""" 4
.el .IP "\f(CWget_set_all\fR" 4
.IX Item "get_set_all"
If called with no arguments, returns a list of key/value pairs in list context or a reference to the actual hash used to store values in scalar context.
.Sp
If called with one argument, and that argument is a reference to a hash, that hash reference is used as the new value for the attribute.  Returns a list of key/value pairs in list context or a reference to the actual hash used to store values in scalar context.
.Sp
Otherwise, the hash is emptied and the arguments are taken as name/value pairs that are then added to the hash.  It then returns a list of key/value pairs in list context or a reference to the actual hash used to store values in scalar context.
.ie n .IP """clear""" 4
.el .IP "\f(CWclear\fR" 4
.IX Item "clear"
Sets the attribute to an empty hash.
.ie n .IP """reset""" 4
.el .IP "\f(CWreset\fR" 4
.IX Item "reset"
Sets the attribute to undef.
.ie n .IP """delete""" 4
.el .IP "\f(CWdelete\fR" 4
.IX Item "delete"
Deletes the key(s) passed as arguments.  Failure to pass any arguments causes a fatal error.
.ie n .IP """exists""" 4
.el .IP "\f(CWexists\fR" 4
.IX Item "exists"
Returns true of the argument exists in the hash, false otherwise. Failure to pass an argument or passing more than one argument causes a fatal error.
.ie n .IP """keys""" 4
.el .IP "\f(CWkeys\fR" 4
.IX Item "keys"
Returns the keys of the hash in list context, or a reference to an array of the keys of the hash in scalar context.  The keys are not sorted.
.ie n .IP """names""" 4
.el .IP "\f(CWnames\fR" 4
.IX Item "names"
An alias for the \f(CW\*(C`keys\*(C'\fR interface.
.ie n .IP """values""" 4
.el .IP "\f(CWvalues\fR" 4
.IX Item "values"
Returns the values of the hash in list context, or a reference to an array of the values of the hash in scalar context.  The values are not sorted.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&    package MyClass;
\&
\&    use Rose::Class::MakeMethods::Generic
\&    (
\&      hash =>
\&      [
\&        param        => { hash_key =>\*(Aqparams\*(Aq },
\&        params       => { interface=>\*(Aqget_set_all\*(Aq },
\&        param_names  => { interface=>\*(Aqkeys\*(Aq,   hash_key=>\*(Aqparams\*(Aq },
\&        param_values => { interface=>\*(Aqvalues\*(Aq, hash_key=>\*(Aqparams\*(Aq },
\&        param_exists => { interface=>\*(Aqexists\*(Aq, hash_key=>\*(Aqparams\*(Aq },
\&        delete_param => { interface=>\*(Aqdelete\*(Aq, hash_key=>\*(Aqparams\*(Aq },
\&
\&        clear_params => { interface=>\*(Aqclear\*(Aq, hash_key=>\*(Aqparams\*(Aq },
\&        reset_params => { interface=>\*(Aqreset\*(Aq, hash_key=>\*(Aqparams\*(Aq },
\&      ],
\&    );
\&    ...
\&
\&    MyClass\->params; # undef
\&
\&    MyClass\->params(a => 1, b => 2); # add pairs
\&    $val = MyClass\->param(\*(Aqb\*(Aq); # 2
\&
\&    %params = MyClass\->params; # copy hash keys and values
\&    $params = MyClass\->params; # get hash ref
\&
\&    MyClass\->params({ c => 3, d => 4 }); # replace contents
\&
\&    MyClass\->param_exists(\*(Aqa\*(Aq); # false
\&
\&    $keys = join(\*(Aq,\*(Aq, sort MyClass\->param_names);  # \*(Aqc,d\*(Aq
\&    $vals = join(\*(Aq,\*(Aq, sort MyClass\->param_values); # \*(Aq3,4\*(Aq
\&
\&    MyClass\->delete_param(\*(Aqc\*(Aq);
\&    MyClass\->param(f => 7, g => 8);
\&
\&    $vals = join(\*(Aq,\*(Aq, sort MyClass\->param_values); # \*(Aq4,7,8\*(Aq
\&
\&    MyClass\->clear_params;
\&    $params = MyClass\->params; # empty hash
\&
\&    MyClass\->reset_params;
\&    $params = MyClass\->params; # undef
.Ve
.RE
.IP "\fBinheritable_hash\fR" 4
.IX Item "inheritable_hash"
Create methods to manipulate a hash of class attributes that can be inherited by subclasses.
.Sp
The hash of attributes is inherited by subclasses using a one-time copy.  Any subclass that accesses or manipulates the hash in any way will immediately get its own private copy of the hash \fIas it exists in the superclass at the time of the access or manipulation\fR.
.Sp
The superclass from which the hash is copied is the closest (\*(L"least super\*(R") class that has ever accessed or manipulated this hash.  The copy is a \*(L"shallow\*(R" copy, duplicating only the keys and values.  Reference values are not recursively copied.
.Sp
Setting to hash to undef (using the 'reset' interface) will cause it to be re-copied from a superclass the next time it is accessed.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.ie n .IP """hash_key""" 4
.el .IP "\f(CWhash_key\fR" 4
.IX Item "hash_key"
.PD
The key to use for the storage of this attribute.  Defaults to the name of the method.
.ie n .IP """interface""" 4
.el .IP "\f(CWinterface\fR" 4
.IX Item "interface"
Choose which interface to use.  Defaults to \f(CW\*(C`get_set\*(C'\fR.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.ie n .IP """get_set""" 4
.el .IP "\f(CWget_set\fR" 4
.IX Item "get_set"
.PD
If called with no arguments, returns a list of key/value pairs in list context or a reference to the actual hash used to store values in scalar context.
.Sp
If called with one argument, and that argument is a reference to a hash, that hash reference is used as the new value for the attribute.  Returns a list of key/value pairs in list context or a reference to the actual hash used to store values in scalar context.
.Sp
If called with one argument, and that argument is a reference to an array, then a list of the hash values for each key in the array is returned.
.Sp
If called with one argument, and it is not a reference to a hash or an array, then the hash value for that key is returned.
.Sp
If called with an even number of arguments, they are taken as name/value pairs and are added to the hash.  It then returns a list of key/value pairs in list context or a reference to the actual hash used to store values in scalar context.
.Sp
Passing an odd number of arguments greater than 1 causes a fatal error.
.ie n .IP """get_set_all""" 4
.el .IP "\f(CWget_set_all\fR" 4
.IX Item "get_set_all"
If called with no arguments, returns a list of key/value pairs in list context or a reference to the actual hash used to store values in scalar context.
.Sp
If called with one argument, and that argument is a reference to a hash, that hash reference is used as the new value for the attribute.  Returns a list of key/value pairs in list context or a reference to the actual hash used to store values in scalar context.
.Sp
Otherwise, the hash is emptied and the arguments are taken as name/value pairs that are then added to the hash.  It then returns a list of key/value pairs in list context or a reference to the actual hash used to store values in scalar context.
.ie n .IP """clear""" 4
.el .IP "\f(CWclear\fR" 4
.IX Item "clear"
Sets the attribute to an empty hash.
.ie n .IP """reset""" 4
.el .IP "\f(CWreset\fR" 4
.IX Item "reset"
Sets the attribute to undef.
.ie n .IP """delete""" 4
.el .IP "\f(CWdelete\fR" 4
.IX Item "delete"
Deletes the key(s) passed as arguments.  Failure to pass any arguments causes a fatal error.
.ie n .IP """exists""" 4
.el .IP "\f(CWexists\fR" 4
.IX Item "exists"
Returns true of the argument exists in the hash, false otherwise. Failure to pass an argument or passing more than one argument causes a fatal error.
.ie n .IP """keys""" 4
.el .IP "\f(CWkeys\fR" 4
.IX Item "keys"
Returns the keys of the hash in list context, or a reference to an array of the keys of the hash in scalar context.  The keys are not sorted.
.ie n .IP """names""" 4
.el .IP "\f(CWnames\fR" 4
.IX Item "names"
An alias for the \f(CW\*(C`keys\*(C'\fR interface.
.ie n .IP """values""" 4
.el .IP "\f(CWvalues\fR" 4
.IX Item "values"
Returns the values of the hash in list context, or a reference to an array of the values of the hash in scalar context.  The values are not sorted.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&    package MyClass;
\&
\&    use Rose::Class::MakeMethods::Generic
\&    (
\&      inheritable_hash =>
\&      [
\&        param        => { hash_key =>\*(Aqparams\*(Aq },
\&        params       => { interface=>\*(Aqget_set_all\*(Aq },
\&        param_names  => { interface=>\*(Aqkeys\*(Aq,   hash_key=>\*(Aqparams\*(Aq },
\&        param_values => { interface=>\*(Aqvalues\*(Aq, hash_key=>\*(Aqparams\*(Aq },
\&        param_exists => { interface=>\*(Aqexists\*(Aq, hash_key=>\*(Aqparams\*(Aq },
\&        delete_param => { interface=>\*(Aqdelete\*(Aq, hash_key=>\*(Aqparams\*(Aq },
\&
\&        clear_params => { interface=>\*(Aqclear\*(Aq, hash_key=>\*(Aqparams\*(Aq },
\&        reset_params => { interface=>\*(Aqreset\*(Aq, hash_key=>\*(Aqparams\*(Aq },
\&      ],
\&    );
\&    ...
\&
\&    package MySubClass;
\&    our @ISA = qw(MyClass);
\&    ...
\&
\&    MyClass\->params; # undef
\&
\&    MyClass\->params(a => 1, b => 2); # add pairs
\&    $val = MyClass\->param(\*(Aqb\*(Aq); # 2
\&
\&    %params = MyClass\->params; # copy hash keys and values
\&    $params = MyClass\->params; # get hash ref
\&
\&    # Inherit a copy of params from MyClass
\&    $params = MySubClass\->params; # { a => 1, b => 2 }
\&
\&    MyClass\->params({ c => 3, d => 4 }); # replace contents
\&
\&    # MySubClass params are still as the existed at the time
\&    # they were originally copied from MyClass
\&    $params = MySubClass\->params; # { a => 1, b => 2 }
\&
\&    # MySubClass can manipulate its own params as it wishes
\&    MySubClass\->param(z => 9);
\&
\&    $params = MySubClass\->params; # { a => 1, b => 2, z => 9 }
\&
\&    MyClass\->param_exists(\*(Aqa\*(Aq); # false
\&
\&    $keys = join(\*(Aq,\*(Aq, sort MyClass\->param_names);  # \*(Aqc,d\*(Aq
\&    $vals = join(\*(Aq,\*(Aq, sort MyClass\->param_values); # \*(Aq3,4\*(Aq
\&
\&    # Reset params (set to undef) so that they will be re\-copied
\&    # from MyClass the next time they\*(Aqre accessed
\&    MySubClass\->reset_params;
\&
\&    MyClass\->delete_param(\*(Aqc\*(Aq);
\&    MyClass\->param(f => 7, g => 8);
\&
\&    $vals = join(\*(Aq,\*(Aq, sort MyClass\->param_values); # \*(Aq4,7,8\*(Aq
\&
\&    # Inherit a copy of params from MyClass
\&    $params = MySubClass\->params; # { d => 4, f => 7, g => 8 }
.Ve
.RE
.IP "\fBinherited_hash\fR" 4
.IX Item "inherited_hash"
Create a family of class methods for managing an inherited hash.
.Sp
An inherited hash is made up of the union of the hashes of all superclasses, minus any keys that are explicitly deleted in the current class.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.ie n .IP """add_implies""" 4
.el .IP "\f(CWadd_implies\fR" 4
.IX Item "add_implies"
.PD
A method name, or reference to a list of method names, to call when a key is added to the hash.  Each added name/value pair is passed to each method in the \f(CW\*(C`add_implies\*(C'\fR list, one pair at a time.
.ie n .IP """add_method""" 4
.el .IP "\f(CWadd_method\fR" 4
.IX Item "add_method"
The name of the class method used to add a single name/value pair to the hash. Defaults to the method name with the prefix \f(CW\*(C`add_\*(C'\fR added.
.ie n .IP """adds_method""" 4
.el .IP "\f(CWadds_method\fR" 4
.IX Item "adds_method"
The name of the class method used to add one or more name/value pairs to the hash.  Defaults to \f(CW\*(C`plural_name\*(C'\fR with the prefix \f(CW\*(C`add_\*(C'\fR added.
.ie n .IP """cache_method""" 4
.el .IP "\f(CWcache_method\fR" 4
.IX Item "cache_method"
The name of the class method used to retrieve (or generate, if it doesn't exist) the internal cache for the hash.  This should be considered a private method, but it is listed here because it does take up a spot in the method namespace.  Defaults to \f(CW\*(C`plural_name\*(C'\fR with \f(CW\*(C`_cache\*(C'\fR added to the end.
.ie n .IP """clear_method""" 4
.el .IP "\f(CWclear_method\fR" 4
.IX Item "clear_method"
The name of the class method used to clear the contents of the hash.  Defaults to \f(CW\*(C`plural_name\*(C'\fR with a \f(CW\*(C`clear_\*(C'\fR prefix added.
.ie n .IP """delete_implies""" 4
.el .IP "\f(CWdelete_implies\fR" 4
.IX Item "delete_implies"
A method name, or reference to a list of method names, to call when a key is removed from the hash.  Each deleted key is passed as an argument to each method in the \f(CW\*(C`delete_implies\*(C'\fR list, one key per call.
.ie n .IP """delete_method""" 4
.el .IP "\f(CWdelete_method\fR" 4
.IX Item "delete_method"
The name of the class method used to remove a single key from the hash.  Defaults to the method name with the prefix \f(CW\*(C`delete_\*(C'\fR added.
.ie n .IP """deletes_method""" 4
.el .IP "\f(CWdeletes_method\fR" 4
.IX Item "deletes_method"
The name of the class method used to remove one or more keys from the hash.  Defaults to \f(CW\*(C`plural_name\*(C'\fR with a \f(CW\*(C`delete_\*(C'\fR prefix added.
.ie n .IP """exists_method""" 4
.el .IP "\f(CWexists_method\fR" 4
.IX Item "exists_method"
The name of the class method that tests for the existence of a key in the hash.  Defaults to the method name with the suffix \f(CW\*(C`_exists\*(C'\fR added.
.ie n .IP """get_set_all_method""" 4
.el .IP "\f(CWget_set_all_method\fR" 4
.IX Item "get_set_all_method"
The name of the class method use to set or fetch the entire hash.  The hash may be passed as a reference to a hash or as a list of name/value pairs.  Returns the hash (in list context) or a reference to a hash (in scalar context).  Defaults to \f(CW\*(C`plural_name\*(C'\fR.
.ie n .IP """hash_method""" 4
.el .IP "\f(CWhash_method\fR" 4
.IX Item "hash_method"
This is an alias for the \f(CW\*(C`get_set_all_method\*(C'\fR parameter.
.ie n .IP """inherit_method""" 4
.el .IP "\f(CWinherit_method\fR" 4
.IX Item "inherit_method"
The name of the class method used to indicate that an inherited key that was previously deleted from the hash should return to being inherited.  Defaults to the method name with the prefix \f(CW\*(C`inherit_\*(C'\fR added.
.ie n .IP """inherits_method""" 4
.el .IP "\f(CWinherits_method\fR" 4
.IX Item "inherits_method"
The name of the class method used to indicate that one or more inherited keys that were previously deleted from the hash should return to being inherited.  Defaults to the \f(CW\*(C`plural_name\*(C'\fR with the prefix \f(CW\*(C`inherit_\*(C'\fR added.
.ie n .IP """interface""" 4
.el .IP "\f(CWinterface\fR" 4
.IX Item "interface"
Choose the interface.  This is kind of pointless since there is only one interface right now.  Defaults to \f(CW\*(C`all\*(C'\fR, obviously.
.ie n .IP """keys_method""" 4
.el .IP "\f(CWkeys_method\fR" 4
.IX Item "keys_method"
The name of the class method that returns a reference to a list of keys in scalar context, or a list of keys in list context.   Defaults to to \f(CW\*(C`plural_name\*(C'\fR with \*(L"_keys\*(R" added to the end.
.ie n .IP """plural_name""" 4
.el .IP "\f(CWplural_name\fR" 4
.IX Item "plural_name"
The plural version of the method name, used to construct the default names for some other methods.  Defaults to the method name with \f(CW\*(C`s\*(C'\fR added.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
.PD
Creates the entire family of methods described above.  The example
below illustrates their use.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&    package MyClass;
\&
\&    use Rose::Class::MakeMethods::Generic
\&    (
\&      inherited_hash =>
\&      [
\&        pet_color =>
\&        {
\&          keys_method     => \*(Aqpets\*(Aq,
\&          delete_implies  => \*(Aqdelete_special_pet_color\*(Aq,
\&          inherit_implies => \*(Aqinherit_special_pet_color\*(Aq,
\&        },
\&
\&        special_pet_color =>
\&        {
\&          keys_method     => \*(Aqspecial_pets\*(Aq,
\&          add_implies => \*(Aqadd_pet_color\*(Aq,
\&        },
\&      ],
\&    );
\&    ...
\&
\&    package MySubClass;
\&    our @ISA = qw(MyClass);
\&    ...
\&
\&
\&    MyClass\->pet_colors(Fido => \*(Aqwhite\*(Aq,
\&                        Max  => \*(Aqblack\*(Aq,
\&                        Spot => \*(Aqyellow\*(Aq);
\&
\&    MyClass\->special_pet_color(Toby => \*(Aqtan\*(Aq);
\&
\&    MyClass\->pets;              # Fido, Max, Spot, Toby
\&    MyClass\->special_pets;      # Toby
\&
\&    MySubClass\->pets;           # Fido, Max, Spot, Toby
\&    MyClass\->pet_color(\*(AqToby\*(Aq); # tan
\&
\&    MySubClass\->special_pet_color(Toby => \*(Aqgold\*(Aq);
\&
\&    MyClass\->pet_color(\*(AqToby\*(Aq);         # tan
\&    MyClass\->special_pet_color(\*(AqToby\*(Aq); # tan
\&
\&    MySubClass\->pet_color(\*(AqToby\*(Aq);         # gold
\&    MySubClass\->special_pet_color(\*(AqToby\*(Aq); # gold
\&
\&    MySubClass\->inherit_pet_color(\*(AqToby\*(Aq);
\&
\&    MySubClass\->pet_color(\*(AqToby\*(Aq);         # tan
\&    MySubClass\->special_pet_color(\*(AqToby\*(Aq); # tan
\&
\&    MyClass\->delete_pet_color(\*(AqMax\*(Aq);
\&
\&    MyClass\->pets;    # Fido, Spot, Toby
\&    MySubClass\->pets; # Fido, Spot, Toby
\&
\&    MyClass\->special_pet_color(Max => \*(Aqmauve\*(Aq);
\&
\&    MyClass\->pets;    # Fido, Max, Spot, Toby
\&    MySubClass\->pets; # Fido, Max, Spot, Toby
\&
\&    MyClass\->special_pets;    # Max, Toby
\&    MySubClass\->special_pets; # Max, Toby
\&
\&    MySubClass\->delete_special_pet_color(\*(AqMax\*(Aq);
\&
\&    MyClass\->pets;    # Fido, Max, Spot, Toby
\&    MySubClass\->pets; # Fido, Max, Spot, Toby
\&
\&    MyClass\->special_pets;    # Max, Toby
\&    MySubClass\->special_pets; # Toby
.Ve
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
John C. Siracusa (siracusa@gmail.com)
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2010 by John C. Siracusa.  All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same terms
as Perl itself.
