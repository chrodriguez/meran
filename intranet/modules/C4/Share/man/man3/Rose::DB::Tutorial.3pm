.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Rose::DB::Tutorial 3"
.TH Rose::DB::Tutorial 3 "2009-12-31" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Rose::DB::Tutorial \- Best practices for using Rose::DB
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
This tutorial describes \*(L"best practices\*(R" for using Rose::DB in the most robust, maintainable manner.  It does not replace the actual documentation, however.  The actual Rose::DB documentation is still essential, and contains some good examples of its own.
.PP
In particular, you should read the description section of the Rose::DB documentation if you have not done so already.  It describes the features and philosophy of Rose::DB.  That information that will not be repeated here.
.SH "CONVENTIONS"
.IX Header "CONVENTIONS"
The examples in this tutorial will use the fictional \f(CW\*(C`My::\*(C'\fR namespace prefix.  Your code should use whatever namespace you deem appropriate.  Usually, it will be more akin to \f(CW\*(C`MyCorp::MyProject::\*(C'\fR (i.e., your corporation, organization, and/or project).  I've chosen to use \f(CW\*(C`My::\*(C'\fR simply because it's shorter, and will help this tutorial stay within an 80\-column width.
.PP
For the sake of brevity, the \f(CW\*(C`use strict\*(C'\fR directive and associated \*(L"my\*(R" declarations have been omitted from the example code.  Needless to say, you should always \f(CW\*(C`use strict\*(C'\fR in your actual code.
.PP
Similarly, the traditional \*(L"1;\*(R" true value used at the end of each \*(L".pm\*(R" file has been omitted from the examples.  Don't forget to add this to the end of your actual Perl module files.
.SH "TUTORIAL"
.IX Header "TUTORIAL"
.SS "Creating a subclass"
.IX Subsection "Creating a subclass"
The first step when using Rose::DB in anything but a throw-away script is to create a trivial subclass.  This is important because Rose::DB has a significant amount of class data.  Using Rose::DB directly means that you will be reading and writing the same data as any other badly-behaved code that also uses Rose::DB directly.
.PP
In particular, the registry that contains all the information for each data source is class data, and is inherited from (that is, shared with) the base class by default.  Creating a subclass allows you to have your own, private data source registry.
.PP
So, here's our initial Rose::DB subclass.
.PP
.Vb 2
\&  # File: My/DB.pm
\&  package My::DB;
\&
\&  use Rose::DB;
\&  our @ISA = qw(Rose::DB);
\&
\&  # Use a private registry for this class
\&  _\|_PACKAGE_\|_\->use_private_registry;
.Ve
.SS "Designing your namespace"
.IX Subsection "Designing your namespace"
As described in the Rose::DB documentation, Rose::DB provides a two-level namespace for data sources, made up of a \*(L"domain\*(R" and a \*(L"type.\*(R"  These are both arbitrary strings, so there's a lot of freedom to break up the namespace in any way you see fit.  For example, sub-domains and sub-types can be created within each string using delimiter characters (e.g., \*(L"::\*(R" as in Perl's package namespace).
.PP
But let's back up.  The simplest case is that you have just one data source, and therefore no need for a namespace at all.  If this is the case, you can skip to the next section.
.PP
In the common case, it's usually sufficient to use simple words for both type and domain.  As the name \*(L"domain\*(R" implies, this value usually represents the environment or surroundings.  For example, a typical server application might use domains named \*(L"development\*(R", \*(L"qa\*(R", \*(L"staging\*(R", and \*(L"production\*(R".
.PP
The \*(L"type\*(R" portion of the namespace tends to be used to differentiate the applicability or contents of the data sources.  Some example type names are \*(L"main\*(R" for the primary database, \*(L"archive\*(R" for a data warehouse database, and \*(L"session\*(R" for a database used to store transient session data.
.PP
The goal of namespace design is to allow data sources to be referred to symbolically, with names that make sense to you in your environment.
.SS "Registering data sources"
.IX Subsection "Registering data sources"
Now that you've decided on your namespace design (or lack thereof, if you have only one data source), it's time to register some data sources.  To register a data source, call the register_db class method.
.PP
This can be done nearly anywhere, but it's most convenient to do it \*(L"early\*(R" and to link it somehow to your \f(CW\*(C`My::DB\*(C'\fR subclass.  That is, when someone \f(CW\*(C`use\*(C'\fRs \f(CW\*(C`My::DB\*(C'\fR, they should not have to worry about whether or not all the data sources are registered.
.PP
In a server environment, there's usually some sort of start-up file that gets loaded before any \*(L"end-user\*(R" code (e.g., \*(L"startup.pl\*(R" by convention in a mod_perl Apache web server).  That may be a good place to include your data source registration calls, but only if you're absolutely sure that \f(CW\*(C`My::DB\*(C'\fR will never be used outside the server environment.
.PP
A better, safer alternative is to put the data source registration calls directly in your Rose::DB subclass.  This is the recommended approach.  Here are some examples.
.PP
\fIJust one data source\fR
.IX Subsection "Just one data source"
.PP
First, consider the case where a namespace is not necessary.  You have a single data source and that's all.  You don't care what it's named.  Luckily, there are default values for both type and domain.  Simply register your data source using these values and you're all set.
.PP
.Vb 1
\&    package My::DB;
\&
\&    use Rose::DB;
\&    our @ISA = qw(Rose::DB);
\&
\&    # Use a private registry for this class
\&    _\|_PACKAGE_\|_\->use_private_registry;
\&
\&    # Register your lone data source using the default type and domain
\&    _\|_PACKAGE_\|_\->register_db(
\&      domain   => My::DB\->default_domain,
\&      type     => My::DB\->default_type,
\&      driver   => \*(Aqpg\*(Aq,
\&      database => \*(Aqmy_db\*(Aq,
\&      host     => \*(Aqlocalhost\*(Aq,
\&      username => \*(Aqjoeuser\*(Aq,
\&      password => \*(Aqmysecret\*(Aq,
\&    );
.Ve
.PP
The domain and type parameters can actually be omitted entirely and they will still default to the values shown above.  In other words, the following call to register_db is exactly equivalent to the one above.
.PP
.Vb 8
\&    # Register your lone data source using the default type and domain
\&    _\|_PACKAGE_\|_\->register_db(
\&      driver   => \*(Aqpg\*(Aq,
\&      database => \*(Aqmy_db\*(Aq,
\&      host     => \*(Aqlocalhost\*(Aq,
\&      username => \*(Aqjoeuser\*(Aq,
\&      password => \*(Aqmysecret\*(Aq,
\&    );
.Ve
.PP
To use \f(CW\*(C`My::DB\*(C'\fR in this kind of setup, simply omit the domain and type parameters from your calls to \f(CW\*(C`My::DB\->new\*(C'\fR.  They will automatically get the default values.
.PP
.Vb 1
\&    use My::DB;
\&
\&    $db = My::DB\->new(); # use default type and default domain
\&    print $db\->username; # "joeuser"
\&    $dbh = $db\->dbh;     # connect and get DBI database handle
.Ve
.PP
\fIMultiple data sources\fR
.IX Subsection "Multiple data sources"
.PP
Most commonly, you will have more than one data source.  (And if you don't now, you probably will in the future.  Better safe than sorry.)  After you've designed your namespace, data source registration is straightforward.  The only wrinkle is how to deal with the default domain and type.
.PP
I recommend setting the default domain and type to the \*(L"safest\*(R" values in your environment.  For example, a domain of \*(L"development\*(R" and a type of \*(L"main\*(R" are reasonable choices.  This allows you to use \*(L"bare\*(R" calls to \f(CW\*(C`My::DB\->new()\*(C'\fR in your code (as shown in the simple, single data source example above).
.PP
Here's an example that includes two domains \*(L"development\*(R" and \*(L"production\*(R", and two types, \*(L"main\*(R" and \*(L"session.\*(R"  The default data source is the domain \*(L"development\*(R" and the type \*(L"main\*(R".
.PP
.Vb 1
\&    package My::DB;
\&
\&    use Rose::DB;
\&    our @ISA = qw(Rose::DB);
\&
\&    # Use a private registry for this class
\&    _\|_PACKAGE_\|_\->use_private_registry;
\&
\&    # Set the default domain and type
\&    _\|_PACKAGE_\|_\->default_domain(\*(Aqdevelopment\*(Aq);
\&    _\|_PACKAGE_\|_\->default_type(\*(Aqmain\*(Aq);
\&
\&    # Register the data sources
\&
\&    # Development:
\&
\&    _\|_PACKAGE_\|_\->register_db(
\&      domain   => \*(Aqdevelopment\*(Aq,
\&      type     => \*(Aqmain\*(Aq,
\&      driver   => \*(Aqpg\*(Aq,
\&      database => \*(Aqdev_db\*(Aq,
\&      host     => \*(Aqlocalhost\*(Aq,
\&      username => \*(Aqdevuser\*(Aq,
\&      password => \*(Aqmysecret\*(Aq,
\&    );
\&
\&    _\|_PACKAGE_\|_\->register_db(
\&      domain   => \*(Aqdevelopment\*(Aq,
\&      type     => \*(Aqsession\*(Aq,
\&      driver   => \*(Aqmysql\*(Aq,
\&      database => \*(Aqsession_db\*(Aq,
\&      host     => \*(Aqlocalhost\*(Aq,
\&      username => \*(Aqdevmysql\*(Aq,
\&      password => \*(Aqmysqlpw\*(Aq,
\&    );
\&
\&    # Production:
\&
\&    _\|_PACKAGE_\|_\->register_db(
\&      domain   => \*(Aqproduction\*(Aq,
\&      type     => \*(Aqmain\*(Aq,
\&      driver   => \*(Aqpg\*(Aq,
\&      database => \*(Aqbig_db\*(Aq,
\&      host     => \*(Aqdbserver.mycorp.com\*(Aq,
\&      username => \*(Aqdbadmin\*(Aq,
\&      password => \*(Aqprodsecret\*(Aq,
\&    );
\&
\&    _\|_PACKAGE_\|_\->register_db(
\&      domain   => \*(Aqproduction\*(Aq,
\&      type     => \*(Aqsession\*(Aq,
\&      driver   => \*(Aqmysql\*(Aq,
\&      database => \*(Aqsession_db\*(Aq,
\&      host     => \*(Aqsessions.mycorp.com\*(Aq,
\&      username => \*(Aqsession_user\*(Aq,
\&      password => \*(Aqprodsesspw\*(Aq,
\&    );
.Ve
.PP
Ideally, and as shown in the example above, all data source types are available in each domain.  Combined with the consistent practice of never specifying an explicit domain when constructing your \f(CW\*(C`My::DB\*(C'\fR objects, this allows the domain to be switched as needed, without modifying any code in the actual application.
.PP
For example, imagine a mod_perl Apache web server environment running application code that constructs its \f(CW\*(C`My::DB\*(C'\fR objects like this:
.PP
.Vb 2
\&    $main_db    = My::DB\->new(\*(Aqmain\*(Aq);    
\&    $session_db = My::DB\->new(\*(Aqsession\*(Aq);
.Ve
.PP
Now imagine a \*(L"startup.pl\*(R" file that contains the following:
.PP
.Vb 2
\&    # File: startup.pl
\&    use My::DB;
\&
\&    if($ENV{\*(AqMYCORP_PRODUCTION_SERVER\*(Aq})
\&    {
\&      My::DB\->default_domain(\*(Aqproduction\*(Aq);
\&    }
\&    else
\&    {
\&      My::DB\->default_domain(\*(Aqdevelopment\*(Aq);
\&    }
.Ve
.PP
This deliberate use of defaults combined with a healthy dose of convention in your constructor calls can make it simple to move your code from one environment to another without any changes beyond the usual configuration management that must be done (e.g., for apache configuration files).
.PP
The determination of the current environment can be done in many different ways, of course.  Checking an environment variable as shown above is probably not the best way to do it, but it makes for a simple example.
.PP
Another alternative is to use some sort of configuration/build management system to generate the Apache configuration files from templates.  In that case, the templates could contain something like this:
.PP
.Vb 5
\&    [% IF in_production %]
\&        My::DB\->default_domain(\*(Aqproduction\*(Aq);
\&    [% ELSE %]
\&        My::DB\->default_domain(\*(Aqdevelopment\*(Aq);
\&    [% END %]
.Ve
.PP
This would leave only the single, appropriate call in the completed \*(L"startup.pl\*(R" file.
.SS "Using your database objects"
.IX Subsection "Using your database objects"
Before trying to use Rose::DB objects, it's important to understand the primary goals of Rose::DB.  The features are described in the Rose::DB documentation, but there is one thing that is left unsaid.  Although Rose::DB is useful in isolation and provides many convenient methods and abstractions, its primary purpose is to encapsulate database-specific behaviors on behalf of Rose::DB::Object.
.PP
Of course, it could fill the same role for any Rose::DB::Object\-like module, and for any code that does the same kinds of things.  If you need to parse or format vendor-specific column values or want to use a simple form of reference counting to keep track of shared database handles, you may find Rose::DB useful.
.PP
The most common non\-Rose::DB::Object\-related use for Rose::DB is as a way to get a \s-1DBI\s0 database handle without sweating the details of how it's created or where it's connected.  The previous sections of this tutorial cover everything you need to know to set up Rose::DB to be used in this capacity.  Please be sure to read the Rose::DB documentation as well, particularly the database handle life-cycle management section.
.SH "DEVELOPMENT POLICY"
.IX Header "DEVELOPMENT POLICY"
The Rose development policy applies to this, and all \f(CW\*(C`Rose::*\*(C'\fR modules.  Please install Rose from \s-1CPAN\s0 and then run \f(CW\*(C`perldoc Rose\*(C'\fR for more information.
.SH "SUPPORT"
.IX Header "SUPPORT"
Any Rose::DB questions or problems can be posted to the Rose::DB::Object mailing list.  (If the volume ever gets high enough, I'll create a separate list for Rose::DB.  But it isn't an issue right now.)  To subscribe to the list or view the archives, go here:
.PP
<http://groups.google.com/group/rose\-db\-object>
.PP
Although the mailing list is the preferred support mechanism, you can also email the author (see below) or file bugs using the \s-1CPAN\s0 bug tracking system:
.PP
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Rose\-DB>
.PP
There's also a wiki and other resources linked from the Rose project home page:
.PP
<http://rose.googlecode.com>
.SH "AUTHOR"
.IX Header "AUTHOR"
John C. Siracusa (siracusa@gmail.com)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2007 by John C. Siracusa.  All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same terms
as Perl itself.
