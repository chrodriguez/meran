.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Rose::Object::MakeMethods 3"
.TH Rose::Object::MakeMethods 3 "2010-10-17" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Rose::Object::MakeMethods \- A simple method maker base class.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MyMethodMaker;
\&
\&  use Rose::Object::MakeMethods;
\&  our @ISA = qw(Rose::Object::MakeMethods);
\&
\&  sub widget
\&  {
\&    my($class, $name, $args) = @_;
\&
\&    my $key = $args\->{\*(Aqhash_key\*(Aq} || $name;
\&    my $interface = $args\->{\*(Aqinterface\*(Aq} || \*(Aqget_set\*(Aq;
\&
\&    my %methods;
\&
\&    if($interface =~ /^get_set/)
\&    {
\&      $methods{$name} = sub
\&      {
\&        my($self) = shift;
\&        if(@_) { ... }
\&        ...
\&        return $self\->{$key};
\&      };
\&    }
\&
\&    if($interface eq \*(Aqget_set_delete\*(Aq)
\&    {
\&      $methods{"delete_$name"} = sub { ... };
\&    )
\&
\&    return \e%methods;
\&  }
\&  ...
\&
\&  package MyObject;
\&
\&  sub new { ... }
\&
\&  use MyMethodMaker
\&  (
\&    \*(Aqwidget \-\-get_set_delete\*(Aq => \*(Aqfoo\*(Aq,
\&
\&    \*(Aqwidget\*(Aq => 
\&    [
\&      \*(Aqbar\*(Aq,
\&      \*(Aqbaz\*(Aq,
\&    ]
\&  );
\&  ...
\&
\&  $o = MyObject\->new;
\&
\&  $o\->foo($bar);
\&  $o\->delete_foo();
\&
\&  print $o\->bar . $o\->baz;
\&  ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Rose::Object::MakeMethods is the base class for a family of method makers. A method maker is a module that's used to define methods in other packages. The actual method makers are subclasses of Rose::Object::MakeMethods that define the names and options of the different kinds of methods that they can make.
.PP
There are method makers that make both object methods and class methods. The object method makers are in the \f(CW\*(C`Rose::Object::MakeMethods::*\*(C'\fR namespace. The class method makers are in the \f(CW\*(C`Rose::Class::MakeMethods::*\*(C'\fR namespace for the sake of clarity, but still inherit from Class::MethodMaker and therefore share the same method making interface.
.PP
Several useful method makers are included under the \f(CW\*(C`Rose::Object::MakeMethods::*\*(C'\fR and \f(CW\*(C`Rose::Class::MakeMethods::*\*(C'\fR namespaces, mostly for use by other \f(CW\*(C`Rose::*\*(C'\fR objects and classes.
.PP
This family of modules is not as powerful or flexible as the one that inspired it: Class::MethodMaker.  I found that I was only using a tiny corner of the functionality provided by Class::MethodMaker, so I wrote this as a simple, smaller replacement.
.PP
The fact that many \f(CW\*(C`Rose::*\*(C'\fR modules use Rose::Object::MakeMethods subclasses to make their methods should be considered an implementation detail that can change at any time.
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.IP "\fBallow_apparent_reload [\s-1BOOL\s0]\fR" 4
.IX Item "allow_apparent_reload [BOOL]"
Get or set an attribute that determines whether or not to allow an attempt to re-make the same method using the same class that made it earlier.  The default is true.
.Sp
This issue comes up when a module is forcibly reloaded, e.g., by Apache::Reload or Apache::StatINC.  When this happens, all the \*(L"make methods\*(R" actions will be attempted again.  In the absence of the \f(CW\*(C`preserve_existing\*(C'\fR or \f(CW\*(C`override_existing\*(C'\fR options, the allow_apparent_reload attribute will be consulted.  If it's true, and if it appears that the method in question was made by this method-maker class, then it behaves as if the \f(CW\*(C`preserve_existing\*(C'\fR option had been passed.  If it is false, then a fatal \*(L"method redefined\*(R" error will occur.
.IP "\fBimport \s-1SPEC\s0\fR" 4
.IX Item "import SPEC"
The \f(CW\*(C`import\*(C'\fR class method is mean to be called implicitly as a result of a \f(CW\*(C`use\*(C'\fR statement.  For example:
.Sp
.Vb 4
\&    use Rose::Object::MakeMethods::Generic
\&    (
\&      SPEC
\&    );
.Ve
.Sp
is roughly equivalent to:
.Sp
.Vb 2
\&    require Rose::Object::MakeMethods::Generic;
\&    Rose::Object::MakeMethods::Generic\->import(SPEC);
.Ve
.Sp
where \s-1SPEC\s0 is a series of specifications for the methods to be created. (But don't call import explicitly; use make_methods instead.)
.Sp
In response to each method specification, one or more methods are created.
.Sp
The first part of the \s-1SPEC\s0 argument is an optional hash reference whose contents are intended to modify the behavior of the method maker class itself, rather than the individual methods being made.  There are currently only two valid arguments for this hash:
.RS 4
.IP "\fBtarget_class \s-1CLASS\s0\fR" 4
.IX Item "target_class CLASS"
Specifies that class that the methods will be added to.  Defaults to the class from which the call was made.  For example, this:
.Sp
.Vb 5
\&    use Rose::Object::MakeMethods::Generic
\&    (
\&      { target_class => \*(AqFoo\*(Aq },
\&      ...
\&    );
.Ve
.Sp
Is equivalent to this:
.Sp
.Vb 1
\&    package Foo;
\&
\&    use Rose::Object::MakeMethods::Generic
\&    (
\&      ...
\&    );
.Ve
.Sp
In general, the \f(CW\*(C`target_class\*(C'\fR argument is omitted since methods are usually indented to end up in the class of the caller.
.IP "\fBoverride_existing \s-1BOOL\s0\fR" 4
.IX Item "override_existing BOOL"
By default, attempting to create a method that already exists will result in a fatal error.  But if the \f(CW\*(C`override_existing\*(C'\fR option is set to a true value, the existing method will be replaced with the generated method.
.IP "\fBpreserve_existing \s-1BOOL\s0\fR" 4
.IX Item "preserve_existing BOOL"
By default, attempting to create a method that already exists will result in a fatal error.  But if the \f(CW\*(C`preserve_existing\*(C'\fR option is set to a true value, the existing method will be left unmodified.  This option takes precedence over the \f(CW\*(C`override_existing\*(C'\fR option.
.RE
.RS 4
.Sp
After the optional hash reference full off options intended for the method maker class itself, a series of method specifications should be provided.  Each method specification defines one or more named methods. The components of such a specification are:
.IP "\(bu" 4
The Method Type
.Sp
This is the name of the subroutine that will be called in order to generated the methods (see \s-1SUBCLASSING\s0 for more information).  It describes the nature of the generated method.  For example, \*(L"scalar\*(R", \*(L"array\*(R", \*(L"bitfield\*(R", \*(L"object\*(R"
.IP "\(bu" 4
Method Type Arguments
.Sp
Name/value pairs that are passed to the method maker of the specified type in order to modify its behavior.
.IP "\(bu" 4
Method Names
.Sp
One or more names for the methods that are to be created.  Note that a method maker of a particular type may choose to modify or ignore these names.  In the common case, for each method name argument, a single method is created with the same name as the method name argument.
.RE
.RS 4
.Sp
Given the method type \f(CW\*(C`bitfield\*(C'\fR and the method arguments \f(CW\*(C`opt1\*(C'\fR and \f(CW\*(C`opt2\*(C'\fR, the following examples show all valid forms for method specifications, with equivalent forms grouped together.
.Sp
Create a bitfield method named \f(CW\*(C`my_bits\*(C'\fR:
.Sp
.Vb 1
\&   bitfield => \*(Aqmy_bits\*(Aq
\&
\&   bitfield => [ \*(Aqmy_bits\*(Aq ],
\&
\&   bitfield => [ \*(Aqmy_bits\*(Aq => {} ],
.Ve
.Sp
Create a bitfield method named \f(CW\*(C`my_bits\*(C'\fR, passing the \f(CW\*(C`opt1\*(C'\fR argument with a value of 2.
.Sp
.Vb 1
\&   \*(Aqbitfield \-\-opt1=2\*(Aq => \*(Aqmy_bits\*(Aq
\&
\&   \*(Aqbitfield \-\-opt1=2\*(Aq => [ \*(Aqmy_bits\*(Aq ]
\&
\&   bitfield => [ \*(Aqmy_bits\*(Aq => { opt1 => 2 } ]
.Ve
.Sp
Create a bitfield method named \f(CW\*(C`my_bits\*(C'\fR, passing the \f(CW\*(C`opt1\*(C'\fR argument with a value of 2 and the \f(CW\*(C`opt2\*(C'\fR argument with a value of 7.
.Sp
.Vb 1
\&   \*(Aqbitfield \-\-opt1=2 \-\-opt2=7\*(Aq => \*(Aqmy_bits\*(Aq
\&
\&   \*(Aqbitfield \-\-opt1=2 \-\-opt2=7\*(Aq => [ \*(Aqmy_bits\*(Aq ]
\&
\&   bitfield => [ \*(Aqmy_bits\*(Aq => { opt1 => 2, opt2 => 7 } ]
\&
\&   \*(Aqbitfield \-\-opt2=7\*(Aq => [ \*(Aqmy_bits\*(Aq => { opt1 => 2 } ]
.Ve
.Sp
In the case of a conflict between the options specified with the \f(CW\*(C`\-\-name=value\*(C'\fR syntax and those provided in the hash reference, the ones in the hash reference take precedence.  For example, these are equivalent:
.Sp
.Vb 1
\&   \*(Aqbitfield \-\-opt1=99\*(Aq => \*(Aqmy_bits\*(Aq
\&
\&   \*(Aqbitfield \-\-opt1=5\*(Aq => [ \*(Aqmy_bits\*(Aq => { opt1 => 99 } ]
.Ve
.Sp
If no value is provided for the first option, and if it is specified using the \f(CW\*(C`\-\-name\*(C'\fR syntax, then it is taken as the \fIvalue\fR of the \f(CW\*(C`interface\*(C'\fR option.  That is, this:
.Sp
.Vb 1
\&    \*(Aqbitfield \-\-foobar\*(Aq => \*(Aqmy_bits\*(Aq
.Ve
.Sp
is equivalent to these:
.Sp
.Vb 1
\&    \*(Aqbitfield \-\-interface=foobar\*(Aq => \*(Aqmy_bits\*(Aq
\&
\&    bitfield => [ my_bits => { interface => \*(Aqfoobar\*(Aq } ]
.Ve
.Sp
This shortcut supports the convention that the \f(CW\*(C`interface\*(C'\fR option is used to decide which set of methods to create.  But it's just a convention; the \f(CW\*(C`interface\*(C'\fR option is no different from any of the other options when it is eventually passed to the method maker of a given type.
.Sp
Any option other than the very first that is specified using the \f(CW\*(C`\-\-name\*(C'\fR form and that lacks an explicit value is simply set to 1. That is, this:
.Sp
.Vb 1
\&    \*(Aqbitfield \-\-foobar \-\-baz\*(Aq => \*(Aqmy_bits\*(Aq
.Ve
.Sp
is equivalent to these:
.Sp
.Vb 1
\&    \*(Aqbitfield \-\-interface=foobar \-\-baz=1\*(Aq => \*(Aqmy_bits\*(Aq
\&
\&    bitfield => 
\&    [
\&      my_bits => { interface => \*(Aqfoobar\*(Aq, baz => 1 }
\&    ]
.Ve
.Sp
Multiple method names can be specified simultaneously for a given method type and set of options.  For example, to create methods named \f(CW\*(C`my_bits[1\-3]\*(C'\fR, all of the same type and with the same options, any of these would work:
.Sp
.Vb 6
\&     \*(Aqbitfield \-\-opt1=2\*(Aq => 
\&     [
\&       \*(Aqmy_bits1\*(Aq,
\&       \*(Aqmy_bits2\*(Aq,
\&       \*(Aqmy_bits3\*(Aq,
\&     ]
\&
\&     bitfield => 
\&     [
\&       \*(Aqmy_bits1\*(Aq => { opt1 => 2 },
\&       \*(Aqmy_bits2\*(Aq => { opt1 => 2 },
\&       \*(Aqmy_bits3\*(Aq => { opt1 => 2 },
\&     ]
.Ve
.Sp
When options are provided using the \f(CW\*(C`\-\-name=value\*(C'\fR format, they apply to all methods listed inside the array reference, unless overridden. Here's an example of an override:
.Sp
.Vb 6
\&     \*(Aqbitfield \-\-opt1=2\*(Aq => 
\&     [
\&       \*(Aqmy_bits1\*(Aq,
\&       \*(Aqmy_bits2\*(Aq,
\&       \*(Aqmy_bits3\*(Aq => { opt1 => 999 },
\&     ]
.Ve
.Sp
In this case, \f(CW\*(C`my_bits1\*(C'\fR and \f(CW\*(C`my_bits2\*(C'\fR use \f(CW\*(C`opt1\*(C'\fR values of 2, but \f(CW\*(C`my_bits3\*(C'\fR uses an \f(CW\*(C`opt1\*(C'\fR value of 999.  Also note that it's okay to mix bare method names (\f(CW\*(C`my_bits1\*(C'\fR and \f(CW\*(C`my_bits2\*(C'\fR) with method names that have associated hash reference options (\f(CW\*(C`my_bits3\*(C'\fR), all inside the same array reference.
.Sp
Finally, putting it all together, here's a full example using several different formats.
.Sp
.Vb 3
\&    use Rose::Object::MakeMethods::Generic
\&    (
\&      { override_existing => 1 },
\&
\&      \*(Aqbitfield\*(Aq => [ qw(my_bits other_bits) ],
\&
\&      \*(Aqbitfield \-\-opt1=5\*(Aq => 
\&      [
\&        \*(Aqa\*(Aq,
\&        \*(Aqb\*(Aq,
\&      ],
\&
\&      \*(Aqbitfield\*(Aq =>
\&      [
\&        \*(Aqc\*(Aq,
\&        \*(Aqd\*(Aq => { opt2 => 7 },
\&        \*(Aqe\*(Aq => { opt1 => 1 },
\&        \*(Aqf\*(Aq => { }, # empty is okay too
\&      ]
\&    );
.Ve
.Sp
In the documentation for the various Rose::Object::MakeMethods subclasses, any of the valid forms may be used in the examples.
.RE
.IP "\fBmake_methods \s-1SPEC\s0\fR" 4
.IX Item "make_methods SPEC"
This method is equivalent to the \f(CW\*(C`import\*(C'\fR method, but makes the intent of the code clearer when it is called explicitly.  (The \f(CW\*(C`import\*(C'\fR method is only meant to be called implicitly by \f(CW\*(C`use\*(C'\fR.)
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
In order to make a Rose::Object::MakeMethods subclass that can actually make some methods, simply subclass Rose::Object::MakeMethods and define one subroutine for each method type you want to support.
.PP
The subroutine will be passed three arguments when it is called:
.IP "\(bu" 4
The class of the method maker as a string.  This argument is usually ignored unless you are going to call some other class method.
.IP "\(bu" 4
The method name.  In the common case, a single method with this name is defined, but you are free to do whatever you want with it, including ignoring it.
.IP "\(bu" 4
A reference to a hash containing the options for the method.
.PP
The subroutine is expected to return a reference to a hash containing name/code reference pairs.  Note that the subroutine does not actually install the methods.  It simple returns the name of each method that is to be installed, along with references to the closures that contain the code for those methods.
.PP
This subroutine is called for each \fIname\fR in the method specifier.  For example, this would result in three separate calls to the \f(CW\*(C`bitfield\*(C'\fR subroutine of the \f(CW\*(C`MyMethodMaker\*(C'\fR class:
.PP
.Vb 9
\&    use MyMethodMaker
\&    (
\&      bitfield => 
\&      [
\&        \*(Aqmy_bits\*(Aq,
\&        \*(Aqyour_bits\*(Aq  => { size => 32 },
\&        \*(Aqother_bits\*(Aq => { size => 128 },
\&      ]
\&    );
.Ve
.PP
So why not have the subroutine return a single code reference rather than a reference to a hash of name.code reference pairs?  There are two reasons.
.PP
First, remember that the name argument (\*(L"my_bits\*(R", \*(L"your_bits\*(R", \*(L"other_bits\*(R") may be modified or ignored by the method maker.  The actual names of the methods created are determined by the keys of the hash reference returned by the subroutine.
.PP
Second, a single call with a single method name argument may result in the creation more than one method\*(--usually a \*(L"family\*(R" of methods.  For example:
.PP
.Vb 1
\&    package MyObject;
\&
\&    use MyMethodMaker
\&    (
\&      # creates add_book(), delete_book(), and books() methods
\&      \*(Aqhash \-\-manip\*(Aq => \*(Aqbook\*(Aq,
\&    );
\&    ...
\&
\&    $o = MyObject\->new(...);
\&
\&    $o\->add_book($book);
\&
\&    print join("\en", map { $_\->title } $o\->books);
\&
\&    $o\->delete_book($book);
.Ve
.PP
Here, the \f(CW\*(C`hash\*(C'\fR method type elected to create three methods by prepending \f(CW\*(C`add_\*(C'\fR and \f(CW\*(C`delete_\*(C'\fR and appending \f(CW\*(C`s\*(C'\fR to the supplied method name argument, \f(CW\*(C`book\*(C'\fR.
.PP
Anything not specified in this documentation is simply a matter of convention.  For example, the Rose::Object::MakeMethods subclasses all use a common set of method options: \f(CW\*(C`hash_key\*(C'\fR, \f(CW\*(C`interface\*(C'\fR, etc.  As you read their documentation, this will become apparent.
.PP
Finally, here's an example of a subclass that makes scalar accessors:
.PP
.Vb 1
\&    package Rose::Object::MakeMethods::Generic;
\&
\&    use strict;
\&    use Carp();
\&
\&    use Rose::Object::MakeMethods;
\&    our @ISA = qw(Rose::Object::MakeMethods);
\&
\&    sub scalar
\&    {
\&      my($class, $name, $args) = @_;
\&
\&      my %methods;
\&
\&      my $key = $args\->{\*(Aqhash_key\*(Aq} || $name;
\&      my $interface = $args\->{\*(Aqinterface\*(Aq} || \*(Aqget_set\*(Aq;
\&
\&      if($interface eq \*(Aqget_set_init\*(Aq)
\&      {
\&        my $init_method = $args\->{\*(Aqinit_method\*(Aq} || "init_$name";
\&
\&        $methods{$name} = sub
\&        {
\&          return $_[0]\->{$key} = $_[1]  if(@_ > 1);
\&
\&          return defined $_[0]\->{$key} ? $_[0]\->{$key} :
\&            ($_[0]\->{$key} = $_[0]\->$init_method());
\&        }
\&      }
\&      elsif($interface eq \*(Aqget_set\*(Aq)
\&      {
\&        $methods{$name} = sub
\&        {
\&          return $_[0]\->{$key} = $_[1]  if(@_ > 1);
\&          return $_[0]\->{$key};
\&        }
\&      }
\&      else { Carp::croak "Unknown interface: $interface" }
\&
\&      return \e%methods;
\&    }
.Ve
.PP
It can be used like this:
.PP
.Vb 1
\&    package MyObject;
\&
\&    use Rose::Object::MakeMethods::Generic
\&    (
\&      scalar => 
\&      [
\&        \*(Aqpower\*(Aq,
\&        \*(Aqerror\*(Aq,
\&      ],
\&
\&      \*(Aqscalar \-\-get_set_init\*(Aq => \*(Aqname\*(Aq,
\&    );
\&
\&    sub init_name { \*(AqFred\*(Aq }
\&    ...
\&
\&    $o = MyObject\->new(power => 5);
\&
\&    print $o\->name; # Fred
\&
\&    $o\->power(99) or die $o\->error;
.Ve
.PP
This is actually a subset of the code in the actual Rose::Object::MakeMethods::Generic module.  See the rest of the \f(CW\*(C`Rose::Object::MakeMethods::*\*(C'\fR and \f(CW\*(C`Rose::Class::MakeMethods::*\*(C'\fR modules for more examples.
.SH "AUTHOR"
.IX Header "AUTHOR"
John C. Siracusa (siracusa@gmail.com)
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2010 by John C. Siracusa.  All rights reserved.  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
