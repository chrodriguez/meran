.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Rose::DB::Pg 3"
.TH Rose::DB::Pg 3 "2010-12-30" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Rose::DB::Pg \- PostgreSQL driver class for Rose::DB.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Rose::DB;
\&
\&  Rose::DB\->register_db(
\&    domain   => \*(Aqdevelopment\*(Aq,
\&    type     => \*(Aqmain\*(Aq,
\&    driver   => \*(AqPg\*(Aq,
\&    database => \*(Aqdev_db\*(Aq,
\&    host     => \*(Aqlocalhost\*(Aq,
\&    username => \*(Aqdevuser\*(Aq,
\&    password => \*(Aqmysecret\*(Aq,
\&    server_time_zone => \*(AqUTC\*(Aq,
\&    european_dates   => 1,
\&  );
\&
\&  Rose::DB\->default_domain(\*(Aqdevelopment\*(Aq);
\&  Rose::DB\->default_type(\*(Aqmain\*(Aq);
\&  ...
\&
\&  $db = Rose::DB\->new; # $db is really a Rose::DB::Pg\-derived object
\&  ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Rose::DB blesses objects into a class derived from Rose::DB::Pg when the driver is \*(L"pg\*(R".  This mapping of driver names to class names is configurable.  See the documentation for Rose::DB's \fInew()\fR and \fIdriver_class()\fR methods for more information.
.PP
This class cannot be used directly.  You must use Rose::DB and let its \fInew()\fR method return an object blessed into the appropriate class for you, according to its \fIdriver_class()\fR mappings.
.PP
Only the methods that are new or have different behaviors than those in Rose::DB are documented here.  See the Rose::DB documentation for the full list of methods.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.IP "\fBeuropean_dates [\s-1BOOL\s0]\fR" 4
.IX Item "european_dates [BOOL]"
Get or set the boolean value that determines whether or not dates are assumed to be in european dd/mm/yyyy format.  The default is to assume \s-1US\s0 mm/dd/yyyy format (because this is the default for PostgreSQL).
.Sp
This value will be passed to DateTime::Format::Pg as the value of the \f(CW\*(C`european\*(C'\fR parameter in the call to the constructor \f(CW\*(C`new()\*(C'\fR.  This DateTime::Format::Pg object is used by Rose::DB::Pg to parse and format date-related column values in methods like parse_date, format_date, etc.
.IP "\fBnext_value_in_sequence \s-1SEQUENCE\s0\fR" 4
.IX Item "next_value_in_sequence SEQUENCE"
Advance the sequence named \s-1SEQUENCE\s0 and return the new value.  Returns undef if there was an error.
.IP "\fBserver_time_zone [\s-1TZ\s0]\fR" 4
.IX Item "server_time_zone [TZ]"
Get or set the time zone used by the database server software.  \s-1TZ\s0 should be a time zone name that is understood by DateTime::TimeZone.  The default value is \*(L"floating\*(R".
.Sp
This value will be passed to DateTime::Format::Pg as the value of the \f(CW\*(C`server_tz\*(C'\fR parameter in the call to the constructor \f(CW\*(C`new()\*(C'\fR.  This DateTime::Format::Pg object is used by Rose::DB::Pg to parse and format date-related column values in methods like parse_date, format_date, etc.
.Sp
See the DateTime::TimeZone documentation for acceptable values of \s-1TZ\s0.
.IP "\fBpg_enable_utf8 [\s-1BOOL\s0]\fR" 4
.IX Item "pg_enable_utf8 [BOOL]"
Get or set the pg_enable_utf8 database handle attribute.  This is set directly on the dbh, if one exists.  Otherwise, it will be set when the dbh is created.  If no value for this attribute is defined (the default) then it will not be set when the dbh is created, deferring instead to whatever default value DBD::Pg chooses.
.Sp
Returns the value of this attribute in the dbh, if one exists, or the value that will be set when the dbh is next created.
.Sp
See the DBD::Pg documentation to learn more about this attribute.
.IP "\fBsslmode [\s-1MODE\s0]\fR" 4
.IX Item "sslmode [MODE]"
Get or set the \s-1SSL\s0 mode of the connection.  Valid values for \s-1MODE\s0 are \f(CW\*(C`disable\*(C'\fR, \f(CW\*(C`allow\*(C'\fR, \f(CW\*(C`prefer\*(C'\fR, and \f(CW\*(C`require\*(C'\fR.  This attribute is used to build the \s-1DBI\s0 dsn.  Setting it has no effect until the next connection.  See the DBD::Pg documentation to learn more about this attribute.
.SS "Value Parsing and Formatting"
.IX Subsection "Value Parsing and Formatting"
.IP "\fBformat_array \s-1ARRAYREF\s0 | \s-1LIST\s0\fR" 4
.IX Item "format_array ARRAYREF | LIST"
Given a reference to an array or a list of values, return a string formatted according to the rules of PostgreSQL's \*(L"\s-1ARRAY\s0\*(R" column type.  Undef is returned if \s-1ARRAYREF\s0 points to an empty array or if \s-1LIST\s0 is not passed.
.IP "\fBformat_interval \s-1DURATION\s0\fR" 4
.IX Item "format_interval DURATION"
Given a DateTime::Duration object, return a string formatted according to the rules of PostgreSQL's \*(L"\s-1INTERVAL\s0\*(R" column type.  If \s-1DURATION\s0 is undefined, a DateTime::Duration object, a valid interval keyword (according to validate_interval_keyword), or if it looks like a function call (matches \f(CW\*(C`/^\ew+\e(.*\e)$/\*(C'\fR) and keyword_function_calls is true, then it is returned unmodified.
.IP "\fBparse_array \s-1STRING\s0\fR" 4
.IX Item "parse_array STRING"
Parse \s-1STRING\s0 and return a reference to an array.  \s-1STRING\s0 should be formatted according to PostgreSQL's \*(L"\s-1ARRAY\s0\*(R" data type.  Undef is returned if \s-1STRING\s0 is undefined.
.IP "\fBparse_interval \s-1STRING\s0\fR" 4
.IX Item "parse_interval STRING"
Parse \s-1STRING\s0 and return a DateTime::Duration object.  \s-1STRING\s0 should be formatted according to the PostgreSQL native \*(L"interval\*(R" (years, months, days, hours, minutes, seconds) data type.
.Sp
If \s-1STRING\s0 is a DateTime::Duration object, a valid interval keyword (according to validate_interval_keyword), or if it looks like a function call (matches \f(CW\*(C`/^\ew+\e(.*\e)$/\*(C'\fR) and keyword_function_calls is true, then it is returned unmodified.  Otherwise, undef is returned if \s-1STRING\s0 could not be parsed as a valid \*(L"interval\*(R" value.
.IP "\fBvalidate_date_keyword \s-1STRING\s0\fR" 4
.IX Item "validate_date_keyword STRING"
Returns true if \s-1STRING\s0 is a valid keyword for the PostgreSQL \*(L"date\*(R" data type.  Valid (case-insensitive) date keywords are:
.Sp
.Vb 7
\&    current_date
\&    epoch
\&    now
\&    now()
\&    today
\&    tomorrow
\&    yesterday
.Ve
.Sp
The keywords are case sensitive.  Any string that looks like a function call (matches \f(CW\*(C`/^\ew+\e(.*\e)$/\*(C'\fR) is also considered a valid date keyword if keyword_function_calls is true.
.IP "\fBvalidate_datetime_keyword \s-1STRING\s0\fR" 4
.IX Item "validate_datetime_keyword STRING"
Returns true if \s-1STRING\s0 is a valid keyword for the PostgreSQL \*(L"datetime\*(R" data type, false otherwise.  Valid (case-insensitive) datetime keywords are:
.Sp
.Vb 10
\&    \-infinity
\&    allballs
\&    current_date
\&    current_time
\&    current_time()
\&    current_timestamp
\&    current_timestamp()
\&    epoch
\&    infinity
\&    localtime
\&    localtime()
\&    localtimestamp
\&    localtimestamp()
\&    now
\&    now()
\&    timeofday()
\&    today
\&    tomorrow
\&    yesterday
.Ve
.Sp
The keywords are case sensitive.  Any string that looks like a function call (matches \f(CW\*(C`/^\ew+\e(.*\e)$/\*(C'\fR) is also considered a valid datetime keyword if keyword_function_calls is true.
.IP "\fBvalidate_time_keyword \s-1STRING\s0\fR" 4
.IX Item "validate_time_keyword STRING"
Returns true if \s-1STRING\s0 is a valid keyword for the PostgreSQL \*(L"time\*(R" data type, false otherwise.  Valid (case-insensitive) timestamp keywords are:
.Sp
.Vb 8
\&    allballs
\&    current_time
\&    current_time()
\&    localtime
\&    localtime()
\&    now
\&    now()
\&    timeofday()
.Ve
.Sp
The keywords are case sensitive.  Any string that looks like a function call (matches \f(CW\*(C`/^\ew+\e(.*\e)$/\*(C'\fR) is also considered a valid timestamp keyword if keyword_function_calls is true.
.IP "\fBvalidate_timestamp_keyword \s-1STRING\s0\fR" 4
.IX Item "validate_timestamp_keyword STRING"
Returns true if \s-1STRING\s0 is a valid keyword for the PostgreSQL \*(L"timestamp\*(R" data type, false otherwise.  Valid (case-insensitive) timestamp keywords are:
.Sp
.Vb 10
\&    \-infinity
\&    allballs
\&    current_date
\&    current_time
\&    current_time()
\&    current_timestamp
\&    current_timestamp()
\&    epoch
\&    infinity
\&    localtime
\&    localtime()
\&    localtimestamp
\&    localtimestamp()
\&    now
\&    now()
\&    timeofday()
\&    today
\&    tomorrow
\&    yesterday
.Ve
.Sp
The keywords are case sensitive.  Any string that looks like a function call (matches \f(CW\*(C`/^\ew+\e(.*\e)$/\*(C'\fR) is also considered a valid timestamp keyword if keyword_function_calls is true.
.SH "AUTHOR"
.IX Header "AUTHOR"
John C. Siracusa (siracusa@gmail.com)
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2010 by John C. Siracusa.  All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same terms
as Perl itself.
