.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.19)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Rose::DB::Object::MakeMethods::Pg 3"
.TH Rose::DB::Object::MakeMethods::Pg 3 "2010-04-27" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Rose::DB::Object::MakeMethods::Pg \- Create PostgreSQL\-specific object methods for Rose::DB::Object\-derived objects.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MyDBObject;
\&
\&  our @ISA = qw(Rose::DB::Object);
\&
\&  use Rose::DB::Object::MakeMethods::Pg
\&  (
\&    chkpass => 
\&    [
\&      \*(Aqpassword\*(Aq,
\&      \*(Aqsecret\*(Aq => 
\&      {
\&        encrypted_suffix => \*(Aq_mangled\*(Aq,
\&        cmp_suffix       => \*(Aq_equals\*(Aq,
\&      },
\&    ],
\&  );
\&
\&  ...
\&
\&  $o = MyDBObject\->new(...);
\&
\&  $o\->password(\*(Aqfoobar\*(Aq);
\&
\&  # Something like: ":vOR7BujbRZSLM" (varies based on salt used)
\&  print $o\->password_encrypted;
\&
\&  print $o\->password; # "foobar"
\&  print "ok" if($o\->password_is(\*(Aqfoobar\*(Aq); # "ok"
\&
\&  $o\->secret(\*(Aqbaz\*(Aq);
\&
\&  # Something like: ":jqROBZMqtWGJE" (varies based on salt used)
\&  print $o\->secret_mangled;
\&
\&  print $o\->secret; # "baz"
\&  print "ok" if($o\->secret_equals(\*(Aqbaz\*(Aq); # "ok"
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Rose::DB::Object::MakeMethods::Pg\*(C'\fR creates methods that deal with data types that are specific to the PostgreSQL database server.  It inherits from Rose::Object::MakeMethods.  See the Rose::Object::MakeMethods documentation to learn about the interface.  The method types provided by this module are described below.
.PP
All method types defined by this module are designed to work with objects that are subclasses of (or otherwise conform to the interface of) Rose::DB::Object.  In particular, the object is expected to have a \f(CW\*(C`db\*(C'\fR method that returns a Rose::DB\-derived object.  See the Rose::DB::Object documentation for more details.
.SH "METHODS TYPES"
.IX Header "METHODS TYPES"
.IP "\fBchkpass\fR" 4
.IX Item "chkpass"
Create a family methods for handling PostgreSQL's \*(L"\s-1CHKPASS\s0\*(R" data type.  This data type is not installed by default, but is included in the standard PostgreSQL source code distribution (in the \*(L"contrib\*(R" directory).  From the \s-1README\s0 file for \s-1CHKPASS:\s0
.Sp
"Chkpass is a password type that is automatically checked and converted upon
entry.  It is stored encrypted.  To compare, simply compare against a clear
text password and the comparison function will encrypt it before comparing.
.Sp
If you precede the string with a colon, the encryption and checking are
skipped so that you can enter existing passwords into the field.
.Sp
On output, a colon is prepended.  This makes it possible to dump and reload
passwords without re-encrypting them.  If you want the password (encrypted)
without the colon then use the \fIraw()\fR function.  This allows you to use the
type with things like Apache's Auth_PostgreSQL module."
.Sp
This data type is very handy for storing encrypted values such as passwords while still retaining the ability to perform SELECTs and such using unencrypted values in comparisons.  For example, the query
.Sp
.Vb 1
\&    SELECT * FROM users WHERE password = \*(Aqfoobar\*(Aq
.Ve
.Sp
will actually find all the users whose passwords are \*(L"foobar\*(R", even though all the passwords are encrypted in the database.
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.ie n .IP """cmp_suffix""" 4
.el .IP "\f(CWcmp_suffix\fR" 4
.IX Item "cmp_suffix"
.PD
The string appended to the default method name to form the name of the comparison method.  Defaults to \*(L"_is\*(R".
.ie n .IP """encrypted_suffix""" 4
.el .IP "\f(CWencrypted_suffix\fR" 4
.IX Item "encrypted_suffix"
The string appended to the default method name to form the name of the get/set method that handles the encrypted version of the \s-1CHKPASS\s0 value.  Defaults to \*(L"_encrypted\*(R".
.ie n .IP """hash_key""" 4
.el .IP "\f(CWhash_key\fR" 4
.IX Item "hash_key"
The key inside the hash-based object to use for the storage of the unencrypted value.  Defaults to the name of the method.
.Sp
The encrypted value is stored in a hash key with the same name, but with \f(CW\*(C`encrypted_suffix\*(C'\fR appended.
.ie n .IP """interface""" 4
.el .IP "\f(CWinterface\fR" 4
.IX Item "interface"
Choose the interface.  The default is \f(CW\*(C`get_set\*(C'\fR.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.ie n .IP """get_set""" 4
.el .IP "\f(CWget_set\fR" 4
.IX Item "get_set"
.PD
Creates a family of methods for handling PostgreSQL's \*(L"\s-1CHKPASS\s0\*(R" data type.  The methods are:
.RS 4
.ie n .IP """default""" 4
.el .IP "\f(CWdefault\fR" 4
.IX Item "default"
The get/set method for the unencrypted value.  (This method uses the default method name.)  If called with no arguments, the unencrypted value is returned, if it is known.  If not, undef is returned.
.Sp
If passed an argument that begins with \*(L":\*(R", it is assumed to be an encrypted value and is stored as such.  Undef is returned, since it is not feasible to determine the unencrypted value based on the encrypted value.
.Sp
If passed an argument that does not begin with \*(L":\*(R", it is taken as the unencrypted value.  The value is encrypted using Perl's \f(CW\*(C`crypt()\*(C'\fR function paired with a randomly selected salt, and the unencrypted value is returned.
.ie n .IP """encrypted""" 4
.el .IP "\f(CWencrypted\fR" 4
.IX Item "encrypted"
The get/set method for the encrypted value.  The method name will be formed by concatenating the \f(CW\*(C`default\*(C'\fR method name (above) and the value of the \f(CW\*(C`encrypted_suffix\*(C'\fR option.
.Sp
If called with no arguments, the encrypted value is returned, if it is known.  If not, undef is returned.
.Sp
If passed an argument that begins with \*(L":\*(R", it is assumed to be an encrypted value and is stored as such.  The unencrypted value is set to undef, since it is not feasible to determine the unencrypted value based on the encrypted value.  The encrypted value is returned.
.Sp
If passed an argument that does not begin with \*(L":\*(R", it is taken as the unencrypted value.  The value is encrypted using Perl's \f(CW\*(C`crypt()\*(C'\fR function paired with a randomly selected salt, and the encrypted value is returned.
.ie n .IP """comparison""" 4
.el .IP "\f(CWcomparison\fR" 4
.IX Item "comparison"
This method compares its argument to the unencrypted value and returns true if the two values are identical (string comparison), false if they are not, and undef if both the encrypted and unencrypted values are undefined.
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.ie n .IP """get""" 4
.el .IP "\f(CWget\fR" 4
.IX Item "get"
Creates an accessor method for PostgreSQL's \*(L"\s-1CHKPASS\s0\*(R" data type.  This method behaves like the \f(CW\*(C`get_set\*(C'\fR method, except that the value cannot be set.
.ie n .IP """set""" 4
.el .IP "\f(CWset\fR" 4
.IX Item "set"
Creates a mutator method for PostgreSQL's \*(L"\s-1CHKPASS\s0\*(R" data type.  This method behaves like the \f(CW\*(C`get_set\*(C'\fR method, except that a fatal error will occur if no arguments are passed.
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&    package MyDBObject;
\&
\&    our @ISA = qw(Rose::DB::Object);
\&
\&    use Rose::DB::Object::MakeMethods::Pg
\&    (
\&      chkpass => 
\&      [
\&        \*(Aqpassword\*(Aq,
\&        \*(Aqget_password\*(Aq => { interface => \*(Aqget\*(Aq, hash_key => \*(Aqpassword\*(Aq },
\&        \*(Aqset_password\*(Aq => { interface => \*(Aqset\*(Aq, hash_key => \*(Aqpassword\*(Aq },
\&        \*(Aqsecret\*(Aq => 
\&        {
\&          encrypted_suffix => \*(Aq_mangled\*(Aq,
\&          cmp_suffix       => \*(Aq_equals\*(Aq,
\&        },
\&      ],
\&    );
\&
\&    ...
\&
\&    $o = MyDBObject\->new(...);
\&
\&    $o\->set_password(\*(Aqblah\*(Aq);
\&
\&    $o\->password(\*(Aqfoobar\*(Aq);
\&
\&    # Something like: ":vOR7BujbRZSLM" (varies based on salt used)
\&    print $o\->password_encrypted;
\&
\&    print $o\->get_password; # "foobar"
\&    print $o\->password;     # "foobar"
\&    print "ok" if($o\->password_is(\*(Aqfoobar\*(Aq); # "ok"
\&
\&    $o\->secret(\*(Aqbaz\*(Aq);
\&
\&    # Something like: ":jqROBZMqtWGJE" (varies based on salt used)
\&    print $o\->secret_mangled;
\&
\&    print $o\->secret; # "baz"
\&    print "ok" if($o\->secret_equals(\*(Aqbaz\*(Aq); # "ok"
.Ve
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
John C. Siracusa (siracusa@gmail.com)
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2010 by John C. Siracusa.  All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same terms
as Perl itself.
