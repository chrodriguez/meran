.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.19)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Rose::DB::Object::MakeMethods::BigNum 3"
.TH Rose::DB::Object::MakeMethods::BigNum 3 "2010-10-22" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Rose::DB::Object::MakeMethods::BigNum \- Create object methods for arbitrary\-precision numeric attributes for Rose::DB::Object\-derived objects.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MyDBObject;
\&
\&  our @ISA = qw(Rose::DB::Object);
\&
\&  use Rose::DB::Object::MakeMethods::BigNum
\&  (
\&    bigint => 
\&    [
\&      count => 
\&      {
\&        with_init => 1,
\&        min       => 0,
\&      },
\&
\&      # Important: specify very large integer values as strings
\&      tally => { default => \*(Aq9223372036854775800\*(Aq },
\&    ],
\&  );
\&
\&  sub init_count { 12345 }
\&  ...
\&
\&  $obj = MyDBObject\->new(...);
\&
\&  print $obj\->count; # 12345
\&  print $obj\->tally; # 9223372036854775800
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Rose::DB::Object::MakeMethods::BigNum is a method maker that inherits from Rose::Object::MakeMethods.  See the Rose::Object::MakeMethods documentation to learn about the interface.  The method types provided by this module are described below.
.PP
All method types defined by this module are designed to work with objects that are subclasses of (or otherwise conform to the interface of) Rose::DB::Object.  See the Rose::DB::Object documentation for more details.
.SH "METHODS TYPES"
.IX Header "METHODS TYPES"
.IP "\fBbigint\fR" 4
.IX Item "bigint"
Create get/set methods for big integer attributes.  Values are stored internally and returned as Math::BigInt objects.  When specifying very large integer values, use strings to be safe.  (See an example in the synopsis above.)
.RS 4
.IP "Options" 4
.IX Item "Options"
.RS 4
.PD 0
.IP "\fBcheck_in \s-1ARRAYREF\s0\fR" 4
.IX Item "check_in ARRAYREF"
.PD
A reference to an array of valid values.  When setting the attribute, if the new value is not equal to one of the valid values, a fatal error will occur.
.IP "\fBdefault \s-1VALUE\s0\fR" 4
.IX Item "default VALUE"
Determines the default value of the attribute.
.IP "\fBhash_key \s-1NAME\s0\fR" 4
.IX Item "hash_key NAME"
The key inside the hash-based object to use for the storage of this
attribute.  Defaults to the name of the method.
.IP "\fBinit_method \s-1NAME\s0\fR" 4
.IX Item "init_method NAME"
The name of the method to call when initializing the value of an undefined attribute.  Defaults to the method name with the prefix \f(CW\*(C`init_\*(C'\fR added.  This option implies \f(CW\*(C`with_init\*(C'\fR.
.IP "\fBinterface \s-1NAME\s0\fR" 4
.IX Item "interface NAME"
Choose the interface.  The default is \f(CW\*(C`get_set\*(C'\fR.
.IP "\fBmax \s-1INT\s0\fR" 4
.IX Item "max INT"
Get or set the maximum value this attribute is allowed to have.
.IP "\fBmin \s-1INT\s0\fR" 4
.IX Item "min INT"
Get or set the minimum value this attribute is allowed to have.
.IP "\fBwith_init \s-1BOOL\s0\fR" 4
.IX Item "with_init BOOL"
Modifies the behavior of the \f(CW\*(C`get_set\*(C'\fR and \f(CW\*(C`get\*(C'\fR interfaces.  If the attribute is undefined, the method specified by the \f(CW\*(C`init_method\*(C'\fR option is called and the attribute is set to the return value of that method.
.RE
.RS 4
.RE
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.PD 0
.IP "Interfaces" 4
.IX Item "Interfaces"
.RS 4
.IP "\fBget_set\fR" 4
.IX Item "get_set"
.PD
Creates a get/set method for a big integer object attribute.  When called with an argument, the value of the attribute is set.  The current value of the attribute is returned.
.IP "\fBget\fR" 4
.IX Item "get"
Creates an accessor method for a big integer object attribute that returns the current value of the attribute.
.IP "\fBset\fR" 4
.IX Item "set"
Creates a mutator method for a big integer object attribute.  When called with an argument, the value of the attribute is set.  If called with no arguments, a fatal error will occur.
.RE
.RS 4
.RE
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 1
\&    package MyDBObject;
\&
\&    our @ISA = qw(Rose::DB::Object);
\&
\&    use Rose::DB::Object::MakeMethods::BigNum
\&    (
\&      bigint => 
\&      [
\&        count => 
\&        {
\&          with_init => 1,
\&          min       => 0,
\&        },
\&
\&        # Important: specify very large integer values as strings
\&        tally => { default => \*(Aq9223372036854775800\*(Aq },
\&      ],
\&    );
\&
\&    sub init_count { 12345 }
\&    ...
\&
\&    $obj = MyDBObject\->new(...);
\&
\&    print $obj\->count; # 12345
\&    print $obj\->tally; # 9223372036854775800
\&
\&    $obj\->count(\-1); # Fatal error: minimum value is 0
.Ve
.RE
.RE
.RS 4
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
John C. Siracusa (siracusa@gmail.com)
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2010 by John C. Siracusa.  All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same terms
as Perl itself.
