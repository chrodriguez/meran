.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.19)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Rose::DB::Object::Helpers 3"
.TH Rose::DB::Object::Helpers 3 "2010-04-27" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Rose::DB::Object::Helpers \- A mix\-in class containing convenience methods for Rose::DB::Object.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MyDBObject;
\&
\&  use Rose::DB::Object;
\&  our @ISA = qw(Rose::DB::Object);
\&
\&  use Rose::DB::Object::Helpers \*(Aqclone\*(Aq, 
\&    { load_or_insert => \*(Aqfind_or_create\*(Aq };
\&  ...
\&
\&  $obj = MyDBObject\->new(id => 123);
\&  $obj\->find_or_create();
\&
\&  $obj2 = $obj\->clone;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Rose::DB::Object::Helpers provides convenience methods from use with Rose::DB::Object\-derived classes.  These methods do not exist in Rose::DB::Object in order to keep the method namespace clean.  (Each method added to Rose::DB::Object is another potential naming conflict with a column accessor.)
.PP
This class inherits from Rose::Object::MixIn.  See the Rose::Object::MixIn documentation for a full explanation of how to import methods from this class.  The helper methods themselves are described below.
.SH "FUNCTIONS VS. METHODS"
.IX Header "FUNCTIONS VS. METHODS"
Due to the \*(L"wonders\*(R" of Perl 5's object system, any helper method described here can also be used as a Rose::DB::Object::Util\-style utility \fIfunction\fR that takes a Rose::DB::Object\-derived object as its first argument.  Example:
.PP
.Vb 2
\&  # Import two helpers
\&  use Rose::DB::Object::Helpers qw(clone_and_reset traverse_depth_first);
\&
\&  $o = My::DB::Object\->new(...);
\&
\&  clone_and_reset($o); # Imported helper "method" called as function
\&
\&  # Imported helper "method" with arguments called as function
\&  traverse_depth_first($o, handlers => { ... }, max_depth => 2);
.Ve
.PP
Why, then, the distinction between Rose::DB::Object::Helpers methods and Rose::DB::Object::Util functions?  It's simply a matter of context.  The functions in Rose::DB::Object::Util are most useful in the context of the internals (e.g., writing your own column method-maker) whereas Rose::DB::Object::Helpers methods are most often added to a common Rose::DB::Object\-derived base class and then called as object methods by all classes that inherit from it.
.PP
The point is, these are just conventions.  Use any of these subroutines as functions or as methods as you see fit.  Just don't forget to pass a Rose::DB::Object\-derived object as the first argument when calling as a function.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.SS "as_json [\s-1PARAMS\s0]"
.IX Subsection "as_json [PARAMS]"
Returns a JSON-formatted string created from the object tree as created by the as_tree method.  \s-1PARAMS\s0 are the same as for the as_tree method, except that the \f(CW\*(C`deflate\*(C'\fR parameter is ignored (it is always set to true).
.PP
You must have the \s-1JSON\s0 module version 2.12 or later installed in order to use this helper method.  If you have the \s-1JSON::XS\s0 module version 2.2222 or later installed, this method will work a lot faster.
.SS "as_tree [\s-1PARAMS\s0]"
.IX Subsection "as_tree [PARAMS]"
Returns a reference to a hash of name/value pairs representing the column values of this object as well as any nested sub-objects.  The \s-1PARAMS\s0 name/value pairs dictate the details of the sub-object traversal.  Valid parameters are:
.IP "\fBallow_loops \s-1BOOL\s0\fR" 4
.IX Item "allow_loops BOOL"
If true, allow loops during the traversal (e.g., A \-> B \-> C \-> A).  The default value is false.
.IP "\fBdeflate \s-1BOOL\s0\fR" 4
.IX Item "deflate BOOL"
If true, the values in the tree will be simple scalars suitable for storage in the database (e.g., a date string like \*(L"2005\-12\-31\*(R" instead of a DateTime object).  The default is true.
.IP "\fBexclude \s-1CODEREF\s0\fR" 4
.IX Item "exclude CODEREF"
A reference to a subroutine that is called on each Rose::DB::Object\-derived object encountered during the traversal.  It is passed the object, the parent object (undef, if none), and the  Rose::DB::Object::Metadata::Relationship\-derived object (undef, if none) that led to this object.  If the subroutine returns true, then this object is not processed.  Example:
.Sp
.Vb 7
\&    exclude => sub
\&    {
\&      my($object, $parent, $rel_meta) = @_;
\&      ...
\&      return 1  if($should_exclude);
\&      return 0;
\&    },
.Ve
.IP "\fBforce_load \s-1BOOL\s0\fR" 4
.IX Item "force_load BOOL"
If true, related sub-objects will be loaded from the database.  If false, then only the sub-objects that have already been loaded from the database will be traversed.  The default is false.
.IP "\fBmax_depth \s-1DEPTH\s0\fR" 4
.IX Item "max_depth DEPTH"
Do not descend past \s-1DEPTH\s0 levels.  Depth is an integer starting from 0 for the object that the as_tree method was called on and increasing with each level of related objects.  The default value is 100.
.IP "\fBpersistent_columns_only \s-1BOOL\s0\fR" 4
.IX Item "persistent_columns_only BOOL"
If true, non-persistent columns will not be included in the tree.  The default is false.
.IP "\fBprune \s-1CODEREF\s0\fR" 4
.IX Item "prune CODEREF"
A reference to a subroutine that is called on each Rose::DB::Object::Metadata::Relationship\-derived object encountered during traversal.  It is passed the relationship object, the parent object, and the depth.  If the subroutine returns true, then the entire sub-tree below this relationship will not be traversed.  Example:
.Sp
.Vb 7
\&    prune => sub
\&    {
\&      my($rel_meta, $object, $depth) = @_;
\&      ...
\&      return 1  if($should_prune);
\&      return 0;
\&    },
.Ve
.PP
\&\fBCaveats\fR: Currently, you cannot have a relationship and a column with the same name in the same class.  This should not happen without explicit action on the part of the class creator, but it is technically possible.  The result of serializing such an object using as_tree is undefined.  This limitation may be removed in the future.
.PP
The exact format of the \*(L"tree\*(R" data structure returned by this method is not public and may change in the future (e.g., to overcome the limitation described above).
.SS "as_yaml [\s-1PARAMS\s0]"
.IX Subsection "as_yaml [PARAMS]"
Returns a YAML-formatted string created from the object tree as created by the as_tree method.  \s-1PARAMS\s0 are the same as for the as_tree method, except that the \f(CW\*(C`deflate\*(C'\fR parameter is ignored (it is always set to true).
.PP
You must have the YAML::Syck module installed in order to use this helper method.
.SS "clone"
.IX Subsection "clone"
Returns a new object initialized with the column values of the existing object.  For example, imagine a \f(CW\*(C`Person\*(C'\fR class with three columns, \f(CW\*(C`id\*(C'\fR, \f(CW\*(C`name\*(C'\fR, and \f(CW\*(C`age\*(C'\fR.
.PP
.Vb 1
\&    $a = Person\->new(id => 123, name => \*(AqJohn\*(Aq, age => 30);
.Ve
.PP
This use of the \f(CW\*(C`clone()\*(C'\fR method:
.PP
.Vb 1
\&    $b = $a\->clone;
.Ve
.PP
is equivalent to this:
.PP
.Vb 1
\&    $b = Person\->new(id => $a\->id, name => $a\->name, age => $a\->age);
.Ve
.SS "clone_and_reset"
.IX Subsection "clone_and_reset"
This is the same as the clone method described above, except that it also sets all of the primary and unique key columns to undef.  If the cloned object has a db attribute, then it is copied to the clone object as well.
.PP
For example, imagine a \f(CW\*(C`Person\*(C'\fR class with three columns, \f(CW\*(C`id\*(C'\fR, \f(CW\*(C`name\*(C'\fR, and \f(CW\*(C`age\*(C'\fR, where \f(CW\*(C`id\*(C'\fR is the primary key and \f(CW\*(C`name\*(C'\fR is a unique key.
.PP
.Vb 1
\&    $a = Person\->new(id => 123, name => \*(AqJohn\*(Aq, age => 30, db => $db);
.Ve
.PP
This use of the \f(CW\*(C`clone_and_reset()\*(C'\fR method:
.PP
.Vb 1
\&    $b = $a\->clone_and_reset;
.Ve
.PP
is equivalent to this:
.PP
.Vb 4
\&    $b = Person\->new(id => $a\->id, name => $a\->name, age => $a\->age);
\&    $b\->id(undef);   # reset primary key
\&    $b\->name(undef); # reset unique key
\&    $b\->db($a\->db);  # copy db
.Ve
.SS "column_values_as_json"
.IX Subsection "column_values_as_json"
Returns a string containing a \s-1JSON\s0 representation of the object's column values.  You must have the \s-1JSON\s0 module version 2.12 or later installed in order to use this helper method.  If you have the \s-1JSON::XS\s0 module version 2.2222 or later installed, this method will work a lot faster.
.SS "column_values_as_yaml"
.IX Subsection "column_values_as_yaml"
Returns a string containing a \s-1YAML\s0 representation of the object's column values.  You must have the YAML::Syck module installed in order to use this helper method.
.SS "column_accessor_value_pairs"
.IX Subsection "column_accessor_value_pairs"
Returns a hash (in list context) or reference to a hash (in scalar context) of column accessor method names and column values.  The keys of the hash are the accessor method names for the columns.  The values are retrieved by calling the accessor method for each column.
.SS "column_mutator_value_pairs"
.IX Subsection "column_mutator_value_pairs"
Returns a hash (in list context) or reference to a hash (in scalar context) of column mutator method names and column values.  The keys of the hash are the mutator method names for the columns.  The values are retrieved by calling the accessor method for each column.
.SS "column_value_pairs"
.IX Subsection "column_value_pairs"
Returns a hash (in list context) or reference to a hash (in scalar context) of column name and value pairs.  The keys of the hash are the names of the columns.  The values are retrieved by calling the accessor method for each column.
.SS "dirty_columns [ \s-1NAMES\s0 | \s-1COLUMNS\s0 ]"
.IX Subsection "dirty_columns [ NAMES | COLUMNS ]"
Given a list of column names or Rose::DB::Object::Metadata::Column\-derived objects, mark each column in the invoking object as modifed.
.PP
If passed no arguments, returns a list of all modified columns in list context or the number of modified columns in scalar context.
.SS "forget_related [ \s-1NAME\s0 | \s-1PARAMS\s0 ]"
.IX Subsection "forget_related [ NAME | PARAMS ]"
Given a foreign key or relationship name, forget any previously loaded objects related by the specified foreign key or relationship.  Normally, any objects loaded by the default accessor methods for relationships and foreign keys are fetched from the database only the first time they are asked for, and simply returned thereafter.  Asking them to be \*(L"forgotten\*(R" causes them to be fetched anew from the database the next time they are asked for.
.PP
If the related object name is passed as a plain string \s-1NAME\s0, then a foreign key with that name is looked up.  If no such foreign key exists, then a relationship with that name is looked up.  If no such relationship or foreign key exists, a fatal error will occur.  Example:
.PP
.Vb 1
\&    $foo\->forget_related(\*(Aqbar\*(Aq);
.Ve
.PP
It's generally not a good idea to add a foreign key and a relationship with the same name, but it is technically possible.  To specify the domain of the name, pass the name as the value of a \f(CW\*(C`foreign_key\*(C'\fR or \f(CW\*(C`relationship\*(C'\fR parameter.  Example:
.PP
.Vb 2
\&    $foo\->forget_related(foreign_key => \*(Aqbar\*(Aq);
\&    $foo\->forget_related(relationship => \*(Aqbar\*(Aq);
.Ve
.SS "has_loaded_related [ \s-1NAME\s0 | \s-1PARAMS\s0 ]"
.IX Subsection "has_loaded_related [ NAME | PARAMS ]"
Given a foreign key or relationship name, return true if one or more related objects have been loaded into the current object, false otherwise.
.PP
If the name is passed as a plain string \s-1NAME\s0, then a foreign key with that name is looked up.  If no such foreign key exists, then a relationship with that name is looked up.  If no such relationship or foreign key exists, a fatal error will occur.  Example:
.PP
.Vb 1
\&    $foo\->has_loaded_related(\*(Aqbar\*(Aq);
.Ve
.PP
It's generally not a good idea to add a foreign key and a relationship with the same name, but it is technically possible.  To specify the domain of the name, pass the name as the value of a \f(CW\*(C`foreign_key\*(C'\fR or \f(CW\*(C`relationship\*(C'\fR parameter.  Example:
.PP
.Vb 2
\&    $foo\->has_loaded_related(foreign_key => \*(Aqbar\*(Aq);
\&    $foo\->has_loaded_related(relationship => \*(Aqbar\*(Aq);
.Ve
.SS "init_with_column_value_pairs [ \s-1HASH\s0 | \s-1HASHREF\s0 ]"
.IX Subsection "init_with_column_value_pairs [ HASH | HASHREF ]"
Initialize an object with a hash or reference to a hash of column/value pairs.  This differs from the inherited init method in that it accepts column names rather than method names.  A column name may not be the same as its mutator method name if the column is aliased, for example.
.PP
.Vb 1
\&    $p = Person\->new; # assume "type" column is aliased to "person_type"
\&
\&    # init() takes method/value pairs
\&    $p\->init(person_type => \*(Aqcool\*(Aq, age => 30);
\&
\&    # Helper takes a hashref of column/value pairs
\&    $p\->init_with_column_value_pairs({ type => \*(Aqcool\*(Aq, age => 30 });
\&
\&    # ...or a hash of column/value pairs
\&    $p\->init_with_column_value_pairs(type => \*(Aqcool\*(Aq, age => 30);
.Ve
.SS "init_with_json \s-1JSON\s0"
.IX Subsection "init_with_json JSON"
Initialize the object with a JSON-formatted string.  The \s-1JSON\s0 string must be in the format returned by the as_json (or column_values_as_json) method.  Example:
.PP
.Vb 2
\&    $p1 = Person\->new(name => \*(AqJohn\*(Aq, age => 30);
\&    $json = $p1\->as_json;
\&
\&    $p2 = Person\->new;
\&    $p2\->init_with_json($json);
\&
\&    print $p2\->name; # John
\&    print $p2\->age;  # 30
.Ve
.SS "init_with_deflated_tree \s-1TREE\s0"
.IX Subsection "init_with_deflated_tree TREE"
This is the same as the init_with_tree method, except that it expects all the values to be simple scalars suitable for storage in the database (e.g., a date string like \*(L"2005\-12\-31\*(R" instead of a DateTime object).  In other words, the \s-1TREE\s0 should be in the format generated by the as_tree method called with the \f(CW\*(C`deflate\*(C'\fR parameter set to true.  Initializing objects in this way is slightly more efficient.
.SS "init_with_tree \s-1TREE\s0"
.IX Subsection "init_with_tree TREE"
Initialize the object with a Perl data structure in the format returned from the as_tree method.  Example:
.PP
.Vb 2
\&    $p1 = Person\->new(name => \*(AqJohn\*(Aq, age => 30);
\&    $tree = $p1\->as_tree;
\&
\&    $p2 = Person\->new;
\&    $p2\->init_with_tree($tree);
\&
\&    print $p2\->name; # John
\&    print $p2\->age;  # 30
.Ve
.SS "init_with_yaml \s-1YAML\s0"
.IX Subsection "init_with_yaml YAML"
Initialize the object with a YAML-formatted string.  The \s-1YAML\s0 string must be in the format returned by the as_yaml (or column_values_as_yaml) method.  Example:
.PP
.Vb 2
\&    $p1 = Person\->new(name => \*(AqJohn\*(Aq, age => 30);
\&    $yaml = $p1\->as_yaml;
\&
\&    $p2 = Person\->new;
\&    $p2\->init_with_yaml($yaml);
\&
\&    print $p2\->name; # John
\&    print $p2\->age;  # 30
.Ve
.SS "insert_or_update [\s-1PARAMS\s0]"
.IX Subsection "insert_or_update [PARAMS]"
If the object already exists in the database, then update it.  Otherwise, insert it.  Any \s-1PARAMS\s0 are passed on to the call to save (which is supplied with the appropriate \f(CW\*(C`insert\*(C'\fR or \f(CW\*(C`update\*(C'\fR boolean parameter).
.PP
This method differs from the standard save method in that save decides to insert or update based solely on whether or not the object was previously loaded.  This method will take the extra step of actually attempting to load the object to see whether or not it's in the database.
.PP
The return value of the save method is returned.
.SS "insert_or_update_on_duplicate_key [\s-1PARAMS\s0]"
.IX Subsection "insert_or_update_on_duplicate_key [PARAMS]"
Update or insert a row with a single \s-1SQL\s0 statement, depending on whether or not a row with the same primary or unique key already exists.  Any \s-1PARAMS\s0 are passed on to the call to save (which is supplied with the appropriate \f(CW\*(C`insert\*(C'\fR or \f(CW\*(C`update\*(C'\fR boolean parameter).
.PP
If the current database does not support the \*(L"\s-1ON\s0 \s-1DUPLICATE\s0 \s-1KEY\s0 \s-1UPDATE\s0\*(R" \s-1SQL\s0 extension, then this method simply calls the insert_or_update method, pasing all \s-1PARAMS\s0.
.PP
Currently, the only database that supports \*(L"\s-1ON\s0 \s-1DUPLICATE\s0 \s-1KEY\s0 \s-1UPDATE\s0\*(R" is MySQL, and only in version 4.1.0 or later.  You can read more about the feature here:
.PP
http://dev.mysql.com/doc/refman/5.1/en/insert\-on\-duplicate.html <http://dev.mysql.com/doc/refman/5.1/en/insert-on-duplicate.html>
.PP
Here's a quick example of the \s-1SQL\s0 syntax:
.PP
.Vb 2
\&    INSERT INTO table (a, b, c) VALUES (1, 2, 3) 
\&      ON DUPLICATE KEY UPDATE a = 1, b = 2, c = 3;
.Ve
.PP
Note that there are two sets of columns and values in the statement.  This presents a choice: which columns to put in the \*(L"\s-1INSERT\s0\*(R" part, and which to put in the \*(L"\s-1UPDATE\s0\*(R" part.
.PP
When using this method, if the object was previously loaded from the database, then values for all columns are put in both the \*(L"\s-1INSERT\s0\*(R" and \*(L"\s-1UPDATE\s0\*(R" portions of the statement.
.PP
Otherwise, all columns are included in both clauses \fIexcept\fR those belonging to primary keys or unique keys which have only undefined values.  This is important because it allows objects to be updated based on a single primary or unique key, even if other possible keys exist, but do not have values set.  For example, consider this table with the following data:
.PP
.Vb 5
\&    CREATE TABLE parts
\&    (
\&      id      INT PRIMARY KEY,
\&      code    CHAR(3) NOT NULL,
\&      status  CHAR(1),
\&
\&      UNIQUE(code)
\&    );
\&
\&    INSERT INTO parts (id, code, status) VALUES (1, \*(Aqabc\*(Aq, \*(Aqx\*(Aq);
.Ve
.PP
This code will update part id 1, setting its \*(L"status\*(R" column to \*(L"y\*(R".
.PP
.Vb 2
\&    $p = Part\->new(code => \*(Aqabc\*(Aq, status => \*(Aqy\*(Aq);
\&    $p\->insert_or_update_on_duplicate_key;
.Ve
.PP
The resulting \s-1SQL:\s0
.PP
.Vb 2
\&    INSERT INTO parts (code, status) VALUES (\*(Aqabc\*(Aq, \*(Aqy\*(Aq) 
\&      ON DUPLICATE KEY UPDATE code = \*(Aqabc\*(Aq, status = \*(Aqy\*(Aq;
.Ve
.PP
Note that the \*(L"id\*(R" column is omitted because it has an undefined value.  The \s-1SQL\s0 statement will detect the duplicate value for the unique key \*(L"code\*(R" and then run the \*(L"\s-1UPDATE\s0\*(R" portion of the query, setting \*(L"status\*(R" to \*(L"y\*(R".
.PP
This method returns true if the row was inserted or updated successfully, false otherwise.  The true value returned on success will be the object itself.  If the object overloads its boolean value such that it is not true, then a true value will be returned instead of the object itself.
.PP
Yes, this method name is very long.  Remember that you can rename methods on import.  It is expected that most people will want to rename this method to \*(L"insert_or_update\*(R", using it in place of the normal insert_or_update helper method:
.PP
.Vb 4
\&    package My::DB::Object;
\&    ...
\&    use Rose::DB::Object::Helpers 
\&      { insert_or_update_on_duplicate_key => \*(Aqinsert_or_update\*(Aq };
.Ve
.SS "load_or_insert [\s-1PARAMS\s0]"
.IX Subsection "load_or_insert [PARAMS]"
Try to load the object, passing \s-1PARAMS\s0 to the call to the \fIload()\fR method.  The parameter \*(L"speculative => 1\*(R" is automatically added to \s-1PARAMS\s0.  If no such object is found, then the object is inserted.
.PP
Example:
.PP
.Vb 2
\&    # Get object id 123 if it exists, otherwise create it now.
\&    $obj = MyDBObject\->new(id => 123)\->load_or_insert;
.Ve
.SS "load_or_save [\s-1PARAMS\s0]"
.IX Subsection "load_or_save [PARAMS]"
Try to load the object, passing \s-1PARAMS\s0 to the call to the \fIload()\fR method.  The parameter \*(L"speculative => 1\*(R" is automatically added to \s-1PARAMS\s0.  If no such object is found, then the object is saved.
.PP
This methods differs from load_or_insert in that the save method will also save sub-objects.  See the documentation for Rose::DB::Object's save method for more information.
.PP
Example:
.PP
.Vb 1
\&    @perms = (Permission\->new(...), Permission\->new(...));
\&
\&    # Get person id 123 if it exists, otherwise create it now
\&    # along with permission sub\-objects.
\&    $person = Person\->new(id    => 123, 
\&                          perms => \e@perms)\->load_or_insert;
.Ve
.SS "load_speculative [\s-1PARAMS\s0]"
.IX Subsection "load_speculative [PARAMS]"
Try to load the object, passing \s-1PARAMS\s0 to the call to the \fIload()\fR method along with the \*(L"speculative => 1\*(R" parameter.  See the documentation for Rose::DB::Object's load method for more information.
.PP
Example:
.PP
.Vb 1
\&    $obj = MyDBObject\->new(id => 123);
\&
\&    if($obj\->load_speculative)
\&    {
\&      print "Found object id 123\en";
\&    }
\&    else
\&    {
\&      print "Object id 123 not found\en";
\&    }
.Ve
.SS "new_from_json \s-1JSON\s0"
.IX Subsection "new_from_json JSON"
The method is the equivalent of creating a new object and then calling the init_with_json method on it, passing \s-1JSON\s0 as an argument.  See the init_with_json method for more information.
.SS "new_from_deflated_tree \s-1TREE\s0"
.IX Subsection "new_from_deflated_tree TREE"
The method is the equivalent of creating a new object and then calling the init_with_deflated_tree method on it, passing \s-1TREE\s0 as an argument.  See the init_with_deflated_tree method for more information.
.SS "new_from_tree \s-1TREE\s0"
.IX Subsection "new_from_tree TREE"
The method is the equivalent of creating a new object and then calling the init_with_tree method on it, passing \s-1TREE\s0 as an argument.  See the init_with_tree method for more information.
.SS "new_from_yaml \s-1YAML\s0"
.IX Subsection "new_from_yaml YAML"
The method is the equivalent of creating a new object and then calling the init_with_yaml method on it, passing \s-1YAML\s0 as an argument.  See the init_with_yaml method for more information.
.SS "strip [\s-1PARAMS\s0]"
.IX Subsection "strip [PARAMS]"
This method prepares an object for serialization by stripping out internal structures known to contain code references or other values that do not survive serialization.  The object itself is returned, now stripped.
.PP
\&\fBNote:\fR Operations that were scheduled to happen "on \fIsave()\fR" will \fIalso\fR be stripped out by this method.  Examples include the databsae update or insertion of any child objects attached to the parent object using \f(CW\*(C`get_set_on_save\*(C'\fR, \f(CW\*(C`add_on_save\*(C'\fR, or \f(CW\*(C`delete_on_save\*(C'\fR methods.  If such operations exist, an exception will be thrown unless the \f(CW\*(C`strip_on_save_ok\*(C'\fR parameter is true.
.PP
If your object has these kinds of pending changes, either \fIsave()\fR first and then \fIstrip()\fR, or \fIclone()\fR and then \fIstrip()\fR the clone.
.PP
By default, the db object and all sub-objects (foreign keys or relationships) are removed.  \s-1PARAMS\s0 are optional name/value pairs.  Valid \s-1PARAMS\s0 are:
.IP "\fBleave [ \s-1NAME\s0  | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "leave [ NAME  | ARRAYREF ]"
This parameter specifies which items to leave un-stripped.  The value may be an item name or a reference to an array of item names.  Valid names are:
.RS 4
.IP "\fBdb\fR" 4
.IX Item "db"
Do not remove the db object.  The db object will have its \s-1DBI\s0 database handle (dbh) removed, however.
.IP "\fBforeign_keys\fR" 4
.IX Item "foreign_keys"
Do not removed sub-objects that have already been loaded by this object through foreign keys.
.IP "\fBrelationships\fR" 4
.IX Item "relationships"
Do not removed sub-objects that have already been loaded by this object through relationships.
.IP "\fBrelated_objects\fR" 4
.IX Item "related_objects"
Do not remove any sub-objects (foreign keys or relationships) that have already been loaded by this object.  This option is the same as specifying both the \f(CW\*(C`foreign_keys\*(C'\fR and \f(CW\*(C`relationships\*(C'\fR names.
.RE
.RS 4
.RE
.IP "\fBstrip_on_save_ok \s-1BOOL\s0\fR" 4
.IX Item "strip_on_save_ok BOOL"
If true, do not throw an exception when pending \*(L"on-save\*(R" changes exist in the object; just strip them.  (See description above for details.)
.SS "\fBtraverse_depth_first [ \s-1CODEREF\s0 | \s-1PARAMS\s0 ]\fP"
.IX Subsection "traverse_depth_first [ CODEREF | PARAMS ]"
Do a depth-first traversal of the Rose::DB::Object\-derived object that this method is called on, descending into related objects. If a reference to a subroutine is passed as the sole argument, it is taken as the value of the \f(CW\*(C`object\*(C'\fR key to the \f(CW\*(C`handlers\*(C'\fR parameter hash (see below).  Otherwise, \s-1PARAMS\s0 name/value pairs are expected.  Valid parameters are:
.IP "\fBallow_loops \s-1BOOL\s0\fR" 4
.IX Item "allow_loops BOOL"
If true, allow loops during the traversal (e.g., A \-> B \-> C \-> A).  The default value is false.
.IP "\fBcontext \s-1SCALAR\s0\fR" 4
.IX Item "context SCALAR"
An arbitrary context variable to be passed along to (and possibly modified by) each handler routine (see \f(CW\*(C`handlers\*(C'\fR parameter below).  The context may be any scalar value (e.g., an object, a reference to a hash, etc.)
.IP "\fBexclude \s-1CODEREF\s0\fR" 4
.IX Item "exclude CODEREF"
A reference to a subroutine that is called on each Rose::DB::Object\-derived object encountered during the traversal.  It is passed the object, the parent object (undef, if none), and the  Rose::DB::Object::Metadata::Relationship\-derived object (undef, if none) that led to this object.  If the subroutine returns true, then this object is not processed.  Example:
.Sp
.Vb 7
\&    exclude => sub
\&    {
\&      my($object, $parent, $rel_meta) = @_;
\&      ...
\&      return 1  if($should_exclude);
\&      return 0;
\&    },
.Ve
.IP "\fBforce_load \s-1BOOL\s0\fR" 4
.IX Item "force_load BOOL"
If true, related sub-objects will be loaded from the database.  If false, then only the sub-objects that have already been loaded from the database will be traversed.  The default is false.
.IP "\fBhandlers \s-1HASHREF\s0\fR" 4
.IX Item "handlers HASHREF"
A reference to a hash of handler subroutines.  Valid keys, calling context, and the arguments passed to the referenced subroutines are as follows.
.RS 4
.IP "\fBobject\fR" 4
.IX Item "object"
This handler is called whenever a Rose::DB::Object\-derived object is encountered.  This includes the object that traverse_depth_first was called on as well as any sub-objects.  The handler is passed the object, the \f(CW\*(C`context\*(C'\fR, the parent object (undef, if none), the Rose::DB::Object::Metadata::Relationship\-derived object through which this object was arrived at (undef if none), and the depth.
.Sp
The handler \fImust\fR return the value to be used as the \f(CW\*(C`context\*(C'\fR during the traversal of any related sub-objects.  The context returned may be different than the context passed in.  Example:
.Sp
.Vb 6
\&    handlers =>
\&    {
\&      object => sub
\&      {
\&        my($object, $context, $parent, $rel_meta, $depth) = @_;
\&        ...
\&
\&        return $context; # Important!
\&      }
\&      ...
\&    }
.Ve
.IP "\fBrelationship\fR" 4
.IX Item "relationship"
This handler is called just before a Rose::DB::Object::Metadata::Relationship\-derived object is descended into  (i.e., just before the sub-objectes related through this relationship are processed). The handler is passed the object that contains the relationship, the \f(CW\*(C`context\*(C'\fR, the \f(CW\*(C`context\*(C'\fR, and the relationship object itself.
.Sp
The handler \fImust\fR return the value to be used as the \f(CW\*(C`context\*(C'\fR during the traversal of the objects related through this relationship.  (If you do not define this handler, then the current context object will be used.)  The context returned may be different than the context passed in.  Example:
.Sp
.Vb 6
\&    handlers =>
\&    {
\&      relationship => sub
\&      {
\&        my($object, $context, $rel_meta) = @_;
\&        ...
\&
\&        return $context; # Important!
\&      }
\&      ...
\&    }
.Ve
.IP "\fBloop_avoided\fR" 4
.IX Item "loop_avoided"
This handler is called after the traversal refuses to process a sub-object in order to avoid a loop.  (This only happens if the \f(CW\*(C`allow_loops\*(C'\fR is parameter is false, obviously.)  The handler is passed the object that was not processed, the \f(CW\*(C`context\*(C'\fR, the parent object, the \fIprevious\fR \f(CW\*(C`context\*(C'\fR, and the Rose::DB::Object::Metadata::Relationship\-derived object through which the sub-object was related.  Example:
.Sp
.Vb 9
\&    handlers =>
\&    {
\&      loop_avoided => sub
\&      {
\&        my($object, $context, $parent, $prev_context, $rel_meta) = @_;
\&        ...
\&      }
\&      ...
\&    }
.Ve
.RE
.RS 4
.RE
.IP "\fBmax_depth \s-1DEPTH\s0\fR" 4
.IX Item "max_depth DEPTH"
Do not descend past \s-1DEPTH\s0 levels.  Depth is an integer starting from 0 for the object that the traverse_depth_first method was called on and increasing with each level of related objects.  The default value is 100.
.IP "\fBprune \s-1CODEREF\s0\fR" 4
.IX Item "prune CODEREF"
A reference to a subroutine that is called on each Rose::DB::Object::Metadata::Relationship\-derived object encountered during traversal.  It is passed the relationship object, the parent object, and the depth.  If the subroutine returns true, then the entire sub-tree below this relationship will not be traversed.  Example:
.Sp
.Vb 7
\&    prune => sub
\&    {
\&      my($rel_meta, $object, $depth) = @_;
\&      ...
\&      return 1  if($should_prune);
\&      return 0;
\&    },
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
John C. Siracusa (siracusa@gmail.com)
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2010 by John C. Siracusa.  All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same terms
as Perl itself.
