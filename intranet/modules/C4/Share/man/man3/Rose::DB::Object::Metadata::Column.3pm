.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Rose::DB::Object::Metadata::Column 3"
.TH Rose::DB::Object::Metadata::Column 3 "2011-11-21" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Rose::DB::Object::Metadata::Column \- Base class for database column metadata objects.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package MyColumnType;
\&
\&  use Rose::DB::Object::Metadata::Column;
\&  our @ISA = qw(Rose::DB::Object::Metadata::Column);
\&  ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the base class for objects that store and manipulate database column metadata.  Column metadata objects store information about columns (data type, size, etc.) and are responsible for parsing, formatting, and creating object methods that manipulate column values.
.PP
Rose::DB::Object::Metadata::Column objects stringify to the value returned by the name method.  This allows full-blown column objects to be used in place of column name strings in most situations.
.SS "\s-1MAKING\s0 \s-1METHODS\s0"
.IX Subsection "MAKING METHODS"
A Rose::DB::Object::Metadata::Column\-derived object is responsible for creating object methods that manipulate column values.  Each column object can make zero or more methods for each available column method type.  A column method type describes the purpose of a method.  The default column method types are:
.ie n .IP """get_set""" 4
.el .IP "\f(CWget_set\fR" 4
.IX Item "get_set"
A method that can both get and set the column value.  If an argument is passed, then the column value is set.  In either case, the current column value is returned.
.ie n .IP """get""" 4
.el .IP "\f(CWget\fR" 4
.IX Item "get"
A method that returns the current column value.
.ie n .IP """set""" 4
.el .IP "\f(CWset\fR" 4
.IX Item "set"
A method that sets the column value.
.PP
Methods are created by calling make_methods.  A list of method types can be passed to the call to make_methods.  If absent, the list of method types is determined by the auto_method_types method.  A list of all possible method types is available through the available_method_types method.
.PP
These methods make up the \*(L"public\*(R" interface to column method creation.  There are, however, several \*(L"protected\*(R" methods which are used internally to implement the methods described above.  (The word \*(L"protected\*(R" is used here in a vaguely \*(C+ sense, meaning \*(L"accessible to subclasses, but not to the public.\*(R")  Subclasses will probably find it easier to override and/or call these protected methods in order to influence the behavior of the \*(L"public\*(R" method maker methods.
.PP
A Rose::DB::Object::Metadata::Column object delegates method creation to a  Rose::Object::MakeMethods\-derived class.  Each Rose::Object::MakeMethods\-derived class has its own set of method types, each of which takes it own set of arguments.
.PP
Using this system, four pieces of information are needed to create a method on behalf of a Rose::DB::Object::Metadata::Column\-derived object:
.IP "\(bu" 4
The \fBcolumn method type\fR (e.g., \f(CW\*(C`get_set\*(C'\fR, \f(CW\*(C`get\*(C'\fR, \f(CW\*(C`set\*(C'\fR)
.IP "\(bu" 4
The \fBmethod maker class\fR (e.g., Rose::DB::Object::MakeMethods::Generic)
.IP "\(bu" 4
The \fBmethod maker method type\fR (e.g., scalar)
.IP "\(bu" 4
The \fBmethod maker arguments\fR (e.g., \f(CW\*(C`interface => \*(Aqget_set_init\*(Aq\*(C'\fR)
.PP
This information can be organized conceptually into a \*(L"method map\*(R" that connects a column method type to a method maker class and, finally, to one particular method type within that class, and its arguments.
.PP
The default method map is:
.ie n .IP """get_set""" 4
.el .IP "\f(CWget_set\fR" 4
.IX Item "get_set"
Rose::DB::Object::MakeMethods::Generic, scalar, \f(CW\*(C`interface => \*(Aqget_set\*(Aq, ...\*(C'\fR
.ie n .IP """get""" 4
.el .IP "\f(CWget\fR" 4
.IX Item "get"
Rose::DB::Object::MakeMethods::Generic, scalar, \f(CW\*(C`interface => \*(Aqget\*(Aq, ...\*(C'\fR
.ie n .IP """set""" 4
.el .IP "\f(CWset\fR" 4
.IX Item "set"
Rose::DB::Object::MakeMethods::Generic, scalar, \f(CW\*(C`interface => \*(Aqset\*(Aq, ...\*(C'\fR
.PP
Each item in the map is a column method type.  For each column method type, the method maker class, the method maker method type, and the \*(L"interesting\*(R" method maker arguments are listed, in that order.
.PP
The \*(L"...\*(R" in the method maker arguments is meant to indicate that other arguments have been omitted.  For example, the column object's default value is passed as part of the arguments for all method types.  These arguments that are common to all column method types are routinely omitted from the method map for the sake of brevity.  If there are no \*(L"interesting\*(R" method maker arguments, then \*(L"...\*(R" may appear by itself.
.PP
The purpose of documenting the method map is to answer the question, \*(L"What kind of method(s) will be created by this column object for a given method type?\*(R"  Given the method map, it's possible to read the documentation for each method maker class to determine how methods of the specified type behave when passed the listed arguments.
.PP
To this end, each Rose::DB::Object::Metadata::Column\-derived class in the Rose::DB::Object module distribution will list its method map in its documentation.  This is a concise way to document the behavior that is specific to each column class, while omitting the common functionality (which is documented here, in the column base class).
.PP
Remember, the existence and behavior of the method map is really implementation detail.  A column object is free to implement the public method-making interface however it wants, without regard to any conceptual or actual method map.  It must then, of course, document what kinds of methods it makes for each of its method types, but it does not have to use a method map to do so.
.SS "\s-1TRIGGERS\s0"
.IX Subsection "TRIGGERS"
Triggers allow code to run in response to certain column-related events.  An event may trigger zero or more pieces of code.  The names and behaviors of the various kinds of events are as follows.
.IP "\fBon_get\fR" 4
.IX Item "on_get"
Triggered when a column value is retrieved for some purpose \fIother than\fR storage in the database.  For example, when end-user code retrieves a column value by calling an accessor method, this event is triggered.  This event is \fInot\fR triggered when a column value is retrieved while the object is being saved into the database.
.Sp
Each piece of code responding to an \f(CW\*(C`on_get\*(C'\fR event will be passed a single argument: a reference to the object itself.  The return value is not used.
.IP "\fBon_set\fR" 4
.IX Item "on_set"
Triggered when a column value is set to a value that came from somewhere \fIother than\fR  the database.  For example, when end-user code sets a column value by calling a mutator method, this event is triggered.  This event is \fInot\fR triggered when a column value is set while the object is being loaded from the database.
.Sp
The \f(CW\*(C`on_set\*(C'\fR event occurs \fIafter\fR the column value has been set.  Each piece of code responding to an \f(CW\*(C`on_set\*(C'\fR event will be passed a single argument: a reference to the object itself.  The return value is not used.
.IP "\fBon_load\fR" 4
.IX Item "on_load"
Triggered when a column value is set while an object is being loaded from the database.
.Sp
The \f(CW\*(C`on_load\*(C'\fR event occurs \fIafter\fR the column value has been loaded.  Each piece of code responding to an \f(CW\*(C`on_load\*(C'\fR event will be passed a single argument: a reference to the object itself.  The return value is not used.
.IP "\fBon_save\fR" 4
.IX Item "on_save"
Triggered when a column value is retrieved while an object is being saved into the database.
.Sp
Each piece of code responding to an \f(CW\*(C`on_save\*(C'\fR event will be passed a single argument: a reference to the object itself.  The return value is not used.
.IP "\fBinflate\fR" 4
.IX Item "inflate"
Triggered when a column value is retrieved for some purpose \fIother than\fR storage in the database.  For example, when end-user code retrieves a column value by calling an accessor method, and that value came directly from the database, this event is triggered.
.Sp
Inflation will only happen \*(L"as needed.\*(R"  That is, a value that has already been inflated will not be inflated again, and a value that comes from the database and goes back into it without ever being retrieved by end-user code will never be inflated at all.
.Sp
Each piece of code responding to an \f(CW\*(C`inflate\*(C'\fR event will be passed two arguments: a reference to the object itself and the value to be inflated.  It should return an inflated version of that value.  Note that the value to be inflated may have come from the database, or from end-user code.  Be prepared to handle almost anything.
.IP "\fBdeflate\fR" 4
.IX Item "deflate"
Triggered when a column value that did not come directly from the database needs to be put into the database.  For example, when a column value set by end-user code needs to be saved into the database, this event is triggered.
.Sp
Deflation will only happen \*(L"as needed.\*(R"  That is, a value that has already been deflated will not be deflated again, and a value that comes from the database and goes back into it without ever being retrieved by end-user code will never need to be deflated at all.
.Sp
Each piece of code responding to a \f(CW\*(C`deflate\*(C'\fR event will be passed two arguments: a reference to the object itself and the value to be deflated.  It should return a deflated version of that value suitable for saving into the currently connected database.  Note that the value to be deflated may have come from the database, or from end-user code.  Be prepared to handle almost anything.
.PP
All triggers are disabled while inside code called in response to a trigger event.  Such code may call any other column methods, including methods that belong to its own column, without fear of infinite recursion into trigger service subroutines.  Alternately, triggers may be explicitly enabled if desired.  Just watch out for infinite loops.
.PP
For performance reasons, none of the column classes bundled with Rose::DB::Object use triggers by default.  Some of them do inflate and deflate values, but they do so internally (inside the accessor and mutator methods created by the Rose::Object::MakeMethods\-derived classes that service those column types).  You can still add triggers to these column types, but the interaction between the internal inflate/deflate actions and the triggers for those same events can become a bit \*(L"non-obvious.\*(R"
.SH "CLASS METHODS"
.IX Header "CLASS METHODS"
.IP "\fBdefault_auto_method_types [\s-1TYPES\s0]\fR" 4
.IX Item "default_auto_method_types [TYPES]"
Get or set the default list of auto_method_types.  \s-1TYPES\s0 should be a list of column method types.  Returns the list of default column method types (in list context) or a reference to an array of the default column method types (in scalar context).  The default list contains only the \*(L"get_set\*(R" column method type.
.IP "\fBdefault_undef_overrides_default [\s-1BOOL\s0]\fR" 4
.IX Item "default_undef_overrides_default [BOOL]"
Get or set the default value of the undef_overrides_default attribute.  The default value is undef.
.Sp
This default only applies when the column does not have a parent metadata object or if the metadata object's column_undef_overrides_default method returns undef.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "\fBnew \s-1PARAMS\s0\fR" 4
.IX Item "new PARAMS"
Constructs a new object based on \s-1PARAMS\s0, where \s-1PARAMS\s0 are
name/value pairs.  Any object method is a valid parameter name.
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.IP "\fBaccessor_method_name\fR" 4
.IX Item "accessor_method_name"
Returns the name of the method used to get the column value.  This is a convenient shortcut for:
.Sp
.Vb 1
\&    $column\->method_name(\*(Aqget\*(Aq) || $column\->method_name(\*(Aqget_set\*(Aq);
.Ve
.IP "\fBadd_trigger [ \s-1EVENT\s0, \s-1CODEREF\s0 | \s-1PARAMS\s0 ]\fR" 4
.IX Item "add_trigger [ EVENT, CODEREF | PARAMS ]"
Add a trigger, as specified by either an event and a code reference, or a set of named parameters that include an event, a code reference, and an optional name and position for the trigger.
.Sp
If there are only two arguments, and the first is a valid event name, then the second must be a code reference.  Otherwise, the arguments are taken as named parameters.
.Sp
Valid parameters are:
.RS 4
.ie n .IP """code CODEREF""" 4
.el .IP "\f(CWcode CODEREF\fR" 4
.IX Item "code CODEREF"
A reference to a subroutine that will be called in response to a trigger event.  This parameter is required.  See the triggers section of this documentation for a description of the arguments to and return values expected from these routines for each type of event.
.ie n .IP """event EVENT""" 4
.el .IP "\f(CWevent EVENT\fR" 4
.IX Item "event EVENT"
The name of the event that activates this trigger.  This parameter is required.  Valid event names are \f(CW\*(C`on_get\*(C'\fR, \f(CW\*(C`on_set\*(C'\fR, \f(CW\*(C`on_load\*(C'\fR, \f(CW\*(C`on_save\*(C'\fR, \f(CW\*(C`inflate\*(C'\fR, and \f(CW\*(C`deflate\*(C'\fR.  See the triggers section of this documentation for more information on these event types.
.ie n .IP """name NAME""" 4
.el .IP "\f(CWname NAME\fR" 4
.IX Item "name NAME"
An optional name mapped to the triggered subroutine.  If a name is not supplied, one will be generated.  A known name is necessary if you ever want to delete a particular subroutine from the list of triggered subroutine for a given event.
.ie n .IP """position POS""" 4
.el .IP "\f(CWposition POS\fR" 4
.IX Item "position POS"
The position in the list of triggered subroutines to add this new code.  Triggered subroutines are kept in an ordered list.  By default, new triggers are added to the end of the list, which means they run last.  Valid position arguments are:
.RS 4
.ie n .IP """end"", ""last"", or ""push""" 4
.el .IP "\f(CWend\fR, \f(CWlast\fR, or \f(CWpush\fR" 4
.IX Item "end, last, or push"
Add to the end of the list.
.ie n .IP """start"", ""first"", or ""unshift""" 4
.el .IP "\f(CWstart\fR, \f(CWfirst\fR, or \f(CWunshift\fR" 4
.IX Item "start, first, or unshift"
Add to the beginning of the list.
.RE
.RS 4
.Sp
If omitted, the position defaults to \*(L"end.\*(R"
.RE
.RE
.RS 4
.Sp
Examples:
.Sp
.Vb 2
\&    # Add trigger using an event name and a code reference
\&    $column\->add_trigger(on_set => sub { print "set!\en" });
\&
\&    # Same as above, but using named parameters
\&    $column\->add_trigger(event => \*(Aqon_set\*(Aq,
\&                         code  => sub { print "set!\en" });
\&
\&    # Same as the above, but with a custom name and explicit position
\&    $column\->add_trigger(event    => \*(Aqon_set\*(Aq,
\&                         code     => sub { print "set!\en" },
\&                         name     => \*(Aqdebugging\*(Aq,
\&                         position => \*(Aqend\*(Aq);
.Ve
.RE
.IP "\fBalias [\s-1NAME\s0]\fR" 4
.IX Item "alias [NAME]"
Get or set an alternate name for this column.
.IP "\fBavailable_method_types\fR" 4
.IX Item "available_method_types"
Returns the full list of column method types supported by this class.
.IP "\fBauto_method_types [\s-1TYPES\s0]\fR" 4
.IX Item "auto_method_types [TYPES]"
Get or set the list of column method types that are automatically created when make_methods is called without an explicit list of column method types.  The default list is determined by the default_auto_method_types class method.
.IP "\fBbuild_method_name_for_type \s-1TYPE\s0\fR" 4
.IX Item "build_method_name_for_type TYPE"
Return a method name for the column method type \s-1TYPE\s0.  The default implementation returns the column's alias (if defined) or name for the method type \*(L"get_set\*(R", and the same thing with a \*(L"get_\*(R" or \*(L"set_\*(R" prefix for the \*(L"get\*(R" and \*(L"set\*(R" column method types, respectively.
.IP "\fBdefault [\s-1VALUE\s0]\fR" 4
.IX Item "default [VALUE]"
Get or set the default value of the column.
.IP "\fBdefault_exists\fR" 4
.IX Item "default_exists"
Returns true if a default value exists for this column (even if it is undef), false otherwise.
.IP "\fBdelete_default\fR" 4
.IX Item "delete_default"
Deletes the default value for this column.
.IP "\fBdelete_trigger \s-1PARAMS\s0\fR" 4
.IX Item "delete_trigger PARAMS"
Delete a triggered subroutine from the list of triggered subroutines for a given event.  You must know the name applied to the triggered subroutine when it was added in order to delete it.  \s-1PARAMS\s0 are name/value pairs.
.RS 4
.ie n .IP """name NAME""" 4
.el .IP "\f(CWname NAME\fR" 4
.IX Item "name NAME"
The name applied to the triggered subroutine when it was added via the added method.  This parameter is required.
.ie n .IP """event EVENT""" 4
.el .IP "\f(CWevent EVENT\fR" 4
.IX Item "event EVENT"
The name of the event that activates this trigger.  This parameter is required.  Valid event names are \f(CW\*(C`on_get\*(C'\fR, \f(CW\*(C`on_set\*(C'\fR, \f(CW\*(C`on_load\*(C'\fR, \f(CW\*(C`on_save\*(C'\fR, \f(CW\*(C`inflate\*(C'\fR, and \f(CW\*(C`deflate\*(C'\fR.  See the triggers section of this documentation for more information on these event types.
.RE
.RS 4
.Sp
A fatal error will occur if a matching trigger cannot be found.
.Sp
Examples:
.Sp
.Vb 4
\&    # Add two named triggers
\&    $column\->add_trigger(event => \*(Aqon_set\*(Aq,
\&                         code  => sub { print "set!\en" },
\&                         name  => \*(Aqdebugging\*(Aq);
\&
\&    $column\->add_trigger(event => \*(Aqon_set\*(Aq,
\&                         code  => sub { shift\->do_something() },
\&                         name  => \*(Aqside_effect\*(Aq);
\&
\&    # Delete the side_effect trigger
\&    $column\->delete_trigger(event => \*(Aqon_set\*(Aq,
\&                            name  => \*(Aqside_effect\*(Aq);
\&
\&    # Fatal error: no trigger subroutine for this column
\&    # named "nonesuch" for the event type "on_set"
\&    $column\->delete_trigger(event => \*(Aqon_set\*(Aq,
\&                            name  => \*(Aqnonesuch\*(Aq);
.Ve
.RE
.IP "\fBdelete_triggers [\s-1EVENT\s0]\fR" 4
.IX Item "delete_triggers [EVENT]"
Delete all triggers for \s-1EVENT\s0.  If \s-1EVENT\s0 is omitted, delete all triggers for all events for this column.
.Sp
Valid event names are \f(CW\*(C`on_get\*(C'\fR, \f(CW\*(C`on_set\*(C'\fR, \f(CW\*(C`on_load\*(C'\fR, \f(CW\*(C`on_save\*(C'\fR, \f(CW\*(C`inflate\*(C'\fR, and \f(CW\*(C`deflate\*(C'\fR.  See the triggers section of this documentation for more information on these event types.
.IP "\fBdisable_triggers\fR" 4
.IX Item "disable_triggers"
Disable all triggers for this column.
.IP "\fBenable_triggers\fR" 4
.IX Item "enable_triggers"
Enable all triggers for this column.
.IP "\fBformat_value \s-1DB\s0, \s-1VALUE\s0\fR" 4
.IX Item "format_value DB, VALUE"
Convert \s-1VALUE\s0 into a string suitable for the database column of this type.  \s-1VALUE\s0 is expected to be like the return value of the parse_value method.  \s-1DB\s0 is a Rose::DB object that may be used as part of the parsing process.  Both arguments are required.
.IP "\fBis_primary_key_member [\s-1BOOL\s0]\fR" 4
.IX Item "is_primary_key_member [BOOL]"
Get or set the boolean flag that indicates whether or not this column is part of the primary key for its table.
.IP "\fBload_on_demand [\s-1BOOL\s0]\fR" 4
.IX Item "load_on_demand [BOOL]"
Get or set a boolean value that indicates whether or not a column's value should be loaded only when needed.  If true, then the column's value will not automatically be fetched from the database when an object is loaded.  It will be fetched only if the column value is subsequently requested through its accessor method.  (This is often referred to as \*(L"lazy loading.\*(R")  The default value is false.
.Sp
Note: a column that is part of a primary key cannot be loaded on demand.
.IP "\fBlazy [\s-1BOOL\s0]\fR" 4
.IX Item "lazy [BOOL]"
This is an alias for the load_on_demand method.  It exists to allow this common usage scenario:
.Sp
.Vb 5
\&    _\|_PACKAGE_\|_\->meta\->columns
\&    (
\&      ...
\&      notes => { type => \*(Aqtext\*(Aq, length => 1024, lazy => 1 },
\&    );
.Ve
.Sp
without requiring the longer \f(CW\*(C`load_on_demand\*(C'\fR parameter name to be used.
.IP "\fBmake_methods \s-1PARAMS\s0\fR" 4
.IX Item "make_methods PARAMS"
Create object method used to manipulate column values.  \s-1PARAMS\s0 are name/value pairs.  Valid \s-1PARAMS\s0 are:
.RS 4
.ie n .IP """preserve_existing BOOL""" 4
.el .IP "\f(CWpreserve_existing BOOL\fR" 4
.IX Item "preserve_existing BOOL"
Boolean flag that indicates whether or not to preserve existing methods in the case of a name conflict.
.ie n .IP """replace_existing BOOL""" 4
.el .IP "\f(CWreplace_existing BOOL\fR" 4
.IX Item "replace_existing BOOL"
Boolean flag that indicates whether or not to replace existing methods in the case of a name conflict.
.ie n .IP """target_class CLASS""" 4
.el .IP "\f(CWtarget_class CLASS\fR" 4
.IX Item "target_class CLASS"
The class in which to make the method(s).  If omitted, it defaults to the calling class.
.ie n .IP """types ARRAYREF""" 4
.el .IP "\f(CWtypes ARRAYREF\fR" 4
.IX Item "types ARRAYREF"
A reference to an array of column method types to be created.  If omitted, it defaults to the list of column method types returned by auto_method_types.
.RE
.RS 4
.Sp
If any of the methods could not be created for any reason, a fatal error will occur.
.RE
.IP "\fBmanager_uses_method [\s-1BOOL\s0]\fR" 4
.IX Item "manager_uses_method [BOOL]"
If true, then Rose::DB::Object::QueryBuilder will pass column values through the object method(s) associated with this column when composing \s-1SQL\s0 queries where \f(CW\*(C`query_is_sql\*(C'\fR is not set.  The default value is false.  See the Rose::DB::Object::QueryBuilder documentation for more information.
.Sp
Note: the method is named \*(L"manager_uses_method\*(R" instead of, say, \*(L"query_builder_uses_method\*(R" because Rose::DB::Object::QueryBuilder is rarely used directly.  Instead, it's mostly used indirectly through the Rose::DB::Object::Manager class.
.IP "\fBmethod_name \s-1TYPE\s0 [, \s-1NAME\s0]\fR" 4
.IX Item "method_name TYPE [, NAME]"
Get or set the name of the column method of type \s-1TYPE\s0.
.IP "\fBmutator_method_name\fR" 4
.IX Item "mutator_method_name"
Returns the name of the method used to set the column value.  This is a convenient shortcut for:
.Sp
.Vb 1
\&    $column\->method_name(\*(Aqset\*(Aq) || $column\->method_name(\*(Aqget_set\*(Aq);
.Ve
.IP "\fBname [\s-1NAME\s0]\fR" 4
.IX Item "name [NAME]"
Get or set the name of the column, not including the table name, username, schema, or any other qualifier.
.IP "\fBnonpersistent [\s-1BOOL\s0]\fR" 4
.IX Item "nonpersistent [BOOL]"
Get or set a boolean flag that indicates whether or not the column 
is non-persistent.
.IP "\fBnot_null [\s-1BOOL\s0]\fR" 4
.IX Item "not_null [BOOL]"
Get or set a boolean flag that indicates whether or not the column 
value can can be null.
.IP "\fBparse_value \s-1DB\s0, \s-1VALUE\s0\fR" 4
.IX Item "parse_value DB, VALUE"
Parse and return a convenient Perl representation of \s-1VALUE\s0.  What form this value will take is up to the column subclass.  If \s-1VALUE\s0 is a keyword or otherwise has special meaning to the underlying database, it may be returned unmodified.  \s-1DB\s0 is a Rose::DB object that may be used as part of the parsing process.  Both arguments are required.
.IP "\fBprimary_key_position [\s-1INT\s0]\fR" 4
.IX Item "primary_key_position [INT]"
Get or set the column's ordinal position in the primary key.  Returns undef if the column is not part of the primary key.  Position numbering starts from 1.
.IP "\fBremarks [\s-1TEXT\s0]\fR" 4
.IX Item "remarks [TEXT]"
Get or set a text description of the column.
.IP "\fBrw_method_name\fR" 4
.IX Item "rw_method_name"
Returns the name of the method used to get or set the column value.  This is a convenient shortcut for:
.Sp
.Vb 1
\&    $column\->method_name(\*(Aqget_set\*(Aq);
.Ve
.IP "\fBshould_inline_value \s-1DB\s0, \s-1VALUE\s0\fR" 4
.IX Item "should_inline_value DB, VALUE"
Given the Rose::DB\-derived object \s-1DB\s0 and the column value \s-1VALUE\s0, return true of the value should be \*(L"inlined\*(R" (i.e., not bound to a \*(L"?\*(R" placeholder and passed as an argument to \s-1DBI\s0's execute method), false otherwise.  The default implementation always returns false.
.Sp
This method is necessary because some \s-1DBI\s0 drivers do not (or cannot) always do the right thing when binding values to placeholders in \s-1SQL\s0 statements.  For example, consider the following \s-1SQL\s0 for the Informix database:
.Sp
.Vb 2
\&    CREATE TABLE test (d DATETIME YEAR TO SECOND);
\&    INSERT INTO test (d) VALUES (CURRENT);
.Ve
.Sp
This is valid Informix \s-1SQL\s0 and will insert a row with the current date and time into the \*(L"test\*(R" table.
.Sp
Now consider the following attempt to do the same thing using \s-1DBI\s0 placeholders (assume the table was already created as per the \s-1CREATE\s0 \s-1TABLE\s0 statement above):
.Sp
.Vb 2
\&    $sth = $dbh\->prepare(\*(AqINSERT INTO test (d) VALUES (?)\*(Aq);
\&    $sth\->execute(\*(AqCURRENT\*(Aq); # Error!
.Ve
.Sp
What you'll end up with is an error like this:
.Sp
.Vb 2
\&    DBD::Informix::st execute failed: SQL: \-1262: Non\-numeric 
\&    character in datetime or interval.
.Ve
.Sp
In other words, DBD::Informix has tried to quote the string \*(L"\s-1CURRENT\s0\*(R", which has special meaning to Informix only when it is not quoted.
.Sp
In order to make this work, the value \*(L"\s-1CURRENT\s0\*(R" must be \*(L"inlined\*(R" rather than bound to a placeholder when it is the value of a \*(L"\s-1DATETIME\s0 \s-1YEAR\s0 \s-1TO\s0 \s-1SECOND\s0\*(R" column in an Informix database.
.Sp
All of the information needed to make this decision is available to the call to should_inline_value.  It gets passed a Rose::DB\-derived object, from which it can determine the database driver, and it gets passed the actual value, which it can check to see if it matches \f(CW\*(C`/^current$/i\*(C'\fR.
.Sp
This is just one example.  Each subclass of Rose::DB::Object::Metadata::Column must determine for itself when a value needs to be inlined.
.IP "\fBtriggers \s-1EVENT\s0 [, \s-1CODEREF\s0 | \s-1ARRAYREF\s0 ]\fR" 4
.IX Item "triggers EVENT [, CODEREF | ARRAYREF ]"
Get or set the list of trigger subroutines for \s-1EVENT\s0.  Valid event names are \f(CW\*(C`on_get\*(C'\fR, \f(CW\*(C`on_set\*(C'\fR, \f(CW\*(C`on_load\*(C'\fR, \f(CW\*(C`on_save\*(C'\fR, \f(CW\*(C`inflate\*(C'\fR, and \f(CW\*(C`deflate\*(C'\fR.  See the triggers section of this documentation for more information on these event types.
.Sp
If passed a code ref or a reference to an array of code refs, then the list of trigger subroutines for \s-1EVENT\s0 is replaced with those code ref(s).
.Sp
Returns a reference to an array of trigger subroutines for the event type \s-1EVENT\s0.  If there are no triggers for \s-1EVENT\s0, undef will be returned.
.IP "\fBtriggers_disabled\fR" 4
.IX Item "triggers_disabled"
Returns true if triggers are disabled for this column, false otherwise.
.IP "\fBtype\fR" 4
.IX Item "type"
Returns the (possibly abstract) data type of the column.  The default implementation returns \*(L"scalar\*(R".
.IP "\fBundef_overrides_default [\s-1BOOL\s0]\fR" 4
.IX Item "undef_overrides_default [BOOL]"
Get or set a boolean value that indicates whether or not setting the column to an undef value overrides the column's default value.
.Sp
The default value of this attribute is determined by the parent metadata object's column_undef_overrides_default method, or the column's default_undef_overrides_default class method id the metadata object's column_undef_overrides_default method returns undef, or if the column has no parent metadata object.
.Sp
Example: consider a Rose::DB::Object\-derived \f(CW\*(C`Person\*(C'\fR class with a \f(CW\*(C`name\*(C'\fR column set up like this:
.Sp
.Vb 8
\&    package Person;
\&    ...
\&       columns =>
\&       [
\&         name => { type => \*(Aqvarchar\*(Aq, default => \*(AqJohn Doe\*(Aq },
\&         ...
\&       ],
\&    ...
.Ve
.Sp
The following behavior is the same regardless of the setting of the undef_overrides_default attribute for the \f(CW\*(C`name\*(C'\fR column:
.Sp
.Vb 2
\&    $p = Person\->new;
\&    print $p\->name; # John Doe
\&
\&    $p\->name(\*(AqLarry Wall\*(Aq);
\&    print $p\->name; # Larry Wall
.Ve
.Sp
If undef_overrides_default is \fBfalse\fR for the \f(CW\*(C`name\*(C'\fR column, then this is the behavior of explicitly setting the column to undef:
.Sp
.Vb 2
\&    $p\->name(undef);
\&    print $p\->name; # John Doe
.Ve
.Sp
If undef_overrides_default is \fBtrue\fR for the \f(CW\*(C`name\*(C'\fR column, then this is the behavior of explicitly setting the column to undef:
.Sp
.Vb 2
\&    $p\->name(undef);
\&    print $p\->name; # undef
.Ve
.Sp
The undef_overrides_default attribute can be set directly on the column:
.Sp
.Vb 2
\&    name => { type => \*(Aqvarchar\*(Aq, default => \*(AqJohn Doe\*(Aq, 
\&              undef_overrides_default => 1 },
.Ve
.Sp
or it can be set class-wide using the meta object's column_undef_overrides_default attribute:
.Sp
.Vb 1
\&    Person\->meta\->column_undef_overrides_default(1);
.Ve
.Sp
or it can be set for all classes that use a given Rose::DB::Object::Metadata\-derived class using the default_column_undef_overrides_default class method:
.Sp
.Vb 1
\&    My::DB::Object::Metadata\->default_column_undef_overrides_default(1);
.Ve
.SH "PROTECTED API"
.IX Header "PROTECTED API"
These methods are not part of the public interface, but are supported for use by subclasses.  Put another way, given an unknown object that \*(L"isa\*(R" Rose::DB::Object::Metadata::Column, there should be no expectation that the following methods exist.  But subclasses, which know the exact class from which they inherit, are free to use these methods in order to implement the public \s-1API\s0 described above.
.IP "\fBmethod_maker_arguments \s-1TYPE\s0\fR" 4
.IX Item "method_maker_arguments TYPE"
Returns a hash (in list context) or reference to a hash (in scalar context) of name/value arguments that will be passed to the method_maker_class when making the column method type \s-1TYPE\s0.
.IP "\fBmethod_maker_class \s-1TYPE\s0 [, \s-1CLASS\s0]\fR" 4
.IX Item "method_maker_class TYPE [, CLASS]"
If \s-1CLASS\s0 is passed, the name of the Rose::Object::MakeMethods\-derived class used to create the object method of type \s-1TYPE\s0 is set to \s-1CLASS\s0.
.Sp
Returns the name of the Rose::Object::MakeMethods\-derived class used to create the object method of type \s-1TYPE\s0.
.IP "\fBmethod_maker_type \s-1TYPE\s0 [, \s-1NAME\s0]\fR" 4
.IX Item "method_maker_type TYPE [, NAME]"
If \s-1NAME\s0 is passed, the name of the method maker method type for the column method type \s-1TYPE\s0 is set to \s-1NAME\s0.
.Sp
Returns the method maker method type for the column method type \s-1TYPE\s0.
.SH "AUTHOR"
.IX Header "AUTHOR"
John C. Siracusa (siracusa@gmail.com)
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 2010 by John C. Siracusa.  All rights reserved.  This program is
free software; you can redistribute it and/or modify it under the same terms
as Perl itself.
