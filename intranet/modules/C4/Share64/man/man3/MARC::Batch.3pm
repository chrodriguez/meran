.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.19)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MARC::Batch 3"
.TH MARC::Batch 3 "2010-03-29" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MARC::Batch \- Perl module for handling files of MARC::Record objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
MARC::Batch hides all the file handling of files of \f(CW\*(C`MARC::Record\*(C'\fRs.
\&\f(CW\*(C`MARC::Record\*(C'\fR still does the file I/O, but \f(CW\*(C`MARC::Batch\*(C'\fR handles the
multiple-file aspects.
.PP
.Vb 1
\&    use MARC::Batch;
\&
\&    # If you have werid control fields...
\&    use MARC::Field;
\&    MARC::Field\->allow_controlfield_tags(\*(AqFMT\*(Aq, \*(AqLDX\*(Aq);    
\&    
\&
\&    my $batch = MARC::Batch\->new( \*(AqUSMARC\*(Aq, @files );
\&    while ( my $marc = $batch\->next ) {
\&        print $marc\->subfield(245,"a"), "\en";
\&    }
.Ve
.SH "EXPORT"
.IX Header "EXPORT"
None.  Everything is a class method.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "new( $type, @files )"
.el .SS "new( \f(CW$type\fP, \f(CW@files\fP )"
.IX Subsection "new( $type, @files )"
Create a \f(CW\*(C`MARC::Batch\*(C'\fR object that will process \f(CW@files\fR.
.PP
\&\f(CW$type\fR must be either \*(L"\s-1USMARC\s0\*(R" or \*(L"MicroLIF\*(R".  If you want to specify
\&\*(L"MARC::File::USMARC\*(R" or \*(L"MARC::File::MicroLIF\*(R", that's \s-1OK\s0, too. \f(CW\*(C`new()\*(C'\fR returns a
new MARC::Batch object.
.PP
\&\f(CW@files\fR can be a list of filenames:
.PP
.Vb 1
\&    my $batch = MARC::Batch\->new( \*(AqUSMARC\*(Aq, \*(Aqfile1.marc\*(Aq, \*(Aqfile2.marc\*(Aq );
.Ve
.PP
Your \f(CW@files\fR may also contain filehandles. So if you've got a large
file that's gzipped you can open a pipe to \fIgzip\fR and pass it in:
.PP
.Vb 2
\&    my $fh = IO::File\->new( \*(Aqgunzip \-c marc.dat.gz |\*(Aq );
\&    my $batch = MARC::Batch\->new( \*(AqUSMARC\*(Aq, $fh );
.Ve
.PP
And you can mix and match if you really want to:
.PP
.Vb 1
\&    my $batch = MARC::Batch\->new( \*(AqUSMARC\*(Aq, $fh, \*(Aqfile1.marc\*(Aq );
.Ve
.SS "\fInext()\fP"
.IX Subsection "next()"
Read the next record from that batch, and return it as a MARC::Record
object.  If the current file is at \s-1EOF\s0, close it and open the next
one. \f(CW\*(C`next()\*(C'\fR will return \f(CW\*(C`undef\*(C'\fR when there is no more data to be
read from any batch files.
.PP
By default, \f(CW\*(C`next()\*(C'\fR also will return \f(CW\*(C`undef\*(C'\fR if an error is
encountered while reading from the batch. If not checked for this can
cause your iteration to terminate prematurely. To alter this behavior,
see \f(CW\*(C`strict_off()\*(C'\fR. You can retrieve warning messages using the
\&\f(CW\*(C`warnings()\*(C'\fR method.
.PP
Optionally you can pass in a filter function as a subroutine reference
if you are only interested in particular fields from the record. This
can boost performance.
.SS "\fIstrict_off()\fP"
.IX Subsection "strict_off()"
If you would like \f(CW\*(C`MARC::Batch\*(C'\fR to continue after it has encountered what
it believes to be bad \s-1MARC\s0 data then use this method to turn strict \fB\s-1OFF\s0\fR.
A call to \f(CW\*(C`strict_off()\*(C'\fR always returns true (1).
.PP
\&\f(CW\*(C`strict_off()\*(C'\fR can be handy when you don't care about the quality of your
\&\s-1MARC\s0 data, and just want to plow through it. For safety, \f(CW\*(C`MARC::Batch\*(C'\fR
strict is \fB\s-1ON\s0\fR by default.
.SS "\fIstrict_on()\fP"
.IX Subsection "strict_on()"
The opposite of \f(CW\*(C`strict_off()\*(C'\fR, and the default state. You shouldn't
have to use this method unless you've previously used \f(CW\*(C`strict_off()\*(C'\fR, and
want it back on again.  When strict is \fB\s-1ON\s0\fR calls to \fInext()\fR will return
undef when an error is encountered while reading \s-1MARC\s0 data. \fIstrict_on()\fR
always returns true (1).
.SS "\fIwarnings()\fP"
.IX Subsection "warnings()"
Returns a list of warnings that have accumulated while processing a particular
batch file. As a side effect the warning buffer will be cleared.
.PP
.Vb 1
\&    my @warnings = $batch\->warnings();
.Ve
.PP
This method is also used internally to set warnings, so you probably don't
want to be passing in anything as this will set warnings on your batch object.
.PP
\&\f(CW\*(C`warnings()\*(C'\fR will return the empty list when there are no warnings.
.SS "\fIwarnings_off()\fP"
.IX Subsection "warnings_off()"
Turns off the default behavior of printing warnings to \s-1STDERR\s0. However, even
with warnings off the messages can still be retrieved using the \fIwarnings()\fR
method if you wish to check for them.
.PP
\&\f(CW\*(C`warnings_off()\*(C'\fR always returns true (1).
.SS "\fIwarnings_on()\fP"
.IX Subsection "warnings_on()"
Turns on warnings so that diagnostic information is printed to \s-1STDERR\s0. This
is on by default so you shouldn't have to use it unless you've previously
turned off warnings using \fIwarnings_off()\fR.
.PP
\&\fIwarnings_on()\fR always returns true (1).
.SS "\fIfilename()\fP"
.IX Subsection "filename()"
Returns the currently open filename or \f(CW\*(C`undef\*(C'\fR if there is not currently a file
open on this batch object.
.SH "RELATED MODULES"
.IX Header "RELATED MODULES"
MARC::Record, MARC::Lint
.SH "TODO"
.IX Header "TODO"
None yet.  Send me your ideas and needs.
.SH "LICENSE"
.IX Header "LICENSE"
This code may be distributed under the same terms as Perl itself.
.PP
Please note that these modules are not products of or supported by the
employers of the various contributors to the code.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Lester, \f(CW\*(C`<andy@petdance.com>\*(C'\fR
