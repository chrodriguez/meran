/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2002 from the
 * contents of Aspell.xs. Do not edit this file, edit Aspell.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Aspell.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include <aspell.h>

#define MAX_ERRSTR_LEN 1000

typedef struct {
    AspellCanHaveError  *ret;
    AspellSpeller       *speller;
    AspellConfig        *config;
    char                lastError[MAX_ERRSTR_LEN+1];
    int                 errnum;  /* Deprecated  - only returns 0/1 */
} Aspell_object;


static int _create_speller(Aspell_object *self)
{
    AspellCanHaveError *ret;

    ret = new_aspell_speller(self->config);


    if ( (self->errnum = aspell_error_number(ret) ) )
    {
        strncpy(self->lastError, aspell_error_message(ret), MAX_ERRSTR_LEN);
        return 0;
    }


    /* The config is no longer needed (check for errors here?) */
    delete_aspell_config(self->config);
    self->config = NULL;


    self->speller = to_aspell_speller(ret);
    self->config  = aspell_speller_config(self->speller);
    return 1;
}




#line 54 "Aspell.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

#line 97 "Aspell.c"

XS(XS_Text__Aspell_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0));
	Aspell_object *	RETVAL;
#line 54 "Aspell.xs"
        RETVAL = (Aspell_object*)safemalloc( sizeof( Aspell_object ) );

        if( RETVAL == NULL ){
            warn("unable to malloc Aspell_object");
            XSRETURN_UNDEF;
        }
        memset( RETVAL, 0, sizeof( Aspell_object ) );

        /*  create the configuration */
        RETVAL->config = new_aspell_config();

        /* Set initial default */
        /* 
         * aspell_config_replace(RETVAL->config, "language-tag", "en");
         * default language is 'EN' */

#line 129 "Aspell.c"
	ST(0) = sv_newmortal();
        sv_setref_pv( ST(0), CLASS, (void*)RETVAL );

    }
    XSRETURN(1);
}


XS(XS_Text__Aspell_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	Aspell_object *	self;

        if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
                self = INT2PTR (Aspell_object *, SvIV (SvRV (ST(0))));
        else{
                warn( "Text::Aspell::DESTROY() -- self is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };
#line 78 "Aspell.xs"
        if ( self->speller )
            delete_aspell_speller(self->speller);

        safefree( (char*)self );
#line 162 "Aspell.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Text__Aspell_create_speller); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_create_speller)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	Aspell_object *	self;
	int	RETVAL;
	dXSTARG;

        if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
                self = INT2PTR (Aspell_object *, SvIV (SvRV (ST(0))));
        else{
                warn( "Text::Aspell::create_speller() -- self is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };
#line 88 "Aspell.xs"
        if ( !_create_speller(self) )
            XSRETURN_UNDEF;

        RETVAL = 1;

#line 195 "Aspell.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Text__Aspell_print_config); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_print_config)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	Aspell_object *	self;
#line 100 "Aspell.xs"
        AspellKeyInfoEnumeration * key_list;
        const AspellKeyInfo * entry;
#line 217 "Aspell.c"
	int	RETVAL;
	dXSTARG;

        if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
                self = INT2PTR (Aspell_object *, SvIV (SvRV (ST(0))));
        else{
                warn( "Text::Aspell::print_config() -- self is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };
#line 103 "Aspell.xs"
        key_list = aspell_config_possible_elements( self->config, 0 );

        while ( (entry = aspell_key_info_enumeration_next(key_list) ) )
            PerlIO_printf(PerlIO_stdout(),"%20s:  %s\n", entry->name, aspell_config_retrieve(self->config, entry->name) );

        delete_aspell_key_info_enumeration(key_list);


        RETVAL = 1;

#line 238 "Aspell.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Text__Aspell_set_option); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_set_option)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "self, tag, val");
    {
	Aspell_object *	self;
	char *	tag = (char *)SvPV_nolen(ST(1));
	char *	val = (char *)SvPV_nolen(ST(2));
	int	RETVAL;
	dXSTARG;

        if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
                self = INT2PTR (Aspell_object *, SvIV (SvRV (ST(0))));
        else{
                warn( "Text::Aspell::set_option() -- self is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };
#line 123 "Aspell.xs"
        self->lastError[0] = '\0';

        aspell_config_replace(self->config, tag, val );

        if ( (self->errnum = aspell_config_error_number( self->config) ) )
        {
            strcpy(self->lastError, aspell_config_error_message( self->config ) );
            XSRETURN_UNDEF;
        }

        RETVAL = 1;
#line 280 "Aspell.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Text__Aspell_remove_option); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_remove_option)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, tag");
    {
	Aspell_object *	self;
	char *	tag = (char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

        if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
                self = INT2PTR (Aspell_object *, SvIV (SvRV (ST(0))));
        else{
                warn( "Text::Aspell::remove_option() -- self is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };
#line 144 "Aspell.xs"
        self->lastError[0] = '\0';

        aspell_config_remove(self->config, tag );

        if ( (self->errnum = aspell_config_error_number( self->config) ) )
        {
            strcpy(self->lastError, aspell_config_error_message( self->config ) );
            XSRETURN_UNDEF;
        }

        RETVAL = 1;
#line 321 "Aspell.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Text__Aspell_get_option); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_get_option)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, val");
    {
	Aspell_object *	self;
	char *	val = (char *)SvPV_nolen(ST(1));
	char *	RETVAL;
	dXSTARG;

        if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
                self = INT2PTR (Aspell_object *, SvIV (SvRV (ST(0))));
        else{
                warn( "Text::Aspell::get_option() -- self is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };
#line 163 "Aspell.xs"
        self->lastError[0] = '\0';

        RETVAL = (char *)aspell_config_retrieve(self->config, val);

        if ( (self->errnum = aspell_config_error_number( self->config) ) )
        {
            strcpy(self->lastError, aspell_config_error_message( self->config ) );
            XSRETURN_UNDEF;
        }

#line 361 "Aspell.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Text__Aspell_get_option_as_list); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_get_option_as_list)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, val");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Aspell_object *	self;
	char *	val = (char *)SvPV_nolen(ST(1));
#line 182 "Aspell.xs"
        AspellStringList        * lst   = new_aspell_string_list();
        AspellMutableContainer  * lst0  = aspell_string_list_to_mutable_container(lst);
        AspellStringEnumeration * els;
        const char              *option_value;

#line 389 "Aspell.c"

        if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
                self = INT2PTR (Aspell_object *, SvIV (SvRV (ST(0))));
        else{
                warn( "Text::Aspell::get_option_as_list() -- self is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };
#line 188 "Aspell.xs"
        if (!self->config )
            XSRETURN_UNDEF;

        aspell_config_retrieve_list(self->config, val, lst0);

        if ( (self->errnum = aspell_config_error_number( self->config) ) )
        {
            strncpy(self->lastError, aspell_config_error_message( self->config ), MAX_ERRSTR_LEN);
            delete_aspell_string_list(lst);
            XSRETURN_UNDEF;
        }

        els = aspell_string_list_elements(lst);

        while ( (option_value = aspell_string_enumeration_next(els)) != 0)
            XPUSHs(sv_2mortal(newSVpv( option_value ,0 )));


        delete_aspell_string_enumeration(els);
        delete_aspell_string_list(lst);
#line 418 "Aspell.c"
	PUTBACK;
	return;
    }
}


XS(XS_Text__Aspell_errstr); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_errstr)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	Aspell_object *	self;
	char *	RETVAL;
	dXSTARG;

        if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
                self = INT2PTR (Aspell_object *, SvIV (SvRV (ST(0))));
        else{
                warn( "Text::Aspell::errstr() -- self is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };
#line 214 "Aspell.xs"
        RETVAL = (char*) self->lastError;
#line 448 "Aspell.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Text__Aspell_errnum); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_errnum)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	Aspell_object *	self;
	int	RETVAL;
	dXSTARG;

        if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
                self = INT2PTR (Aspell_object *, SvIV (SvRV (ST(0))));
        else{
                warn( "Text::Aspell::errnum() -- self is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };
#line 222 "Aspell.xs"
        RETVAL = self->errnum;
#line 478 "Aspell.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Text__Aspell_check); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_check)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, word");
    {
	Aspell_object *	self;
	char *	word = (char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

        if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
                self = INT2PTR (Aspell_object *, SvIV (SvRV (ST(0))));
        else{
                warn( "Text::Aspell::check() -- self is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };
#line 232 "Aspell.xs"
        self->lastError[0] = '\0';
        self->errnum = 0;

        if (!self->speller && !_create_speller(self) )
            XSRETURN_UNDEF;

        RETVAL = aspell_speller_check(self->speller, word, -1);

        if ( aspell_speller_error( self->speller ) )
        {
            self->errnum = aspell_speller_error_number( self->speller );
            strncpy(self->lastError, aspell_speller_error_message( self->speller ), MAX_ERRSTR_LEN);
            XSRETURN_UNDEF;
        }
#line 522 "Aspell.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Text__Aspell_suggest); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_suggest)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, word");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Aspell_object *	self;
	char *	word = (char *)SvPV_nolen(ST(1));
#line 254 "Aspell.xs"
        const AspellWordList *wl;
        AspellStringEnumeration *els;
        const char *suggestion;
#line 548 "Aspell.c"

        if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
                self = INT2PTR (Aspell_object *, SvIV (SvRV (ST(0))));
        else{
                warn( "Text::Aspell::suggest() -- self is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };
#line 258 "Aspell.xs"
        self->lastError[0] = '\0';
        self->errnum = 0;


        if (!self->speller && !_create_speller(self) )
            XSRETURN_UNDEF;

        wl = aspell_speller_suggest(self->speller, word, -1);

        if (!wl)
        {
            self->errnum = aspell_speller_error_number( self->speller );
            strncpy(self->lastError, aspell_speller_error_message(self->speller), MAX_ERRSTR_LEN);
            XSRETURN_UNDEF;
        }



        els = aspell_word_list_elements(wl);


        while ( (suggestion = aspell_string_enumeration_next(els)) )
            XPUSHs(sv_2mortal(newSVpv( suggestion ,0 )));

        delete_aspell_string_enumeration(els);
#line 582 "Aspell.c"
	PUTBACK;
	return;
    }
}


XS(XS_Text__Aspell_add_to_personal); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_add_to_personal)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, word");
    {
	Aspell_object *	self;
	char *	word = (char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

        if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
                self = INT2PTR (Aspell_object *, SvIV (SvRV (ST(0))));
        else{
                warn( "Text::Aspell::add_to_personal() -- self is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };
#line 290 "Aspell.xs"
        self->lastError[0] = '\0';
        self->errnum = 0;

        if (!self->speller && !_create_speller(self) )
            XSRETURN_UNDEF;


        RETVAL = aspell_speller_add_to_personal(self->speller, word, -1);

        if ( aspell_speller_error( self->speller ) )
        {
            self->errnum = aspell_speller_error_number( self->speller );
            strncpy(self->lastError, aspell_speller_error_message(self->speller), MAX_ERRSTR_LEN);
            XSRETURN_UNDEF;
        }
#line 627 "Aspell.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Text__Aspell_add_to_session); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_add_to_session)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "self, word");
    {
	Aspell_object *	self;
	char *	word = (char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;

        if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
                self = INT2PTR (Aspell_object *, SvIV (SvRV (ST(0))));
        else{
                warn( "Text::Aspell::add_to_session() -- self is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };
#line 313 "Aspell.xs"
        self->lastError[0] = '\0';
        self->errnum = 0;

        if (!self->speller && !_create_speller(self) )
            XSRETURN_UNDEF;


        RETVAL = aspell_speller_add_to_session(self->speller, word, -1);

        if ( aspell_speller_error( self->speller ) )
        {
            self->errnum = aspell_speller_error_number( self->speller );
            strncpy(self->lastError, aspell_speller_error_message(self->speller), MAX_ERRSTR_LEN);
            XSRETURN_UNDEF;
        }
#line 672 "Aspell.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Text__Aspell_store_replacement); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_store_replacement)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "self, word, replacement");
    {
	Aspell_object *	self;
	char *	word = (char *)SvPV_nolen(ST(1));
	char *	replacement = (char *)SvPV_nolen(ST(2));
	int	RETVAL;
	dXSTARG;

        if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
                self = INT2PTR (Aspell_object *, SvIV (SvRV (ST(0))));
        else{
                warn( "Text::Aspell::store_replacement() -- self is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };
#line 339 "Aspell.xs"
        self->lastError[0] = '\0';
        self->errnum = 0;

        if (!self->speller && !_create_speller(self) )
            XSRETURN_UNDEF;


        RETVAL = aspell_speller_store_replacement(self->speller, word, -1, replacement, -1);

        if ( aspell_speller_error( self->speller ) )
        {
            self->errnum = aspell_speller_error_number( self->speller );
            strncpy(self->lastError, aspell_speller_error_message(self->speller), MAX_ERRSTR_LEN);
            XSRETURN_UNDEF;
        }
#line 718 "Aspell.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Text__Aspell_save_all_word_lists); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_save_all_word_lists)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	Aspell_object *	self;
	int	RETVAL;
	dXSTARG;

        if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
                self = INT2PTR (Aspell_object *, SvIV (SvRV (ST(0))));
        else{
                warn( "Text::Aspell::save_all_word_lists() -- self is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };
#line 361 "Aspell.xs"
        self->lastError[0] = '\0';
        self->errnum = 0;

        if (!self->speller && !_create_speller(self) )
            XSRETURN_UNDEF;


        RETVAL = aspell_speller_save_all_word_lists(self->speller);

        if ( aspell_speller_error( self->speller ) )
        {
            self->errnum = aspell_speller_error_number( self->speller );
            strncpy(self->lastError, aspell_speller_error_message(self->speller), MAX_ERRSTR_LEN);
            XSRETURN_UNDEF;
        }
#line 762 "Aspell.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Text__Aspell_clear_session); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_clear_session)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	Aspell_object *	self;
	int	RETVAL;
	dXSTARG;

        if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
                self = INT2PTR (Aspell_object *, SvIV (SvRV (ST(0))));
        else{
                warn( "Text::Aspell::clear_session() -- self is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };
#line 383 "Aspell.xs"
        self->lastError[0] = '\0';
        self->errnum = 0;

        if (!self->speller && !_create_speller(self) )
            XSRETURN_UNDEF;


        RETVAL = aspell_speller_clear_session(self->speller);

        if ( aspell_speller_error( self->speller ) )
        {
            self->errnum = aspell_speller_error_number( self->speller );
            strncpy(self->lastError, aspell_speller_error_message(self->speller), MAX_ERRSTR_LEN);
            XSRETURN_UNDEF;
        }
#line 806 "Aspell.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Text__Aspell_list_dictionaries); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_list_dictionaries)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Aspell_object *	self;
#line 406 "Aspell.xs"
        AspellDictInfoList * dlist;
        AspellDictInfoEnumeration * dels;
        const AspellDictInfo * entry;
#line 831 "Aspell.c"

        if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
                self = INT2PTR (Aspell_object *, SvIV (SvRV (ST(0))));
        else{
                warn( "Text::Aspell::list_dictionaries() -- self is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };
#line 410 "Aspell.xs"
        if (!self->config )
            XSRETURN_UNDEF;


        dlist = get_aspell_dict_info_list(self->config);
        dels = aspell_dict_info_list_elements(dlist);

        while ( (entry = aspell_dict_info_enumeration_next(dels)) != 0)
        {
            int  len;
            char *dictname;

            len = strlen( entry->name ) +
                  strlen( entry->jargon ) +
                  strlen( entry->code ) +
                  strlen( entry->size_str ) +
                  strlen( entry->module->name ) + 4;


            dictname = (char *)safemalloc( len + 1 );
            sprintf( dictname, "%s:%s:%s:%s:%s", entry->name, entry->code, entry->jargon, entry->size_str, entry->module->name );

            PUSHs(sv_2mortal(newSVpv( dictname ,0 )));
            safefree( dictname );
        }

        delete_aspell_dict_info_enumeration(dels);
#line 867 "Aspell.c"
	PUTBACK;
	return;
    }
}


XS(XS_Text__Aspell_dictionary_info); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_dictionary_info)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Aspell_object *	self;
#line 443 "Aspell.xs"
        AspellDictInfoList *dlist;
        AspellDictInfoEnumeration *dels;
        const AspellDictInfo *entry;
#line 892 "Aspell.c"

        if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
                self = INT2PTR (Aspell_object *, SvIV (SvRV (ST(0))));
        else{
                warn( "Text::Aspell::dictionary_info() -- self is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };
#line 448 "Aspell.xs"
        if (!self->config )  /* type map should catch this error, I'd think */
            XSRETURN_UNDEF;


        dlist = get_aspell_dict_info_list(self->config);
        dels = aspell_dict_info_list_elements(dlist);

        while ( (entry = aspell_dict_info_enumeration_next(dels)) != 0)
        {
            HV * dict_entry = newHV();

            if ( entry->name[0] )
                hv_store(dict_entry, "name",  4, newSVpv(entry->name,0),0);

            if ( entry->jargon[0] )
                hv_store(dict_entry, "jargon",6, newSVpv(entry->jargon,0),0);

            if ( entry->code[0] )
                hv_store(dict_entry, "code",  4, newSVpv(entry->code,0),0);

            if ( entry->code )
                hv_store(dict_entry, "size",  4, newSViv(entry->size),0);

            if ( entry->module->name[0] )
                hv_store(dict_entry, "module",6, newSVpv(entry->module->name,0),0);

            XPUSHs(sv_2mortal(newRV_noinc((SV*)dict_entry)));

        }

        delete_aspell_dict_info_enumeration(dels);
#line 932 "Aspell.c"
	PUTBACK;
	return;
    }
}


XS(XS_Text__Aspell_fetch_option_keys); /* prototype to pass -Wmissing-prototypes */
XS(XS_Text__Aspell_fetch_option_keys)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "self");
    {
	Aspell_object *	self;
#line 486 "Aspell.xs"
        AspellKeyInfoEnumeration * key_list;
        const AspellKeyInfo * entry;
        HV * option_hash;

#line 956 "Aspell.c"
	SV *	RETVAL;

        if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) )
                self = INT2PTR (Aspell_object *, SvIV (SvRV (ST(0))));
        else{
                warn( "Text::Aspell::fetch_option_keys() -- self is not a blessed SV reference" );
                XSRETURN_UNDEF;
        };
#line 491 "Aspell.xs"
        key_list = aspell_config_possible_elements( self->config, 0 );

        option_hash = newHV();

        while ( (entry = aspell_key_info_enumeration_next(key_list) ) )
        {
            HV * KeyInfo = newHV();

            hv_store(KeyInfo, "type",  4, newSViv((int)entry->type),0);

            if ( entry->def && entry->def[0] )
                hv_store(KeyInfo, "default", 7, newSVpv(entry->def,0),0);

            if ( entry->desc && entry->desc[0] )
                hv_store(KeyInfo, "desc",4, newSVpv(entry->desc,0),0);

            hv_store(option_hash, entry->name, strlen(entry->name), newRV_noinc((SV *)KeyInfo),0);
        }

        delete_aspell_key_info_enumeration(key_list);

        RETVAL = newRV_noinc((SV *)option_hash);

#line 989 "Aspell.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Text__Aspell); /* prototype to pass -Wmissing-prototypes */
XS(boot_Text__Aspell)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    const char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("Text::Aspell::new", XS_Text__Aspell_new, file);
        newXS("Text::Aspell::DESTROY", XS_Text__Aspell_DESTROY, file);
        newXS("Text::Aspell::create_speller", XS_Text__Aspell_create_speller, file);
        newXS("Text::Aspell::print_config", XS_Text__Aspell_print_config, file);
        newXS("Text::Aspell::set_option", XS_Text__Aspell_set_option, file);
        newXS("Text::Aspell::remove_option", XS_Text__Aspell_remove_option, file);
        newXS("Text::Aspell::get_option", XS_Text__Aspell_get_option, file);
        newXS("Text::Aspell::get_option_as_list", XS_Text__Aspell_get_option_as_list, file);
        newXS("Text::Aspell::errstr", XS_Text__Aspell_errstr, file);
        newXS("Text::Aspell::errnum", XS_Text__Aspell_errnum, file);
        newXS("Text::Aspell::check", XS_Text__Aspell_check, file);
        newXS("Text::Aspell::suggest", XS_Text__Aspell_suggest, file);
        newXS("Text::Aspell::add_to_personal", XS_Text__Aspell_add_to_personal, file);
        newXS("Text::Aspell::add_to_session", XS_Text__Aspell_add_to_session, file);
        newXS("Text::Aspell::store_replacement", XS_Text__Aspell_store_replacement, file);
        newXS("Text::Aspell::save_all_word_lists", XS_Text__Aspell_save_all_word_lists, file);
        newXS("Text::Aspell::clear_session", XS_Text__Aspell_clear_session, file);
        newXS("Text::Aspell::list_dictionaries", XS_Text__Aspell_list_dictionaries, file);
        newXS("Text::Aspell::dictionary_info", XS_Text__Aspell_dictionary_info, file);
        newXS("Text::Aspell::fetch_option_keys", XS_Text__Aspell_fetch_option_keys, file);
    if (PL_unitcheckav)
         call_list(PL_scopestack_ix, PL_unitcheckav);
    XSRETURN_YES;
}

