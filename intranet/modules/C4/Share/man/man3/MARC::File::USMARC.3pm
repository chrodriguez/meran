.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MARC::File::USMARC 3"
.TH MARC::File::USMARC 3 "2010-03-29" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MARC::File::USMARC \- USMARC\-specific file handling
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use MARC::File::USMARC;
\&
\&    my $file = MARC::File::USMARC\->in( $filename );
\&
\&    while ( my $marc = $file\->next() ) {
\&        # Do something
\&    }
\&    $file\->close();
\&    undef $file;
.Ve
.SH "EXPORT"
.IX Header "EXPORT"
None.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "decode( $string [, \e&filter_func ] )"
.el .SS "decode( \f(CW$string\fP [, \e&filter_func ] )"
.IX Subsection "decode( $string [, &filter_func ] )"
Constructor for handling data from a \s-1USMARC\s0 file.  This function takes care of
all the tag directory parsing & mangling.
.PP
Any warnings or coercions can be checked in the \f(CW\*(C`warnings()\*(C'\fR function.
.PP
The \f(CW$filter_func\fR is an optional reference to a user-supplied function
that determines on a tag-by-tag basis if you want the tag passed to it
to be put into the \s-1MARC\s0 record.  The function is passed the tag number
and the raw tag data, and must return a boolean.  The return of a true
value tells MARC::File::USMARC::decode that the tag should get put into
the resulting \s-1MARC\s0 record.
.PP
For example, if you only want title and subject tags in your \s-1MARC\s0 record,
try this:
.PP
.Vb 2
\&    sub filter {
\&        my ($tagno,$tagdata) = @_;
\&
\&        return ($tagno == 245) || ($tagno >= 600 && $tagno <= 699);
\&    }
\&
\&    my $marc = MARC::File::USMARC\->decode( $string, \e&filter );
.Ve
.PP
Why would you want to do such a thing?  The big reason is that creating
fields is processor-intensive, and if your program is doing read-only
data analysis and needs to be as fast as possible, you can save time by
not creating fields that you'll be ignoring anyway.
.PP
Another possible use is if you're only interested in printing certain
tags from the record, then you can filter them when you read from disc
and not have to delete unwanted tags yourself.
.SS "\fIupdate_leader()\fP"
.IX Subsection "update_leader()"
If any changes get made to the \s-1MARC\s0 record, the first 5 bytes of the
leader (the length) will be invalid.  This function updates the
leader with the correct length of the record as it would be if
written out to a file.
.SS "\fI_build_tag_directory()\fP"
.IX Subsection "_build_tag_directory()"
Function for internal use only: Builds the tag directory that gets
put in front of the data in a \s-1MARC\s0 record.
.PP
Returns two array references, and two lengths: The tag directory, and the data fields themselves,
the length of all data (including the Leader that we expect will be added),
and the size of the Leader and tag directory.
.SS "\fIencode()\fP"
.IX Subsection "encode()"
Returns a string of characters suitable for writing out to a \s-1USMARC\s0 file,
including the leader, directory and all the fields.
.SH "RELATED MODULES"
.IX Header "RELATED MODULES"
MARC::Record
.SH "TODO"
.IX Header "TODO"
Make some sort of autodispatch so that you don't have to explicitly
specify the MARC::File::X subclass, sort of like how \s-1DBI\s0 knows to
use DBD::Oracle or DBD::Mysql.
.PP
Create a toggle-able option to check inside the field data for
end of field characters.  Presumably it would be good to have
it turned on all the time, but it's nice to be able to opt out
if you don't want to take the performance hit.
.SH "LICENSE"
.IX Header "LICENSE"
This code may be distributed under the same terms as Perl itself.
.PP
Please note that these modules are not products of or supported by the
employers of the various contributors to the code.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Lester, \f(CW\*(C`<andy@petdance.com>\*(C'\fR
